/*
 *   Generated by blitz/templates/resouces/combined.vm
 *
 *   Copyright 2007 Glencoe Software, Inc. All rights reserved.
 *   Use is subject to license terms supplied in LICENSE.txt
 *
 */
#include <omero/model/CommentAnnotationI.h>
namespace omero { 
  namespace model {
      void CommentAnnotationI::errorIfUnloaded()
      {
        if (! loaded ) throw omero::UnloadedEntityException(__FILE__,__LINE__,"Object unloaded");
      }
      void CommentAnnotationI::throwNullCollectionException(std::string propertyName)
      {
        std::string s = "Error updating collection:" + propertyName +"\n"+
        "Collection is currently null. This can be seen\n"+
        "by testing \""+ propertyName +"Loaded\". This implies\n"+
        "that this collection was unloaded. Please refresh this object\n"+
        "in order to update this collection.\n";
        throw omero::UnloadedCollectionException(
           __FILE__,__LINE__,s.c_str());
      }
    CommentAnnotationI::~CommentAnnotationI() {}
      CommentAnnotationI::CommentAnnotationI() : CommentAnnotation() {
          loaded = true;
          toggleCollectionsLoaded(true);
          details = new omero::model::DetailsI();
      }
   void CommentAnnotationI::toggleCollectionsLoaded(bool load) {
          if (load) {
              annotationLinks = CommentAnnotationAnnotationLinksSeq();
              annotationLinksLoaded = true;
          } else {
              annotationLinks = (CommentAnnotationAnnotationLinksSeq)0;
              annotationLinksLoaded = false;
          }
   }
   CommentAnnotationI::CommentAnnotationI(omero::RLongPtr idPtr, bool isLoaded) : CommentAnnotation() {
     id = idPtr;
     loaded = isLoaded;
     if (loaded) details = new omero::model::DetailsI(); 
     toggleCollectionsLoaded(isLoaded);
   }
      void CommentAnnotationI::unload(const Ice::Current& current) {
          loaded = false;
          unloadTextValue( );
          unloadNs( );
          unloadAnnotationLinks( );
          unloadDetails( );
   }
      omero::RLongPtr CommentAnnotationI::getId() {
          return id;
      }

      void CommentAnnotationI::setId(omero::RLongPtr _id) {
          id = _id;
      }
      void CommentAnnotationI::unloadTextValue() {
          
          textValue = (omero::RStringPtr) 0;
      }
      omero::RStringPtr CommentAnnotationI::getTextValue() {
          errorIfUnloaded();
          return  textValue ;
      }

      void CommentAnnotationI::setTextValue(omero::RStringPtr _textValue) {
          errorIfUnloaded();
          textValue =  _textValue ;
           
      }
      void CommentAnnotationI::unloadNs() {
          
          ns = (omero::RStringPtr) 0;
      }
      omero::RStringPtr CommentAnnotationI::getNs() {
          errorIfUnloaded();
          return  ns ;
      }

      void CommentAnnotationI::setNs(omero::RStringPtr _ns) {
          errorIfUnloaded();
          ns =  _ns ;
           
      }
      void CommentAnnotationI::unloadAnnotationLinks() {
          annotationLinksLoaded = false;
          annotationLinks = (AnnotationAnnotationLinksSeq) 0;
      }
      AnnotationAnnotationLinksSeq CommentAnnotationI::getAnnotationLinks() {
          errorIfUnloaded();
          return  annotationLinks ;
      }

      void CommentAnnotationI::setAnnotationLinks(AnnotationAnnotationLinksSeq _annotationLinks) {
          errorIfUnloaded();
          annotationLinks =  _annotationLinks ;
          if (_annotationLinks != (AnnotationAnnotationLinksSeq) 0) { annotationLinksLoaded = true; } else { annotationLinksLoaded = false; }
      }
      bool CommentAnnotationI::isAnnotationLinksLoaded( ) {
          return annotationLinksLoaded;
      }
      Ice::Long CommentAnnotationI::sizeOfAnnotationLinks( ) {
          errorIfUnloaded();
          if (!annotationLinksLoaded) return -1l;
          return annotationLinks.size();
      }
      AnnotationAnnotationLinksSeq::iterator CommentAnnotationI::beginAnnotationLinks(){
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          return annotationLinks.begin();
      }
      AnnotationAnnotationLinksSeq::iterator CommentAnnotationI::endAnnotationLinks(){
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          return annotationLinks.end();
      } 
      AnnotationAnnotationLinksSeq CommentAnnotationI::copyAnnotationLinks() {
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          AnnotationAnnotationLinksSeq result(annotationLinks.size());
          std::copy(annotationLinks.begin(), annotationLinks.end(), result.begin());
          return result;
      }
      void CommentAnnotationI::addAnnotationAnnotationLink(AnnotationAnnotationLinkPtr target) {
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          annotationLinks.push_back( target );
          target->parent = this;
      }
      void CommentAnnotationI::addAnnotationAnnotationLinkSet(AnnotationAnnotationLinksSeq targets) {
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          AnnotationAnnotationLinksSeq::iterator loc = annotationLinks.end();
          AnnotationAnnotationLinksSeq::iterator beg = targets.begin(); 
          AnnotationAnnotationLinksSeq::iterator end = targets.end(); 
          annotationLinks.insert(loc,beg,end);
          for (AnnotationAnnotationLinksSeq::iterator it = targets.begin(); it != targets.end(); ++it) {
              AnnotationAnnotationLinkPtr target = *it;
              target->parent = this;
          }
      }
      struct testRemoveAnnotationAnnotationLinkFromCommentAnnotationI
      {
          const AnnotationAnnotationLinkPtr t;
          testRemoveAnnotationAnnotationLinkFromCommentAnnotationI(const AnnotationAnnotationLinkPtr n) : t(n) {}
          bool operator()(AnnotationAnnotationLinkPtr const& o) {
              return o == t;
          }
      };
      void CommentAnnotationI::removeAnnotationAnnotationLink(AnnotationAnnotationLinkPtr target) {
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          AnnotationAnnotationLinksSeq::iterator it = std::remove_if(
              annotationLinks.begin(),
              annotationLinks.end(),
              testRemoveAnnotationAnnotationLinkFromCommentAnnotationI(target));
          annotationLinks.erase(it,annotationLinks.end());
          target->parent = (CommentAnnotationIPtr)0;
      }
      struct testRemoveAnnotationAnnotationLinkSetFromCommentAnnotationI
      {
          const AnnotationAnnotationLinksSeq t;
          testRemoveAnnotationAnnotationLinkSetFromCommentAnnotationI(const AnnotationAnnotationLinksSeq n) : t(n) {}
          bool operator()(AnnotationAnnotationLinkPtr const& o) {
              return std::find(t.begin(), t.end(), o) != t.end();
          }
      };
      void CommentAnnotationI::removeAnnotationAnnotationLinkSet(AnnotationAnnotationLinksSeq targets) {
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          AnnotationAnnotationLinksSeq::iterator end = annotationLinks.end();
          AnnotationAnnotationLinksSeq::iterator removed = std::remove_if(
              annotationLinks.begin(), end,
              testRemoveAnnotationAnnotationLinkSetFromCommentAnnotationI(targets));
          AnnotationAnnotationLinksSeq::iterator beg(removed);
          for(; beg != end; beg++) {
              (*beg)->parent = (CommentAnnotationIPtr)0;
          }
          annotationLinks.erase(removed,end);
      }
      void CommentAnnotationI::clearAnnotationLinks() {
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          AnnotationAnnotationLinksSeq::iterator beg = annotationLinks.begin();
          AnnotationAnnotationLinksSeq::iterator end = annotationLinks.end();
          for(; beg != end; beg++) {
              (*beg)->parent = (CommentAnnotationIPtr)0;
          }
          annotationLinks.clear();
      }
      void CommentAnnotationI::linkAnnotation(const AnnotationPtr& addition) {
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          AnnotationAnnotationLinkIPtr link = new AnnotationAnnotationLinkI();
          link->link( this, addition );
          addAnnotationAnnotationLink( link, true );
      }
      void CommentAnnotationI::addAnnotationAnnotationLink(const AnnotationAnnotationLinkPtr& link, bool bothSides, const Ice::Current& current) {
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          annotationLinks.push_back( link );
          if (bothSides && link->child->loaded ) {
              AnnotationPtr::dynamicCast(link->child)->addAnnotationAnnotationLink( link, false );
          }
      }  
      std::vector<AnnotationAnnotationLinkPtr> CommentAnnotationI::findAnnotationAnnotationLink(AnnotationPtr removal) {
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          std::vector<AnnotationAnnotationLinkPtr> result;
          AnnotationAnnotationLinksSeq::iterator beg = beginAnnotationLinks();
          AnnotationAnnotationLinksSeq::iterator end = endAnnotationLinks();
          while (beg != end) {
              if ((*beg)->child == removal) result.push_back( *beg );
              ++beg;
          }
          return result;
      }  

      struct testRemoveAnnotationFromCommentAnnotationI {

        const AnnotationAnnotationLinkPtr t;
        const bool bothSides;
        testRemoveAnnotationFromCommentAnnotationI(const AnnotationAnnotationLinkPtr n, const bool b) : t(n), bothSides(b) {}
        bool operator()(AnnotationAnnotationLinkPtr const& o) {
           if (o == t) {
               if (bothSides && t->child->loaded){
                   AnnotationPtr::dynamicCast(o->child)->removeAnnotationAnnotationLink(t,false);
               }
               return true;
           }
           return false;
        }
      }; 

      void CommentAnnotationI::unlinkAnnotation(const AnnotationPtr& removal) {
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          std::vector<AnnotationAnnotationLinkPtr> toRemove = findAnnotationAnnotationLink(removal);
          AnnotationAnnotationLinksSeq::iterator beg = toRemove.begin();
          AnnotationAnnotationLinksSeq::iterator end = toRemove.end();
          while (beg != end) {
            removeAnnotationAnnotationLink( *beg, true );
            ++beg;
          }
      }
      void CommentAnnotationI::removeAnnotationAnnotationLink(const AnnotationAnnotationLinkPtr& link, bool bothSides, const Ice::Current& current) {
          errorIfUnloaded();
          if (!annotationLinksLoaded) throwNullCollectionException("annotationLinks");
          // predicate may do reverse side
          AnnotationAnnotationLinksSeq::iterator it = std::remove_if(
              annotationLinks.begin(),
              annotationLinks.end(),
              testRemoveAnnotationFromCommentAnnotationI(link, bothSides));
          annotationLinks.erase(it,annotationLinks.end());
      } 
      void CommentAnnotationI::unloadDetails() {
          
          details = (omero::model::DetailsPtr) 0;
      }
      omero::model::DetailsPtr CommentAnnotationI::getDetails() {
          errorIfUnloaded();
          return  details ;
      }

      void CommentAnnotationI::setDetails(omero::model::DetailsPtr _details) {
          errorIfUnloaded();
          details =  _details ;
           
      }
}}
