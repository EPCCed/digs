/* soapC.c
   Generated by gSOAP 2.7.15 from srm2_2.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.15 2010-02-01 14:30:38 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header));
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns1__TStatusCode:
		return soap_in_ns1__TStatusCode(soap, NULL, NULL, "ns1:TStatusCode");
	case SOAP_TYPE_ns1__TConnectionType:
		return soap_in_ns1__TConnectionType(soap, NULL, NULL, "ns1:TConnectionType");
	case SOAP_TYPE_ns1__TAccessPattern:
		return soap_in_ns1__TAccessPattern(soap, NULL, NULL, "ns1:TAccessPattern");
	case SOAP_TYPE_ns1__TFileLocality:
		return soap_in_ns1__TFileLocality(soap, NULL, NULL, "ns1:TFileLocality");
	case SOAP_TYPE_ns1__TOverwriteMode:
		return soap_in_ns1__TOverwriteMode(soap, NULL, NULL, "ns1:TOverwriteMode");
	case SOAP_TYPE_ns1__TRequestType:
		return soap_in_ns1__TRequestType(soap, NULL, NULL, "ns1:TRequestType");
	case SOAP_TYPE_ns1__TPermissionType:
		return soap_in_ns1__TPermissionType(soap, NULL, NULL, "ns1:TPermissionType");
	case SOAP_TYPE_ns1__TPermissionMode:
		return soap_in_ns1__TPermissionMode(soap, NULL, NULL, "ns1:TPermissionMode");
	case SOAP_TYPE_ns1__TAccessLatency:
		return soap_in_ns1__TAccessLatency(soap, NULL, NULL, "ns1:TAccessLatency");
	case SOAP_TYPE_ns1__TRetentionPolicy:
		return soap_in_ns1__TRetentionPolicy(soap, NULL, NULL, "ns1:TRetentionPolicy");
	case SOAP_TYPE_ns1__TFileType:
		return soap_in_ns1__TFileType(soap, NULL, NULL, "ns1:TFileType");
	case SOAP_TYPE_ns1__TFileStorageType:
		return soap_in_ns1__TFileStorageType(soap, NULL, NULL, "ns1:TFileStorageType");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__srmPing:
		return soap_in_ns1__srmPing(soap, NULL, NULL, "ns1:srmPing");
	case SOAP_TYPE_ns1__srmPingResponse_:
		return soap_in_ns1__srmPingResponse_(soap, NULL, NULL, "ns1:srmPingResponse");
	case SOAP_TYPE_ns1__srmGetTransferProtocols:
		return soap_in_ns1__srmGetTransferProtocols(soap, NULL, NULL, "ns1:srmGetTransferProtocols");
	case SOAP_TYPE_ns1__srmGetTransferProtocolsResponse_:
		return soap_in_ns1__srmGetTransferProtocolsResponse_(soap, NULL, NULL, "ns1:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_ns1__srmGetRequestTokens:
		return soap_in_ns1__srmGetRequestTokens(soap, NULL, NULL, "ns1:srmGetRequestTokens");
	case SOAP_TYPE_ns1__srmGetRequestTokensResponse_:
		return soap_in_ns1__srmGetRequestTokensResponse_(soap, NULL, NULL, "ns1:srmGetRequestTokensResponse");
	case SOAP_TYPE_ns1__srmExtendFileLifeTime:
		return soap_in_ns1__srmExtendFileLifeTime(soap, NULL, NULL, "ns1:srmExtendFileLifeTime");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse_:
		return soap_in_ns1__srmExtendFileLifeTimeResponse_(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_ns1__srmGetRequestSummary:
		return soap_in_ns1__srmGetRequestSummary(soap, NULL, NULL, "ns1:srmGetRequestSummary");
	case SOAP_TYPE_ns1__srmGetRequestSummaryResponse_:
		return soap_in_ns1__srmGetRequestSummaryResponse_(soap, NULL, NULL, "ns1:srmGetRequestSummaryResponse");
	case SOAP_TYPE_ns1__srmResumeRequest:
		return soap_in_ns1__srmResumeRequest(soap, NULL, NULL, "ns1:srmResumeRequest");
	case SOAP_TYPE_ns1__srmResumeRequestResponse_:
		return soap_in_ns1__srmResumeRequestResponse_(soap, NULL, NULL, "ns1:srmResumeRequestResponse");
	case SOAP_TYPE_ns1__srmSuspendRequest:
		return soap_in_ns1__srmSuspendRequest(soap, NULL, NULL, "ns1:srmSuspendRequest");
	case SOAP_TYPE_ns1__srmSuspendRequestResponse_:
		return soap_in_ns1__srmSuspendRequestResponse_(soap, NULL, NULL, "ns1:srmSuspendRequestResponse");
	case SOAP_TYPE_ns1__srmAbortFiles:
		return soap_in_ns1__srmAbortFiles(soap, NULL, NULL, "ns1:srmAbortFiles");
	case SOAP_TYPE_ns1__srmAbortFilesResponse_:
		return soap_in_ns1__srmAbortFilesResponse_(soap, NULL, NULL, "ns1:srmAbortFilesResponse");
	case SOAP_TYPE_ns1__srmAbortRequest:
		return soap_in_ns1__srmAbortRequest(soap, NULL, NULL, "ns1:srmAbortRequest");
	case SOAP_TYPE_ns1__srmAbortRequestResponse_:
		return soap_in_ns1__srmAbortRequestResponse_(soap, NULL, NULL, "ns1:srmAbortRequestResponse");
	case SOAP_TYPE_ns1__srmPutDone:
		return soap_in_ns1__srmPutDone(soap, NULL, NULL, "ns1:srmPutDone");
	case SOAP_TYPE_ns1__srmPutDoneResponse_:
		return soap_in_ns1__srmPutDoneResponse_(soap, NULL, NULL, "ns1:srmPutDoneResponse");
	case SOAP_TYPE_ns1__srmReleaseFiles:
		return soap_in_ns1__srmReleaseFiles(soap, NULL, NULL, "ns1:srmReleaseFiles");
	case SOAP_TYPE_ns1__srmReleaseFilesResponse_:
		return soap_in_ns1__srmReleaseFilesResponse_(soap, NULL, NULL, "ns1:srmReleaseFilesResponse");
	case SOAP_TYPE_ns1__srmStatusOfCopyRequest:
		return soap_in_ns1__srmStatusOfCopyRequest(soap, NULL, NULL, "ns1:srmStatusOfCopyRequest");
	case SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse_:
		return soap_in_ns1__srmStatusOfCopyRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_ns1__srmCopy:
		return soap_in_ns1__srmCopy(soap, NULL, NULL, "ns1:srmCopy");
	case SOAP_TYPE_ns1__srmCopyResponse_:
		return soap_in_ns1__srmCopyResponse_(soap, NULL, NULL, "ns1:srmCopyResponse");
	case SOAP_TYPE_ns1__srmStatusOfPutRequest:
		return soap_in_ns1__srmStatusOfPutRequest(soap, NULL, NULL, "ns1:srmStatusOfPutRequest");
	case SOAP_TYPE_ns1__srmStatusOfPutRequestResponse_:
		return soap_in_ns1__srmStatusOfPutRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_ns1__srmPrepareToPut:
		return soap_in_ns1__srmPrepareToPut(soap, NULL, NULL, "ns1:srmPrepareToPut");
	case SOAP_TYPE_ns1__srmPrepareToPutResponse_:
		return soap_in_ns1__srmPrepareToPutResponse_(soap, NULL, NULL, "ns1:srmPrepareToPutResponse");
	case SOAP_TYPE_ns1__srmStatusOfBringOnlineRequest:
		return soap_in_ns1__srmStatusOfBringOnlineRequest(soap, NULL, NULL, "ns1:srmStatusOfBringOnlineRequest");
	case SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse_:
		return soap_in_ns1__srmStatusOfBringOnlineRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_ns1__srmBringOnline:
		return soap_in_ns1__srmBringOnline(soap, NULL, NULL, "ns1:srmBringOnline");
	case SOAP_TYPE_ns1__srmBringOnlineResponse_:
		return soap_in_ns1__srmBringOnlineResponse_(soap, NULL, NULL, "ns1:srmBringOnlineResponse");
	case SOAP_TYPE_ns1__srmStatusOfGetRequest:
		return soap_in_ns1__srmStatusOfGetRequest(soap, NULL, NULL, "ns1:srmStatusOfGetRequest");
	case SOAP_TYPE_ns1__srmStatusOfGetRequestResponse_:
		return soap_in_ns1__srmStatusOfGetRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_ns1__srmPrepareToGet:
		return soap_in_ns1__srmPrepareToGet(soap, NULL, NULL, "ns1:srmPrepareToGet");
	case SOAP_TYPE_ns1__srmPrepareToGetResponse_:
		return soap_in_ns1__srmPrepareToGetResponse_(soap, NULL, NULL, "ns1:srmPrepareToGetResponse");
	case SOAP_TYPE_ns1__srmMv:
		return soap_in_ns1__srmMv(soap, NULL, NULL, "ns1:srmMv");
	case SOAP_TYPE_ns1__srmMvResponse_:
		return soap_in_ns1__srmMvResponse_(soap, NULL, NULL, "ns1:srmMvResponse");
	case SOAP_TYPE_ns1__srmStatusOfLsRequest:
		return soap_in_ns1__srmStatusOfLsRequest(soap, NULL, NULL, "ns1:srmStatusOfLsRequest");
	case SOAP_TYPE_ns1__srmStatusOfLsRequestResponse_:
		return soap_in_ns1__srmStatusOfLsRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_ns1__srmLs:
		return soap_in_ns1__srmLs(soap, NULL, NULL, "ns1:srmLs");
	case SOAP_TYPE_ns1__srmLsResponse_:
		return soap_in_ns1__srmLsResponse_(soap, NULL, NULL, "ns1:srmLsResponse");
	case SOAP_TYPE_ns1__srmRm:
		return soap_in_ns1__srmRm(soap, NULL, NULL, "ns1:srmRm");
	case SOAP_TYPE_ns1__srmRmResponse_:
		return soap_in_ns1__srmRmResponse_(soap, NULL, NULL, "ns1:srmRmResponse");
	case SOAP_TYPE_ns1__srmRmdir:
		return soap_in_ns1__srmRmdir(soap, NULL, NULL, "ns1:srmRmdir");
	case SOAP_TYPE_ns1__srmRmdirResponse_:
		return soap_in_ns1__srmRmdirResponse_(soap, NULL, NULL, "ns1:srmRmdirResponse");
	case SOAP_TYPE_ns1__srmMkdir:
		return soap_in_ns1__srmMkdir(soap, NULL, NULL, "ns1:srmMkdir");
	case SOAP_TYPE_ns1__srmMkdirResponse_:
		return soap_in_ns1__srmMkdirResponse_(soap, NULL, NULL, "ns1:srmMkdirResponse");
	case SOAP_TYPE_ns1__srmGetPermission:
		return soap_in_ns1__srmGetPermission(soap, NULL, NULL, "ns1:srmGetPermission");
	case SOAP_TYPE_ns1__srmGetPermissionResponse_:
		return soap_in_ns1__srmGetPermissionResponse_(soap, NULL, NULL, "ns1:srmGetPermissionResponse");
	case SOAP_TYPE_ns1__srmCheckPermission:
		return soap_in_ns1__srmCheckPermission(soap, NULL, NULL, "ns1:srmCheckPermission");
	case SOAP_TYPE_ns1__srmCheckPermissionResponse_:
		return soap_in_ns1__srmCheckPermissionResponse_(soap, NULL, NULL, "ns1:srmCheckPermissionResponse");
	case SOAP_TYPE_ns1__srmSetPermission:
		return soap_in_ns1__srmSetPermission(soap, NULL, NULL, "ns1:srmSetPermission");
	case SOAP_TYPE_ns1__srmSetPermissionResponse_:
		return soap_in_ns1__srmSetPermissionResponse_(soap, NULL, NULL, "ns1:srmSetPermissionResponse");
	case SOAP_TYPE_ns1__srmGetSpaceTokens:
		return soap_in_ns1__srmGetSpaceTokens(soap, NULL, NULL, "ns1:srmGetSpaceTokens");
	case SOAP_TYPE_ns1__srmGetSpaceTokensResponse_:
		return soap_in_ns1__srmGetSpaceTokensResponse_(soap, NULL, NULL, "ns1:srmGetSpaceTokensResponse");
	case SOAP_TYPE_ns1__srmPurgeFromSpace:
		return soap_in_ns1__srmPurgeFromSpace(soap, NULL, NULL, "ns1:srmPurgeFromSpace");
	case SOAP_TYPE_ns1__srmPurgeFromSpaceResponse_:
		return soap_in_ns1__srmPurgeFromSpaceResponse_(soap, NULL, NULL, "ns1:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpace:
		return soap_in_ns1__srmExtendFileLifeTimeInSpace(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeInSpace");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse_:
		return soap_in_ns1__srmExtendFileLifeTimeInSpaceResponse_(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequest:
		return soap_in_ns1__srmStatusOfChangeSpaceForFilesRequest(soap, NULL, NULL, "ns1:srmStatusOfChangeSpaceForFilesRequest");
	case SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_:
		return soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_ns1__srmChangeSpaceForFiles:
		return soap_in_ns1__srmChangeSpaceForFiles(soap, NULL, NULL, "ns1:srmChangeSpaceForFiles");
	case SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse_:
		return soap_in_ns1__srmChangeSpaceForFilesResponse_(soap, NULL, NULL, "ns1:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_ns1__srmGetSpaceMetaData:
		return soap_in_ns1__srmGetSpaceMetaData(soap, NULL, NULL, "ns1:srmGetSpaceMetaData");
	case SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse_:
		return soap_in_ns1__srmGetSpaceMetaDataResponse_(soap, NULL, NULL, "ns1:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequest:
		return soap_in_ns1__srmStatusOfUpdateSpaceRequest(soap, NULL, NULL, "ns1:srmStatusOfUpdateSpaceRequest");
	case SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse_:
		return soap_in_ns1__srmStatusOfUpdateSpaceRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_ns1__srmUpdateSpace:
		return soap_in_ns1__srmUpdateSpace(soap, NULL, NULL, "ns1:srmUpdateSpace");
	case SOAP_TYPE_ns1__srmUpdateSpaceResponse_:
		return soap_in_ns1__srmUpdateSpaceResponse_(soap, NULL, NULL, "ns1:srmUpdateSpaceResponse");
	case SOAP_TYPE_ns1__srmReleaseSpace:
		return soap_in_ns1__srmReleaseSpace(soap, NULL, NULL, "ns1:srmReleaseSpace");
	case SOAP_TYPE_ns1__srmReleaseSpaceResponse_:
		return soap_in_ns1__srmReleaseSpaceResponse_(soap, NULL, NULL, "ns1:srmReleaseSpaceResponse");
	case SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequest:
		return soap_in_ns1__srmStatusOfReserveSpaceRequest(soap, NULL, NULL, "ns1:srmStatusOfReserveSpaceRequest");
	case SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse_:
		return soap_in_ns1__srmStatusOfReserveSpaceRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_ns1__srmReserveSpace:
		return soap_in_ns1__srmReserveSpace(soap, NULL, NULL, "ns1:srmReserveSpace");
	case SOAP_TYPE_ns1__srmReserveSpaceResponse_:
		return soap_in_ns1__srmReserveSpaceResponse_(soap, NULL, NULL, "ns1:srmReserveSpaceResponse");
	case SOAP_TYPE_ns1__srmPingResponse:
		return soap_in_ns1__srmPingResponse(soap, NULL, NULL, "ns1:srmPingResponse");
	case SOAP_TYPE_ns1__srmPingRequest:
		return soap_in_ns1__srmPingRequest(soap, NULL, NULL, "ns1:srmPingRequest");
	case SOAP_TYPE_ns1__srmGetTransferProtocolsResponse:
		return soap_in_ns1__srmGetTransferProtocolsResponse(soap, NULL, NULL, "ns1:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_ns1__srmGetTransferProtocolsRequest:
		return soap_in_ns1__srmGetTransferProtocolsRequest(soap, NULL, NULL, "ns1:srmGetTransferProtocolsRequest");
	case SOAP_TYPE_ns1__srmGetRequestTokensResponse:
		return soap_in_ns1__srmGetRequestTokensResponse(soap, NULL, NULL, "ns1:srmGetRequestTokensResponse");
	case SOAP_TYPE_ns1__srmGetRequestTokensRequest:
		return soap_in_ns1__srmGetRequestTokensRequest(soap, NULL, NULL, "ns1:srmGetRequestTokensRequest");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse:
		return soap_in_ns1__srmExtendFileLifeTimeResponse(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeRequest:
		return soap_in_ns1__srmExtendFileLifeTimeRequest(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeRequest");
	case SOAP_TYPE_ns1__srmGetRequestSummaryResponse:
		return soap_in_ns1__srmGetRequestSummaryResponse(soap, NULL, NULL, "ns1:srmGetRequestSummaryResponse");
	case SOAP_TYPE_ns1__srmGetRequestSummaryRequest:
		return soap_in_ns1__srmGetRequestSummaryRequest(soap, NULL, NULL, "ns1:srmGetRequestSummaryRequest");
	case SOAP_TYPE_ns1__srmResumeRequestResponse:
		return soap_in_ns1__srmResumeRequestResponse(soap, NULL, NULL, "ns1:srmResumeRequestResponse");
	case SOAP_TYPE_ns1__srmResumeRequestRequest:
		return soap_in_ns1__srmResumeRequestRequest(soap, NULL, NULL, "ns1:srmResumeRequestRequest");
	case SOAP_TYPE_ns1__srmSuspendRequestResponse:
		return soap_in_ns1__srmSuspendRequestResponse(soap, NULL, NULL, "ns1:srmSuspendRequestResponse");
	case SOAP_TYPE_ns1__srmSuspendRequestRequest:
		return soap_in_ns1__srmSuspendRequestRequest(soap, NULL, NULL, "ns1:srmSuspendRequestRequest");
	case SOAP_TYPE_ns1__srmAbortFilesResponse:
		return soap_in_ns1__srmAbortFilesResponse(soap, NULL, NULL, "ns1:srmAbortFilesResponse");
	case SOAP_TYPE_ns1__srmAbortFilesRequest:
		return soap_in_ns1__srmAbortFilesRequest(soap, NULL, NULL, "ns1:srmAbortFilesRequest");
	case SOAP_TYPE_ns1__srmAbortRequestResponse:
		return soap_in_ns1__srmAbortRequestResponse(soap, NULL, NULL, "ns1:srmAbortRequestResponse");
	case SOAP_TYPE_ns1__srmAbortRequestRequest:
		return soap_in_ns1__srmAbortRequestRequest(soap, NULL, NULL, "ns1:srmAbortRequestRequest");
	case SOAP_TYPE_ns1__srmPutDoneResponse:
		return soap_in_ns1__srmPutDoneResponse(soap, NULL, NULL, "ns1:srmPutDoneResponse");
	case SOAP_TYPE_ns1__srmPutDoneRequest:
		return soap_in_ns1__srmPutDoneRequest(soap, NULL, NULL, "ns1:srmPutDoneRequest");
	case SOAP_TYPE_ns1__srmReleaseFilesResponse:
		return soap_in_ns1__srmReleaseFilesResponse(soap, NULL, NULL, "ns1:srmReleaseFilesResponse");
	case SOAP_TYPE_ns1__srmReleaseFilesRequest:
		return soap_in_ns1__srmReleaseFilesRequest(soap, NULL, NULL, "ns1:srmReleaseFilesRequest");
	case SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse:
		return soap_in_ns1__srmStatusOfCopyRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfCopyRequestRequest:
		return soap_in_ns1__srmStatusOfCopyRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfCopyRequestRequest");
	case SOAP_TYPE_ns1__srmCopyResponse:
		return soap_in_ns1__srmCopyResponse(soap, NULL, NULL, "ns1:srmCopyResponse");
	case SOAP_TYPE_ns1__srmCopyRequest:
		return soap_in_ns1__srmCopyRequest(soap, NULL, NULL, "ns1:srmCopyRequest");
	case SOAP_TYPE_ns1__srmStatusOfPutRequestResponse:
		return soap_in_ns1__srmStatusOfPutRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfPutRequestRequest:
		return soap_in_ns1__srmStatusOfPutRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfPutRequestRequest");
	case SOAP_TYPE_ns1__srmPrepareToPutResponse:
		return soap_in_ns1__srmPrepareToPutResponse(soap, NULL, NULL, "ns1:srmPrepareToPutResponse");
	case SOAP_TYPE_ns1__srmPrepareToPutRequest:
		return soap_in_ns1__srmPrepareToPutRequest(soap, NULL, NULL, "ns1:srmPrepareToPutRequest");
	case SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse:
		return soap_in_ns1__srmStatusOfBringOnlineRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestRequest:
		return soap_in_ns1__srmStatusOfBringOnlineRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfBringOnlineRequestRequest");
	case SOAP_TYPE_ns1__srmBringOnlineResponse:
		return soap_in_ns1__srmBringOnlineResponse(soap, NULL, NULL, "ns1:srmBringOnlineResponse");
	case SOAP_TYPE_ns1__srmBringOnlineRequest:
		return soap_in_ns1__srmBringOnlineRequest(soap, NULL, NULL, "ns1:srmBringOnlineRequest");
	case SOAP_TYPE_ns1__srmStatusOfGetRequestResponse:
		return soap_in_ns1__srmStatusOfGetRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfGetRequestRequest:
		return soap_in_ns1__srmStatusOfGetRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfGetRequestRequest");
	case SOAP_TYPE_ns1__srmPrepareToGetResponse:
		return soap_in_ns1__srmPrepareToGetResponse(soap, NULL, NULL, "ns1:srmPrepareToGetResponse");
	case SOAP_TYPE_ns1__srmPrepareToGetRequest:
		return soap_in_ns1__srmPrepareToGetRequest(soap, NULL, NULL, "ns1:srmPrepareToGetRequest");
	case SOAP_TYPE_ns1__srmMvResponse:
		return soap_in_ns1__srmMvResponse(soap, NULL, NULL, "ns1:srmMvResponse");
	case SOAP_TYPE_ns1__srmMvRequest:
		return soap_in_ns1__srmMvRequest(soap, NULL, NULL, "ns1:srmMvRequest");
	case SOAP_TYPE_ns1__srmStatusOfLsRequestResponse:
		return soap_in_ns1__srmStatusOfLsRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfLsRequestRequest:
		return soap_in_ns1__srmStatusOfLsRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfLsRequestRequest");
	case SOAP_TYPE_ns1__srmLsResponse:
		return soap_in_ns1__srmLsResponse(soap, NULL, NULL, "ns1:srmLsResponse");
	case SOAP_TYPE_ns1__srmLsRequest:
		return soap_in_ns1__srmLsRequest(soap, NULL, NULL, "ns1:srmLsRequest");
	case SOAP_TYPE_ns1__srmRmResponse:
		return soap_in_ns1__srmRmResponse(soap, NULL, NULL, "ns1:srmRmResponse");
	case SOAP_TYPE_ns1__srmRmRequest:
		return soap_in_ns1__srmRmRequest(soap, NULL, NULL, "ns1:srmRmRequest");
	case SOAP_TYPE_ns1__srmRmdirResponse:
		return soap_in_ns1__srmRmdirResponse(soap, NULL, NULL, "ns1:srmRmdirResponse");
	case SOAP_TYPE_ns1__srmRmdirRequest:
		return soap_in_ns1__srmRmdirRequest(soap, NULL, NULL, "ns1:srmRmdirRequest");
	case SOAP_TYPE_ns1__srmMkdirResponse:
		return soap_in_ns1__srmMkdirResponse(soap, NULL, NULL, "ns1:srmMkdirResponse");
	case SOAP_TYPE_ns1__srmMkdirRequest:
		return soap_in_ns1__srmMkdirRequest(soap, NULL, NULL, "ns1:srmMkdirRequest");
	case SOAP_TYPE_ns1__srmGetPermissionResponse:
		return soap_in_ns1__srmGetPermissionResponse(soap, NULL, NULL, "ns1:srmGetPermissionResponse");
	case SOAP_TYPE_ns1__srmGetPermissionRequest:
		return soap_in_ns1__srmGetPermissionRequest(soap, NULL, NULL, "ns1:srmGetPermissionRequest");
	case SOAP_TYPE_ns1__srmCheckPermissionResponse:
		return soap_in_ns1__srmCheckPermissionResponse(soap, NULL, NULL, "ns1:srmCheckPermissionResponse");
	case SOAP_TYPE_ns1__srmCheckPermissionRequest:
		return soap_in_ns1__srmCheckPermissionRequest(soap, NULL, NULL, "ns1:srmCheckPermissionRequest");
	case SOAP_TYPE_ns1__srmSetPermissionResponse:
		return soap_in_ns1__srmSetPermissionResponse(soap, NULL, NULL, "ns1:srmSetPermissionResponse");
	case SOAP_TYPE_ns1__srmSetPermissionRequest:
		return soap_in_ns1__srmSetPermissionRequest(soap, NULL, NULL, "ns1:srmSetPermissionRequest");
	case SOAP_TYPE_ns1__srmGetSpaceTokensResponse:
		return soap_in_ns1__srmGetSpaceTokensResponse(soap, NULL, NULL, "ns1:srmGetSpaceTokensResponse");
	case SOAP_TYPE_ns1__srmGetSpaceTokensRequest:
		return soap_in_ns1__srmGetSpaceTokensRequest(soap, NULL, NULL, "ns1:srmGetSpaceTokensRequest");
	case SOAP_TYPE_ns1__srmPurgeFromSpaceResponse:
		return soap_in_ns1__srmPurgeFromSpaceResponse(soap, NULL, NULL, "ns1:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_ns1__srmPurgeFromSpaceRequest:
		return soap_in_ns1__srmPurgeFromSpaceRequest(soap, NULL, NULL, "ns1:srmPurgeFromSpaceRequest");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse:
		return soap_in_ns1__srmExtendFileLifeTimeInSpaceResponse(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceRequest:
		return soap_in_ns1__srmExtendFileLifeTimeInSpaceRequest(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeInSpaceRequest");
	case SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse:
		return soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestRequest:
		return soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfChangeSpaceForFilesRequestRequest");
	case SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse:
		return soap_in_ns1__srmChangeSpaceForFilesResponse(soap, NULL, NULL, "ns1:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_ns1__srmChangeSpaceForFilesRequest:
		return soap_in_ns1__srmChangeSpaceForFilesRequest(soap, NULL, NULL, "ns1:srmChangeSpaceForFilesRequest");
	case SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse:
		return soap_in_ns1__srmGetSpaceMetaDataResponse(soap, NULL, NULL, "ns1:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_ns1__srmGetSpaceMetaDataRequest:
		return soap_in_ns1__srmGetSpaceMetaDataRequest(soap, NULL, NULL, "ns1:srmGetSpaceMetaDataRequest");
	case SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse:
		return soap_in_ns1__srmStatusOfUpdateSpaceRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestRequest:
		return soap_in_ns1__srmStatusOfUpdateSpaceRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfUpdateSpaceRequestRequest");
	case SOAP_TYPE_ns1__srmUpdateSpaceResponse:
		return soap_in_ns1__srmUpdateSpaceResponse(soap, NULL, NULL, "ns1:srmUpdateSpaceResponse");
	case SOAP_TYPE_ns1__srmUpdateSpaceRequest:
		return soap_in_ns1__srmUpdateSpaceRequest(soap, NULL, NULL, "ns1:srmUpdateSpaceRequest");
	case SOAP_TYPE_ns1__srmReleaseSpaceResponse:
		return soap_in_ns1__srmReleaseSpaceResponse(soap, NULL, NULL, "ns1:srmReleaseSpaceResponse");
	case SOAP_TYPE_ns1__srmReleaseSpaceRequest:
		return soap_in_ns1__srmReleaseSpaceRequest(soap, NULL, NULL, "ns1:srmReleaseSpaceRequest");
	case SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse:
		return soap_in_ns1__srmStatusOfReserveSpaceRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestRequest:
		return soap_in_ns1__srmStatusOfReserveSpaceRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfReserveSpaceRequestRequest");
	case SOAP_TYPE_ns1__srmReserveSpaceResponse:
		return soap_in_ns1__srmReserveSpaceResponse(soap, NULL, NULL, "ns1:srmReserveSpaceResponse");
	case SOAP_TYPE_ns1__srmReserveSpaceRequest:
		return soap_in_ns1__srmReserveSpaceRequest(soap, NULL, NULL, "ns1:srmReserveSpaceRequest");
	case SOAP_TYPE_ns1__ArrayOfTSupportedTransferProtocol:
		return soap_in_ns1__ArrayOfTSupportedTransferProtocol(soap, NULL, NULL, "ns1:ArrayOfTSupportedTransferProtocol");
	case SOAP_TYPE_ns1__TSupportedTransferProtocol:
		return soap_in_ns1__TSupportedTransferProtocol(soap, NULL, NULL, "ns1:TSupportedTransferProtocol");
	case SOAP_TYPE_ns1__ArrayOfTRequestTokenReturn:
		return soap_in_ns1__ArrayOfTRequestTokenReturn(soap, NULL, NULL, "ns1:ArrayOfTRequestTokenReturn");
	case SOAP_TYPE_ns1__TRequestTokenReturn:
		return soap_in_ns1__TRequestTokenReturn(soap, NULL, NULL, "ns1:TRequestTokenReturn");
	case SOAP_TYPE_ns1__ArrayOfTPermissionReturn:
		return soap_in_ns1__ArrayOfTPermissionReturn(soap, NULL, NULL, "ns1:ArrayOfTPermissionReturn");
	case SOAP_TYPE_ns1__TPermissionReturn:
		return soap_in_ns1__TPermissionReturn(soap, NULL, NULL, "ns1:TPermissionReturn");
	case SOAP_TYPE_ns1__ArrayOfTSURLPermissionReturn:
		return soap_in_ns1__ArrayOfTSURLPermissionReturn(soap, NULL, NULL, "ns1:ArrayOfTSURLPermissionReturn");
	case SOAP_TYPE_ns1__TSURLPermissionReturn:
		return soap_in_ns1__TSURLPermissionReturn(soap, NULL, NULL, "ns1:TSURLPermissionReturn");
	case SOAP_TYPE_ns1__ArrayOfTRequestSummary:
		return soap_in_ns1__ArrayOfTRequestSummary(soap, NULL, NULL, "ns1:ArrayOfTRequestSummary");
	case SOAP_TYPE_ns1__TRequestSummary:
		return soap_in_ns1__TRequestSummary(soap, NULL, NULL, "ns1:TRequestSummary");
	case SOAP_TYPE_ns1__ArrayOfTCopyRequestFileStatus:
		return soap_in_ns1__ArrayOfTCopyRequestFileStatus(soap, NULL, NULL, "ns1:ArrayOfTCopyRequestFileStatus");
	case SOAP_TYPE_ns1__TCopyRequestFileStatus:
		return soap_in_ns1__TCopyRequestFileStatus(soap, NULL, NULL, "ns1:TCopyRequestFileStatus");
	case SOAP_TYPE_ns1__ArrayOfTPutRequestFileStatus:
		return soap_in_ns1__ArrayOfTPutRequestFileStatus(soap, NULL, NULL, "ns1:ArrayOfTPutRequestFileStatus");
	case SOAP_TYPE_ns1__TPutRequestFileStatus:
		return soap_in_ns1__TPutRequestFileStatus(soap, NULL, NULL, "ns1:TPutRequestFileStatus");
	case SOAP_TYPE_ns1__ArrayOfTBringOnlineRequestFileStatus:
		return soap_in_ns1__ArrayOfTBringOnlineRequestFileStatus(soap, NULL, NULL, "ns1:ArrayOfTBringOnlineRequestFileStatus");
	case SOAP_TYPE_ns1__TBringOnlineRequestFileStatus:
		return soap_in_ns1__TBringOnlineRequestFileStatus(soap, NULL, NULL, "ns1:TBringOnlineRequestFileStatus");
	case SOAP_TYPE_ns1__ArrayOfTGetRequestFileStatus:
		return soap_in_ns1__ArrayOfTGetRequestFileStatus(soap, NULL, NULL, "ns1:ArrayOfTGetRequestFileStatus");
	case SOAP_TYPE_ns1__TGetRequestFileStatus:
		return soap_in_ns1__TGetRequestFileStatus(soap, NULL, NULL, "ns1:TGetRequestFileStatus");
	case SOAP_TYPE_ns1__ArrayOfTCopyFileRequest:
		return soap_in_ns1__ArrayOfTCopyFileRequest(soap, NULL, NULL, "ns1:ArrayOfTCopyFileRequest");
	case SOAP_TYPE_ns1__TCopyFileRequest:
		return soap_in_ns1__TCopyFileRequest(soap, NULL, NULL, "ns1:TCopyFileRequest");
	case SOAP_TYPE_ns1__ArrayOfTPutFileRequest:
		return soap_in_ns1__ArrayOfTPutFileRequest(soap, NULL, NULL, "ns1:ArrayOfTPutFileRequest");
	case SOAP_TYPE_ns1__TPutFileRequest:
		return soap_in_ns1__TPutFileRequest(soap, NULL, NULL, "ns1:TPutFileRequest");
	case SOAP_TYPE_ns1__ArrayOfTGetFileRequest:
		return soap_in_ns1__ArrayOfTGetFileRequest(soap, NULL, NULL, "ns1:ArrayOfTGetFileRequest");
	case SOAP_TYPE_ns1__TGetFileRequest:
		return soap_in_ns1__TGetFileRequest(soap, NULL, NULL, "ns1:TGetFileRequest");
	case SOAP_TYPE_ns1__TTransferParameters:
		return soap_in_ns1__TTransferParameters(soap, NULL, NULL, "ns1:TTransferParameters");
	case SOAP_TYPE_ns1__ArrayOfAnyURI:
		return soap_in_ns1__ArrayOfAnyURI(soap, NULL, NULL, "ns1:ArrayOfAnyURI");
	case SOAP_TYPE_ns1__ArrayOfTExtraInfo:
		return soap_in_ns1__ArrayOfTExtraInfo(soap, NULL, NULL, "ns1:ArrayOfTExtraInfo");
	case SOAP_TYPE_ns1__TExtraInfo:
		return soap_in_ns1__TExtraInfo(soap, NULL, NULL, "ns1:TExtraInfo");
	case SOAP_TYPE_ns1__TDirOption:
		return soap_in_ns1__TDirOption(soap, NULL, NULL, "ns1:TDirOption");
	case SOAP_TYPE_ns1__ArrayOfTMetaDataSpace:
		return soap_in_ns1__ArrayOfTMetaDataSpace(soap, NULL, NULL, "ns1:ArrayOfTMetaDataSpace");
	case SOAP_TYPE_ns1__TMetaDataSpace:
		return soap_in_ns1__TMetaDataSpace(soap, NULL, NULL, "ns1:TMetaDataSpace");
	case SOAP_TYPE_ns1__ArrayOfTMetaDataPathDetail:
		return soap_in_ns1__ArrayOfTMetaDataPathDetail(soap, NULL, NULL, "ns1:ArrayOfTMetaDataPathDetail");
	case SOAP_TYPE_ns1__TMetaDataPathDetail:
		return soap_in_ns1__TMetaDataPathDetail(soap, NULL, NULL, "ns1:TMetaDataPathDetail");
	case SOAP_TYPE_ns1__ArrayOfTSURLLifetimeReturnStatus:
		return soap_in_ns1__ArrayOfTSURLLifetimeReturnStatus(soap, NULL, NULL, "ns1:ArrayOfTSURLLifetimeReturnStatus");
	case SOAP_TYPE_ns1__TSURLLifetimeReturnStatus:
		return soap_in_ns1__TSURLLifetimeReturnStatus(soap, NULL, NULL, "ns1:TSURLLifetimeReturnStatus");
	case SOAP_TYPE_ns1__ArrayOfTSURLReturnStatus:
		return soap_in_ns1__ArrayOfTSURLReturnStatus(soap, NULL, NULL, "ns1:ArrayOfTSURLReturnStatus");
	case SOAP_TYPE_ns1__TSURLReturnStatus:
		return soap_in_ns1__TSURLReturnStatus(soap, NULL, NULL, "ns1:TSURLReturnStatus");
	case SOAP_TYPE_ns1__TReturnStatus:
		return soap_in_ns1__TReturnStatus(soap, NULL, NULL, "ns1:TReturnStatus");
	case SOAP_TYPE_ns1__ArrayOfString:
		return soap_in_ns1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__ArrayOfUnsignedLong:
		return soap_in_ns1__ArrayOfUnsignedLong(soap, NULL, NULL, "ns1:ArrayOfUnsignedLong");
	case SOAP_TYPE_ns1__ArrayOfTGroupPermission:
		return soap_in_ns1__ArrayOfTGroupPermission(soap, NULL, NULL, "ns1:ArrayOfTGroupPermission");
	case SOAP_TYPE_ns1__TGroupPermission:
		return soap_in_ns1__TGroupPermission(soap, NULL, NULL, "ns1:TGroupPermission");
	case SOAP_TYPE_ns1__ArrayOfTUserPermission:
		return soap_in_ns1__ArrayOfTUserPermission(soap, NULL, NULL, "ns1:ArrayOfTUserPermission");
	case SOAP_TYPE_ns1__TUserPermission:
		return soap_in_ns1__TUserPermission(soap, NULL, NULL, "ns1:TUserPermission");
	case SOAP_TYPE_ns1__TRetentionPolicyInfo:
		return soap_in_ns1__TRetentionPolicyInfo(soap, NULL, NULL, "ns1:TRetentionPolicyInfo");
	case SOAP_TYPE_PointerTons1__srmPingResponse_:
		return soap_in_PointerTons1__srmPingResponse_(soap, NULL, NULL, "ns1:srmPingResponse");
	case SOAP_TYPE_PointerTons1__srmPingRequest:
		return soap_in_PointerTons1__srmPingRequest(soap, NULL, NULL, "ns1:srmPingRequest");
	case SOAP_TYPE_PointerTons1__srmPingResponse:
		return soap_in_PointerTons1__srmPingResponse(soap, NULL, NULL, "ns1:srmPingResponse");
	case SOAP_TYPE_PointerTons1__srmGetTransferProtocolsResponse_:
		return soap_in_PointerTons1__srmGetTransferProtocolsResponse_(soap, NULL, NULL, "ns1:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_PointerTons1__srmGetTransferProtocolsRequest:
		return soap_in_PointerTons1__srmGetTransferProtocolsRequest(soap, NULL, NULL, "ns1:srmGetTransferProtocolsRequest");
	case SOAP_TYPE_PointerTons1__srmGetTransferProtocolsResponse:
		return soap_in_PointerTons1__srmGetTransferProtocolsResponse(soap, NULL, NULL, "ns1:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_PointerTons1__srmGetRequestTokensResponse_:
		return soap_in_PointerTons1__srmGetRequestTokensResponse_(soap, NULL, NULL, "ns1:srmGetRequestTokensResponse");
	case SOAP_TYPE_PointerTons1__srmGetRequestTokensRequest:
		return soap_in_PointerTons1__srmGetRequestTokensRequest(soap, NULL, NULL, "ns1:srmGetRequestTokensRequest");
	case SOAP_TYPE_PointerTons1__srmGetRequestTokensResponse:
		return soap_in_PointerTons1__srmGetRequestTokensResponse(soap, NULL, NULL, "ns1:srmGetRequestTokensResponse");
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeResponse_:
		return soap_in_PointerTons1__srmExtendFileLifeTimeResponse_(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeRequest:
		return soap_in_PointerTons1__srmExtendFileLifeTimeRequest(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeRequest");
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeResponse:
		return soap_in_PointerTons1__srmExtendFileLifeTimeResponse(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_PointerTons1__srmGetRequestSummaryResponse_:
		return soap_in_PointerTons1__srmGetRequestSummaryResponse_(soap, NULL, NULL, "ns1:srmGetRequestSummaryResponse");
	case SOAP_TYPE_PointerTons1__srmGetRequestSummaryRequest:
		return soap_in_PointerTons1__srmGetRequestSummaryRequest(soap, NULL, NULL, "ns1:srmGetRequestSummaryRequest");
	case SOAP_TYPE_PointerTons1__srmGetRequestSummaryResponse:
		return soap_in_PointerTons1__srmGetRequestSummaryResponse(soap, NULL, NULL, "ns1:srmGetRequestSummaryResponse");
	case SOAP_TYPE_PointerTons1__srmResumeRequestResponse_:
		return soap_in_PointerTons1__srmResumeRequestResponse_(soap, NULL, NULL, "ns1:srmResumeRequestResponse");
	case SOAP_TYPE_PointerTons1__srmResumeRequestRequest:
		return soap_in_PointerTons1__srmResumeRequestRequest(soap, NULL, NULL, "ns1:srmResumeRequestRequest");
	case SOAP_TYPE_PointerTons1__srmResumeRequestResponse:
		return soap_in_PointerTons1__srmResumeRequestResponse(soap, NULL, NULL, "ns1:srmResumeRequestResponse");
	case SOAP_TYPE_PointerTons1__srmSuspendRequestResponse_:
		return soap_in_PointerTons1__srmSuspendRequestResponse_(soap, NULL, NULL, "ns1:srmSuspendRequestResponse");
	case SOAP_TYPE_PointerTons1__srmSuspendRequestRequest:
		return soap_in_PointerTons1__srmSuspendRequestRequest(soap, NULL, NULL, "ns1:srmSuspendRequestRequest");
	case SOAP_TYPE_PointerTons1__srmSuspendRequestResponse:
		return soap_in_PointerTons1__srmSuspendRequestResponse(soap, NULL, NULL, "ns1:srmSuspendRequestResponse");
	case SOAP_TYPE_PointerTons1__srmAbortFilesResponse_:
		return soap_in_PointerTons1__srmAbortFilesResponse_(soap, NULL, NULL, "ns1:srmAbortFilesResponse");
	case SOAP_TYPE_PointerTons1__srmAbortFilesRequest:
		return soap_in_PointerTons1__srmAbortFilesRequest(soap, NULL, NULL, "ns1:srmAbortFilesRequest");
	case SOAP_TYPE_PointerTons1__srmAbortFilesResponse:
		return soap_in_PointerTons1__srmAbortFilesResponse(soap, NULL, NULL, "ns1:srmAbortFilesResponse");
	case SOAP_TYPE_PointerTons1__srmAbortRequestResponse_:
		return soap_in_PointerTons1__srmAbortRequestResponse_(soap, NULL, NULL, "ns1:srmAbortRequestResponse");
	case SOAP_TYPE_PointerTons1__srmAbortRequestRequest:
		return soap_in_PointerTons1__srmAbortRequestRequest(soap, NULL, NULL, "ns1:srmAbortRequestRequest");
	case SOAP_TYPE_PointerTons1__srmAbortRequestResponse:
		return soap_in_PointerTons1__srmAbortRequestResponse(soap, NULL, NULL, "ns1:srmAbortRequestResponse");
	case SOAP_TYPE_PointerTons1__srmPutDoneResponse_:
		return soap_in_PointerTons1__srmPutDoneResponse_(soap, NULL, NULL, "ns1:srmPutDoneResponse");
	case SOAP_TYPE_PointerTons1__srmPutDoneRequest:
		return soap_in_PointerTons1__srmPutDoneRequest(soap, NULL, NULL, "ns1:srmPutDoneRequest");
	case SOAP_TYPE_PointerTons1__srmPutDoneResponse:
		return soap_in_PointerTons1__srmPutDoneResponse(soap, NULL, NULL, "ns1:srmPutDoneResponse");
	case SOAP_TYPE_PointerTons1__srmReleaseFilesResponse_:
		return soap_in_PointerTons1__srmReleaseFilesResponse_(soap, NULL, NULL, "ns1:srmReleaseFilesResponse");
	case SOAP_TYPE_PointerTons1__srmReleaseFilesRequest:
		return soap_in_PointerTons1__srmReleaseFilesRequest(soap, NULL, NULL, "ns1:srmReleaseFilesRequest");
	case SOAP_TYPE_PointerTons1__srmReleaseFilesResponse:
		return soap_in_PointerTons1__srmReleaseFilesResponse(soap, NULL, NULL, "ns1:srmReleaseFilesResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfCopyRequestResponse_:
		return soap_in_PointerTons1__srmStatusOfCopyRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfCopyRequestRequest:
		return soap_in_PointerTons1__srmStatusOfCopyRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfCopyRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfCopyRequestResponse:
		return soap_in_PointerTons1__srmStatusOfCopyRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_PointerTons1__srmCopyResponse_:
		return soap_in_PointerTons1__srmCopyResponse_(soap, NULL, NULL, "ns1:srmCopyResponse");
	case SOAP_TYPE_PointerTons1__srmCopyRequest:
		return soap_in_PointerTons1__srmCopyRequest(soap, NULL, NULL, "ns1:srmCopyRequest");
	case SOAP_TYPE_PointerTons1__srmCopyResponse:
		return soap_in_PointerTons1__srmCopyResponse(soap, NULL, NULL, "ns1:srmCopyResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfPutRequestResponse_:
		return soap_in_PointerTons1__srmStatusOfPutRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfPutRequestRequest:
		return soap_in_PointerTons1__srmStatusOfPutRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfPutRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfPutRequestResponse:
		return soap_in_PointerTons1__srmStatusOfPutRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_PointerTons1__srmPrepareToPutResponse_:
		return soap_in_PointerTons1__srmPrepareToPutResponse_(soap, NULL, NULL, "ns1:srmPrepareToPutResponse");
	case SOAP_TYPE_PointerTons1__srmPrepareToPutRequest:
		return soap_in_PointerTons1__srmPrepareToPutRequest(soap, NULL, NULL, "ns1:srmPrepareToPutRequest");
	case SOAP_TYPE_PointerTons1__srmPrepareToPutResponse:
		return soap_in_PointerTons1__srmPrepareToPutResponse(soap, NULL, NULL, "ns1:srmPrepareToPutResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfBringOnlineRequestResponse_:
		return soap_in_PointerTons1__srmStatusOfBringOnlineRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfBringOnlineRequestRequest:
		return soap_in_PointerTons1__srmStatusOfBringOnlineRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfBringOnlineRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfBringOnlineRequestResponse:
		return soap_in_PointerTons1__srmStatusOfBringOnlineRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_PointerTons1__srmBringOnlineResponse_:
		return soap_in_PointerTons1__srmBringOnlineResponse_(soap, NULL, NULL, "ns1:srmBringOnlineResponse");
	case SOAP_TYPE_PointerTons1__srmBringOnlineRequest:
		return soap_in_PointerTons1__srmBringOnlineRequest(soap, NULL, NULL, "ns1:srmBringOnlineRequest");
	case SOAP_TYPE_PointerTons1__srmBringOnlineResponse:
		return soap_in_PointerTons1__srmBringOnlineResponse(soap, NULL, NULL, "ns1:srmBringOnlineResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfGetRequestResponse_:
		return soap_in_PointerTons1__srmStatusOfGetRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfGetRequestRequest:
		return soap_in_PointerTons1__srmStatusOfGetRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfGetRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfGetRequestResponse:
		return soap_in_PointerTons1__srmStatusOfGetRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_PointerTons1__srmPrepareToGetResponse_:
		return soap_in_PointerTons1__srmPrepareToGetResponse_(soap, NULL, NULL, "ns1:srmPrepareToGetResponse");
	case SOAP_TYPE_PointerTons1__srmPrepareToGetRequest:
		return soap_in_PointerTons1__srmPrepareToGetRequest(soap, NULL, NULL, "ns1:srmPrepareToGetRequest");
	case SOAP_TYPE_PointerTons1__srmPrepareToGetResponse:
		return soap_in_PointerTons1__srmPrepareToGetResponse(soap, NULL, NULL, "ns1:srmPrepareToGetResponse");
	case SOAP_TYPE_PointerTons1__srmMvResponse_:
		return soap_in_PointerTons1__srmMvResponse_(soap, NULL, NULL, "ns1:srmMvResponse");
	case SOAP_TYPE_PointerTons1__srmMvRequest:
		return soap_in_PointerTons1__srmMvRequest(soap, NULL, NULL, "ns1:srmMvRequest");
	case SOAP_TYPE_PointerTons1__srmMvResponse:
		return soap_in_PointerTons1__srmMvResponse(soap, NULL, NULL, "ns1:srmMvResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfLsRequestResponse_:
		return soap_in_PointerTons1__srmStatusOfLsRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfLsRequestRequest:
		return soap_in_PointerTons1__srmStatusOfLsRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfLsRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfLsRequestResponse:
		return soap_in_PointerTons1__srmStatusOfLsRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_PointerTons1__srmLsResponse_:
		return soap_in_PointerTons1__srmLsResponse_(soap, NULL, NULL, "ns1:srmLsResponse");
	case SOAP_TYPE_PointerTons1__srmLsRequest:
		return soap_in_PointerTons1__srmLsRequest(soap, NULL, NULL, "ns1:srmLsRequest");
	case SOAP_TYPE_PointerTons1__srmLsResponse:
		return soap_in_PointerTons1__srmLsResponse(soap, NULL, NULL, "ns1:srmLsResponse");
	case SOAP_TYPE_PointerTons1__srmRmResponse_:
		return soap_in_PointerTons1__srmRmResponse_(soap, NULL, NULL, "ns1:srmRmResponse");
	case SOAP_TYPE_PointerTons1__srmRmRequest:
		return soap_in_PointerTons1__srmRmRequest(soap, NULL, NULL, "ns1:srmRmRequest");
	case SOAP_TYPE_PointerTons1__srmRmResponse:
		return soap_in_PointerTons1__srmRmResponse(soap, NULL, NULL, "ns1:srmRmResponse");
	case SOAP_TYPE_PointerTons1__srmRmdirResponse_:
		return soap_in_PointerTons1__srmRmdirResponse_(soap, NULL, NULL, "ns1:srmRmdirResponse");
	case SOAP_TYPE_PointerTons1__srmRmdirRequest:
		return soap_in_PointerTons1__srmRmdirRequest(soap, NULL, NULL, "ns1:srmRmdirRequest");
	case SOAP_TYPE_PointerTons1__srmRmdirResponse:
		return soap_in_PointerTons1__srmRmdirResponse(soap, NULL, NULL, "ns1:srmRmdirResponse");
	case SOAP_TYPE_PointerTons1__srmMkdirResponse_:
		return soap_in_PointerTons1__srmMkdirResponse_(soap, NULL, NULL, "ns1:srmMkdirResponse");
	case SOAP_TYPE_PointerTons1__srmMkdirRequest:
		return soap_in_PointerTons1__srmMkdirRequest(soap, NULL, NULL, "ns1:srmMkdirRequest");
	case SOAP_TYPE_PointerTons1__srmMkdirResponse:
		return soap_in_PointerTons1__srmMkdirResponse(soap, NULL, NULL, "ns1:srmMkdirResponse");
	case SOAP_TYPE_PointerTons1__srmGetPermissionResponse_:
		return soap_in_PointerTons1__srmGetPermissionResponse_(soap, NULL, NULL, "ns1:srmGetPermissionResponse");
	case SOAP_TYPE_PointerTons1__srmGetPermissionRequest:
		return soap_in_PointerTons1__srmGetPermissionRequest(soap, NULL, NULL, "ns1:srmGetPermissionRequest");
	case SOAP_TYPE_PointerTons1__srmGetPermissionResponse:
		return soap_in_PointerTons1__srmGetPermissionResponse(soap, NULL, NULL, "ns1:srmGetPermissionResponse");
	case SOAP_TYPE_PointerTons1__srmCheckPermissionResponse_:
		return soap_in_PointerTons1__srmCheckPermissionResponse_(soap, NULL, NULL, "ns1:srmCheckPermissionResponse");
	case SOAP_TYPE_PointerTons1__srmCheckPermissionRequest:
		return soap_in_PointerTons1__srmCheckPermissionRequest(soap, NULL, NULL, "ns1:srmCheckPermissionRequest");
	case SOAP_TYPE_PointerTons1__srmCheckPermissionResponse:
		return soap_in_PointerTons1__srmCheckPermissionResponse(soap, NULL, NULL, "ns1:srmCheckPermissionResponse");
	case SOAP_TYPE_PointerTons1__srmSetPermissionResponse_:
		return soap_in_PointerTons1__srmSetPermissionResponse_(soap, NULL, NULL, "ns1:srmSetPermissionResponse");
	case SOAP_TYPE_PointerTons1__srmSetPermissionRequest:
		return soap_in_PointerTons1__srmSetPermissionRequest(soap, NULL, NULL, "ns1:srmSetPermissionRequest");
	case SOAP_TYPE_PointerTons1__srmSetPermissionResponse:
		return soap_in_PointerTons1__srmSetPermissionResponse(soap, NULL, NULL, "ns1:srmSetPermissionResponse");
	case SOAP_TYPE_PointerTons1__srmGetSpaceTokensResponse_:
		return soap_in_PointerTons1__srmGetSpaceTokensResponse_(soap, NULL, NULL, "ns1:srmGetSpaceTokensResponse");
	case SOAP_TYPE_PointerTons1__srmGetSpaceTokensRequest:
		return soap_in_PointerTons1__srmGetSpaceTokensRequest(soap, NULL, NULL, "ns1:srmGetSpaceTokensRequest");
	case SOAP_TYPE_PointerTons1__srmGetSpaceTokensResponse:
		return soap_in_PointerTons1__srmGetSpaceTokensResponse(soap, NULL, NULL, "ns1:srmGetSpaceTokensResponse");
	case SOAP_TYPE_PointerTons1__srmPurgeFromSpaceResponse_:
		return soap_in_PointerTons1__srmPurgeFromSpaceResponse_(soap, NULL, NULL, "ns1:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmPurgeFromSpaceRequest:
		return soap_in_PointerTons1__srmPurgeFromSpaceRequest(soap, NULL, NULL, "ns1:srmPurgeFromSpaceRequest");
	case SOAP_TYPE_PointerTons1__srmPurgeFromSpaceResponse:
		return soap_in_PointerTons1__srmPurgeFromSpaceResponse(soap, NULL, NULL, "ns1:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_:
		return soap_in_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeInSpaceRequest:
		return soap_in_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeInSpaceRequest");
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeInSpaceResponse:
		return soap_in_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(soap, NULL, NULL, "ns1:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_:
		return soap_in_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest:
		return soap_in_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfChangeSpaceForFilesRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse:
		return soap_in_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_PointerTons1__srmChangeSpaceForFilesResponse_:
		return soap_in_PointerTons1__srmChangeSpaceForFilesResponse_(soap, NULL, NULL, "ns1:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_PointerTons1__srmChangeSpaceForFilesRequest:
		return soap_in_PointerTons1__srmChangeSpaceForFilesRequest(soap, NULL, NULL, "ns1:srmChangeSpaceForFilesRequest");
	case SOAP_TYPE_PointerTons1__srmChangeSpaceForFilesResponse:
		return soap_in_PointerTons1__srmChangeSpaceForFilesResponse(soap, NULL, NULL, "ns1:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_PointerTons1__srmGetSpaceMetaDataResponse_:
		return soap_in_PointerTons1__srmGetSpaceMetaDataResponse_(soap, NULL, NULL, "ns1:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_PointerTons1__srmGetSpaceMetaDataRequest:
		return soap_in_PointerTons1__srmGetSpaceMetaDataRequest(soap, NULL, NULL, "ns1:srmGetSpaceMetaDataRequest");
	case SOAP_TYPE_PointerTons1__srmGetSpaceMetaDataResponse:
		return soap_in_PointerTons1__srmGetSpaceMetaDataResponse(soap, NULL, NULL, "ns1:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_:
		return soap_in_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfUpdateSpaceRequestRequest:
		return soap_in_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfUpdateSpaceRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfUpdateSpaceRequestResponse:
		return soap_in_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_PointerTons1__srmUpdateSpaceResponse_:
		return soap_in_PointerTons1__srmUpdateSpaceResponse_(soap, NULL, NULL, "ns1:srmUpdateSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmUpdateSpaceRequest:
		return soap_in_PointerTons1__srmUpdateSpaceRequest(soap, NULL, NULL, "ns1:srmUpdateSpaceRequest");
	case SOAP_TYPE_PointerTons1__srmUpdateSpaceResponse:
		return soap_in_PointerTons1__srmUpdateSpaceResponse(soap, NULL, NULL, "ns1:srmUpdateSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmReleaseSpaceResponse_:
		return soap_in_PointerTons1__srmReleaseSpaceResponse_(soap, NULL, NULL, "ns1:srmReleaseSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmReleaseSpaceRequest:
		return soap_in_PointerTons1__srmReleaseSpaceRequest(soap, NULL, NULL, "ns1:srmReleaseSpaceRequest");
	case SOAP_TYPE_PointerTons1__srmReleaseSpaceResponse:
		return soap_in_PointerTons1__srmReleaseSpaceResponse(soap, NULL, NULL, "ns1:srmReleaseSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfReserveSpaceRequestResponse_:
		return soap_in_PointerTons1__srmStatusOfReserveSpaceRequestResponse_(soap, NULL, NULL, "ns1:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfReserveSpaceRequestRequest:
		return soap_in_PointerTons1__srmStatusOfReserveSpaceRequestRequest(soap, NULL, NULL, "ns1:srmStatusOfReserveSpaceRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfReserveSpaceRequestResponse:
		return soap_in_PointerTons1__srmStatusOfReserveSpaceRequestResponse(soap, NULL, NULL, "ns1:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_PointerTons1__srmReserveSpaceResponse_:
		return soap_in_PointerTons1__srmReserveSpaceResponse_(soap, NULL, NULL, "ns1:srmReserveSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmReserveSpaceRequest:
		return soap_in_PointerTons1__srmReserveSpaceRequest(soap, NULL, NULL, "ns1:srmReserveSpaceRequest");
	case SOAP_TYPE_PointerTons1__srmReserveSpaceResponse:
		return soap_in_PointerTons1__srmReserveSpaceResponse(soap, NULL, NULL, "ns1:srmReserveSpaceResponse");
	case SOAP_TYPE_PointerTons1__ArrayOfTSupportedTransferProtocol:
		return soap_in_PointerTons1__ArrayOfTSupportedTransferProtocol(soap, NULL, NULL, "ns1:ArrayOfTSupportedTransferProtocol");
	case SOAP_TYPE_PointerTons1__ArrayOfTRequestTokenReturn:
		return soap_in_PointerTons1__ArrayOfTRequestTokenReturn(soap, NULL, NULL, "ns1:ArrayOfTRequestTokenReturn");
	case SOAP_TYPE_PointerTons1__ArrayOfTRequestSummary:
		return soap_in_PointerTons1__ArrayOfTRequestSummary(soap, NULL, NULL, "ns1:ArrayOfTRequestSummary");
	case SOAP_TYPE_PointerTons1__ArrayOfTCopyRequestFileStatus:
		return soap_in_PointerTons1__ArrayOfTCopyRequestFileStatus(soap, NULL, NULL, "ns1:ArrayOfTCopyRequestFileStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfTCopyFileRequest:
		return soap_in_PointerTons1__ArrayOfTCopyFileRequest(soap, NULL, NULL, "ns1:ArrayOfTCopyFileRequest");
	case SOAP_TYPE_PointerTons1__ArrayOfTPutRequestFileStatus:
		return soap_in_PointerTons1__ArrayOfTPutRequestFileStatus(soap, NULL, NULL, "ns1:ArrayOfTPutRequestFileStatus");
	case SOAP_TYPE_PointerTons1__TOverwriteMode:
		return soap_in_PointerTons1__TOverwriteMode(soap, NULL, NULL, "ns1:TOverwriteMode");
	case SOAP_TYPE_PointerTons1__ArrayOfTPutFileRequest:
		return soap_in_PointerTons1__ArrayOfTPutFileRequest(soap, NULL, NULL, "ns1:ArrayOfTPutFileRequest");
	case SOAP_TYPE_PointerTons1__ArrayOfTBringOnlineRequestFileStatus:
		return soap_in_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(soap, NULL, NULL, "ns1:ArrayOfTBringOnlineRequestFileStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfTGetRequestFileStatus:
		return soap_in_PointerTons1__ArrayOfTGetRequestFileStatus(soap, NULL, NULL, "ns1:ArrayOfTGetRequestFileStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfTGetFileRequest:
		return soap_in_PointerTons1__ArrayOfTGetFileRequest(soap, NULL, NULL, "ns1:ArrayOfTGetFileRequest");
	case SOAP_TYPE_PointerTons1__ArrayOfTPermissionReturn:
		return soap_in_PointerTons1__ArrayOfTPermissionReturn(soap, NULL, NULL, "ns1:ArrayOfTPermissionReturn");
	case SOAP_TYPE_PointerTons1__ArrayOfTSURLPermissionReturn:
		return soap_in_PointerTons1__ArrayOfTSURLPermissionReturn(soap, NULL, NULL, "ns1:ArrayOfTSURLPermissionReturn");
	case SOAP_TYPE_PointerTons1__ArrayOfTSURLLifetimeReturnStatus:
		return soap_in_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(soap, NULL, NULL, "ns1:ArrayOfTSURLLifetimeReturnStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfTSURLReturnStatus:
		return soap_in_PointerTons1__ArrayOfTSURLReturnStatus(soap, NULL, NULL, "ns1:ArrayOfTSURLReturnStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfAnyURI:
		return soap_in_PointerTons1__ArrayOfAnyURI(soap, NULL, NULL, "ns1:ArrayOfAnyURI");
	case SOAP_TYPE_PointerTons1__ArrayOfTMetaDataSpace:
		return soap_in_PointerTons1__ArrayOfTMetaDataSpace(soap, NULL, NULL, "ns1:ArrayOfTMetaDataSpace");
	case SOAP_TYPE_PointerTons1__TTransferParameters:
		return soap_in_PointerTons1__TTransferParameters(soap, NULL, NULL, "ns1:TTransferParameters");
	case SOAP_TYPE_PointerTons1__ArrayOfUnsignedLong:
		return soap_in_PointerTons1__ArrayOfUnsignedLong(soap, NULL, NULL, "ns1:ArrayOfUnsignedLong");
	case SOAP_TYPE_PointerTons1__TSupportedTransferProtocol:
		return soap_in_PointerTons1__TSupportedTransferProtocol(soap, NULL, NULL, "ns1:TSupportedTransferProtocol");
	case SOAP_TYPE_PointerTons1__TRequestTokenReturn:
		return soap_in_PointerTons1__TRequestTokenReturn(soap, NULL, NULL, "ns1:TRequestTokenReturn");
	case SOAP_TYPE_PointerTons1__TPermissionReturn:
		return soap_in_PointerTons1__TPermissionReturn(soap, NULL, NULL, "ns1:TPermissionReturn");
	case SOAP_TYPE_PointerTons1__ArrayOfTGroupPermission:
		return soap_in_PointerTons1__ArrayOfTGroupPermission(soap, NULL, NULL, "ns1:ArrayOfTGroupPermission");
	case SOAP_TYPE_PointerTons1__ArrayOfTUserPermission:
		return soap_in_PointerTons1__ArrayOfTUserPermission(soap, NULL, NULL, "ns1:ArrayOfTUserPermission");
	case SOAP_TYPE_PointerTons1__TSURLPermissionReturn:
		return soap_in_PointerTons1__TSURLPermissionReturn(soap, NULL, NULL, "ns1:TSURLPermissionReturn");
	case SOAP_TYPE_PointerTons1__TRequestSummary:
		return soap_in_PointerTons1__TRequestSummary(soap, NULL, NULL, "ns1:TRequestSummary");
	case SOAP_TYPE_PointerTons1__TRequestType:
		return soap_in_PointerTons1__TRequestType(soap, NULL, NULL, "ns1:TRequestType");
	case SOAP_TYPE_PointerTons1__TCopyRequestFileStatus:
		return soap_in_PointerTons1__TCopyRequestFileStatus(soap, NULL, NULL, "ns1:TCopyRequestFileStatus");
	case SOAP_TYPE_PointerTons1__TPutRequestFileStatus:
		return soap_in_PointerTons1__TPutRequestFileStatus(soap, NULL, NULL, "ns1:TPutRequestFileStatus");
	case SOAP_TYPE_PointerTons1__TBringOnlineRequestFileStatus:
		return soap_in_PointerTons1__TBringOnlineRequestFileStatus(soap, NULL, NULL, "ns1:TBringOnlineRequestFileStatus");
	case SOAP_TYPE_PointerTons1__TGetRequestFileStatus:
		return soap_in_PointerTons1__TGetRequestFileStatus(soap, NULL, NULL, "ns1:TGetRequestFileStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfTExtraInfo:
		return soap_in_PointerTons1__ArrayOfTExtraInfo(soap, NULL, NULL, "ns1:ArrayOfTExtraInfo");
	case SOAP_TYPE_PointerTons1__TCopyFileRequest:
		return soap_in_PointerTons1__TCopyFileRequest(soap, NULL, NULL, "ns1:TCopyFileRequest");
	case SOAP_TYPE_PointerTons1__TPutFileRequest:
		return soap_in_PointerTons1__TPutFileRequest(soap, NULL, NULL, "ns1:TPutFileRequest");
	case SOAP_TYPE_PointerTons1__TGetFileRequest:
		return soap_in_PointerTons1__TGetFileRequest(soap, NULL, NULL, "ns1:TGetFileRequest");
	case SOAP_TYPE_PointerTons1__TDirOption:
		return soap_in_PointerTons1__TDirOption(soap, NULL, NULL, "ns1:TDirOption");
	case SOAP_TYPE_PointerTons1__TConnectionType:
		return soap_in_PointerTons1__TConnectionType(soap, NULL, NULL, "ns1:TConnectionType");
	case SOAP_TYPE_PointerTons1__TAccessPattern:
		return soap_in_PointerTons1__TAccessPattern(soap, NULL, NULL, "ns1:TAccessPattern");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTons1__TExtraInfo:
		return soap_in_PointerTons1__TExtraInfo(soap, NULL, NULL, "ns1:TExtraInfo");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons1__TMetaDataSpace:
		return soap_in_PointerTons1__TMetaDataSpace(soap, NULL, NULL, "ns1:TMetaDataSpace");
	case SOAP_TYPE_PointerTons1__TMetaDataPathDetail:
		return soap_in_PointerTons1__TMetaDataPathDetail(soap, NULL, NULL, "ns1:TMetaDataPathDetail");
	case SOAP_TYPE_PointerTons1__ArrayOfTMetaDataPathDetail:
		return soap_in_PointerTons1__ArrayOfTMetaDataPathDetail(soap, NULL, NULL, "ns1:ArrayOfTMetaDataPathDetail");
	case SOAP_TYPE_PointerTons1__TPermissionMode:
		return soap_in_PointerTons1__TPermissionMode(soap, NULL, NULL, "ns1:TPermissionMode");
	case SOAP_TYPE_PointerTons1__TFileType:
		return soap_in_PointerTons1__TFileType(soap, NULL, NULL, "ns1:TFileType");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_in_PointerTons1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons1__TFileLocality:
		return soap_in_PointerTons1__TFileLocality(soap, NULL, NULL, "ns1:TFileLocality");
	case SOAP_TYPE_PointerTons1__TRetentionPolicyInfo:
		return soap_in_PointerTons1__TRetentionPolicyInfo(soap, NULL, NULL, "ns1:TRetentionPolicyInfo");
	case SOAP_TYPE_PointerTons1__TFileStorageType:
		return soap_in_PointerTons1__TFileStorageType(soap, NULL, NULL, "ns1:TFileStorageType");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__TSURLLifetimeReturnStatus:
		return soap_in_PointerTons1__TSURLLifetimeReturnStatus(soap, NULL, NULL, "ns1:TSURLLifetimeReturnStatus");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons1__TSURLReturnStatus:
		return soap_in_PointerTons1__TSURLReturnStatus(soap, NULL, NULL, "ns1:TSURLReturnStatus");
	case SOAP_TYPE_PointerTons1__TReturnStatus:
		return soap_in_PointerTons1__TReturnStatus(soap, NULL, NULL, "ns1:TReturnStatus");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTounsignedLONG64:
		return soap_in_PointerTounsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTons1__TGroupPermission:
		return soap_in_PointerTons1__TGroupPermission(soap, NULL, NULL, "ns1:TGroupPermission");
	case SOAP_TYPE_PointerTons1__TUserPermission:
		return soap_in_PointerTons1__TUserPermission(soap, NULL, NULL, "ns1:TUserPermission");
	case SOAP_TYPE_PointerTons1__TAccessLatency:
		return soap_in_PointerTons1__TAccessLatency(soap, NULL, NULL, "ns1:TAccessLatency");
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TStatusCode"))
		{	*type = SOAP_TYPE_ns1__TStatusCode;
			return soap_in_ns1__TStatusCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TConnectionType"))
		{	*type = SOAP_TYPE_ns1__TConnectionType;
			return soap_in_ns1__TConnectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TAccessPattern"))
		{	*type = SOAP_TYPE_ns1__TAccessPattern;
			return soap_in_ns1__TAccessPattern(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TFileLocality"))
		{	*type = SOAP_TYPE_ns1__TFileLocality;
			return soap_in_ns1__TFileLocality(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TOverwriteMode"))
		{	*type = SOAP_TYPE_ns1__TOverwriteMode;
			return soap_in_ns1__TOverwriteMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TRequestType"))
		{	*type = SOAP_TYPE_ns1__TRequestType;
			return soap_in_ns1__TRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TPermissionType"))
		{	*type = SOAP_TYPE_ns1__TPermissionType;
			return soap_in_ns1__TPermissionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TPermissionMode"))
		{	*type = SOAP_TYPE_ns1__TPermissionMode;
			return soap_in_ns1__TPermissionMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TAccessLatency"))
		{	*type = SOAP_TYPE_ns1__TAccessLatency;
			return soap_in_ns1__TAccessLatency(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TRetentionPolicy"))
		{	*type = SOAP_TYPE_ns1__TRetentionPolicy;
			return soap_in_ns1__TRetentionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TFileType"))
		{	*type = SOAP_TYPE_ns1__TFileType;
			return soap_in_ns1__TFileType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TFileStorageType"))
		{	*type = SOAP_TYPE_ns1__TFileStorageType;
			return soap_in_ns1__TFileStorageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPing"))
		{	*type = SOAP_TYPE_ns1__srmPing;
			return soap_in_ns1__srmPing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPingResponse"))
		{	*type = SOAP_TYPE_ns1__srmPingResponse_;
			return soap_in_ns1__srmPingResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetTransferProtocols"))
		{	*type = SOAP_TYPE_ns1__srmGetTransferProtocols;
			return soap_in_ns1__srmGetTransferProtocols(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetTransferProtocolsResponse"))
		{	*type = SOAP_TYPE_ns1__srmGetTransferProtocolsResponse_;
			return soap_in_ns1__srmGetTransferProtocolsResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetRequestTokens"))
		{	*type = SOAP_TYPE_ns1__srmGetRequestTokens;
			return soap_in_ns1__srmGetRequestTokens(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetRequestTokensResponse"))
		{	*type = SOAP_TYPE_ns1__srmGetRequestTokensResponse_;
			return soap_in_ns1__srmGetRequestTokensResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmExtendFileLifeTime"))
		{	*type = SOAP_TYPE_ns1__srmExtendFileLifeTime;
			return soap_in_ns1__srmExtendFileLifeTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmExtendFileLifeTimeResponse"))
		{	*type = SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse_;
			return soap_in_ns1__srmExtendFileLifeTimeResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetRequestSummary"))
		{	*type = SOAP_TYPE_ns1__srmGetRequestSummary;
			return soap_in_ns1__srmGetRequestSummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetRequestSummaryResponse"))
		{	*type = SOAP_TYPE_ns1__srmGetRequestSummaryResponse_;
			return soap_in_ns1__srmGetRequestSummaryResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmResumeRequest"))
		{	*type = SOAP_TYPE_ns1__srmResumeRequest;
			return soap_in_ns1__srmResumeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmResumeRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmResumeRequestResponse_;
			return soap_in_ns1__srmResumeRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmSuspendRequest"))
		{	*type = SOAP_TYPE_ns1__srmSuspendRequest;
			return soap_in_ns1__srmSuspendRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmSuspendRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmSuspendRequestResponse_;
			return soap_in_ns1__srmSuspendRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmAbortFiles"))
		{	*type = SOAP_TYPE_ns1__srmAbortFiles;
			return soap_in_ns1__srmAbortFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmAbortFilesResponse"))
		{	*type = SOAP_TYPE_ns1__srmAbortFilesResponse_;
			return soap_in_ns1__srmAbortFilesResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmAbortRequest"))
		{	*type = SOAP_TYPE_ns1__srmAbortRequest;
			return soap_in_ns1__srmAbortRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmAbortRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmAbortRequestResponse_;
			return soap_in_ns1__srmAbortRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPutDone"))
		{	*type = SOAP_TYPE_ns1__srmPutDone;
			return soap_in_ns1__srmPutDone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPutDoneResponse"))
		{	*type = SOAP_TYPE_ns1__srmPutDoneResponse_;
			return soap_in_ns1__srmPutDoneResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmReleaseFiles"))
		{	*type = SOAP_TYPE_ns1__srmReleaseFiles;
			return soap_in_ns1__srmReleaseFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmReleaseFilesResponse"))
		{	*type = SOAP_TYPE_ns1__srmReleaseFilesResponse_;
			return soap_in_ns1__srmReleaseFilesResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfCopyRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfCopyRequest;
			return soap_in_ns1__srmStatusOfCopyRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfCopyRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse_;
			return soap_in_ns1__srmStatusOfCopyRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmCopy"))
		{	*type = SOAP_TYPE_ns1__srmCopy;
			return soap_in_ns1__srmCopy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmCopyResponse"))
		{	*type = SOAP_TYPE_ns1__srmCopyResponse_;
			return soap_in_ns1__srmCopyResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfPutRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfPutRequest;
			return soap_in_ns1__srmStatusOfPutRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfPutRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfPutRequestResponse_;
			return soap_in_ns1__srmStatusOfPutRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPrepareToPut"))
		{	*type = SOAP_TYPE_ns1__srmPrepareToPut;
			return soap_in_ns1__srmPrepareToPut(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPrepareToPutResponse"))
		{	*type = SOAP_TYPE_ns1__srmPrepareToPutResponse_;
			return soap_in_ns1__srmPrepareToPutResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfBringOnlineRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfBringOnlineRequest;
			return soap_in_ns1__srmStatusOfBringOnlineRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfBringOnlineRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse_;
			return soap_in_ns1__srmStatusOfBringOnlineRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmBringOnline"))
		{	*type = SOAP_TYPE_ns1__srmBringOnline;
			return soap_in_ns1__srmBringOnline(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmBringOnlineResponse"))
		{	*type = SOAP_TYPE_ns1__srmBringOnlineResponse_;
			return soap_in_ns1__srmBringOnlineResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfGetRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfGetRequest;
			return soap_in_ns1__srmStatusOfGetRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfGetRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfGetRequestResponse_;
			return soap_in_ns1__srmStatusOfGetRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPrepareToGet"))
		{	*type = SOAP_TYPE_ns1__srmPrepareToGet;
			return soap_in_ns1__srmPrepareToGet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPrepareToGetResponse"))
		{	*type = SOAP_TYPE_ns1__srmPrepareToGetResponse_;
			return soap_in_ns1__srmPrepareToGetResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmMv"))
		{	*type = SOAP_TYPE_ns1__srmMv;
			return soap_in_ns1__srmMv(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmMvResponse"))
		{	*type = SOAP_TYPE_ns1__srmMvResponse_;
			return soap_in_ns1__srmMvResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfLsRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfLsRequest;
			return soap_in_ns1__srmStatusOfLsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfLsRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfLsRequestResponse_;
			return soap_in_ns1__srmStatusOfLsRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmLs"))
		{	*type = SOAP_TYPE_ns1__srmLs;
			return soap_in_ns1__srmLs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmLsResponse"))
		{	*type = SOAP_TYPE_ns1__srmLsResponse_;
			return soap_in_ns1__srmLsResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmRm"))
		{	*type = SOAP_TYPE_ns1__srmRm;
			return soap_in_ns1__srmRm(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmRmResponse"))
		{	*type = SOAP_TYPE_ns1__srmRmResponse_;
			return soap_in_ns1__srmRmResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmRmdir"))
		{	*type = SOAP_TYPE_ns1__srmRmdir;
			return soap_in_ns1__srmRmdir(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmRmdirResponse"))
		{	*type = SOAP_TYPE_ns1__srmRmdirResponse_;
			return soap_in_ns1__srmRmdirResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmMkdir"))
		{	*type = SOAP_TYPE_ns1__srmMkdir;
			return soap_in_ns1__srmMkdir(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmMkdirResponse"))
		{	*type = SOAP_TYPE_ns1__srmMkdirResponse_;
			return soap_in_ns1__srmMkdirResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetPermission"))
		{	*type = SOAP_TYPE_ns1__srmGetPermission;
			return soap_in_ns1__srmGetPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetPermissionResponse"))
		{	*type = SOAP_TYPE_ns1__srmGetPermissionResponse_;
			return soap_in_ns1__srmGetPermissionResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmCheckPermission"))
		{	*type = SOAP_TYPE_ns1__srmCheckPermission;
			return soap_in_ns1__srmCheckPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmCheckPermissionResponse"))
		{	*type = SOAP_TYPE_ns1__srmCheckPermissionResponse_;
			return soap_in_ns1__srmCheckPermissionResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmSetPermission"))
		{	*type = SOAP_TYPE_ns1__srmSetPermission;
			return soap_in_ns1__srmSetPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmSetPermissionResponse"))
		{	*type = SOAP_TYPE_ns1__srmSetPermissionResponse_;
			return soap_in_ns1__srmSetPermissionResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetSpaceTokens"))
		{	*type = SOAP_TYPE_ns1__srmGetSpaceTokens;
			return soap_in_ns1__srmGetSpaceTokens(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetSpaceTokensResponse"))
		{	*type = SOAP_TYPE_ns1__srmGetSpaceTokensResponse_;
			return soap_in_ns1__srmGetSpaceTokensResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPurgeFromSpace"))
		{	*type = SOAP_TYPE_ns1__srmPurgeFromSpace;
			return soap_in_ns1__srmPurgeFromSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPurgeFromSpaceResponse"))
		{	*type = SOAP_TYPE_ns1__srmPurgeFromSpaceResponse_;
			return soap_in_ns1__srmPurgeFromSpaceResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmExtendFileLifeTimeInSpace"))
		{	*type = SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpace;
			return soap_in_ns1__srmExtendFileLifeTimeInSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmExtendFileLifeTimeInSpaceResponse"))
		{	*type = SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse_;
			return soap_in_ns1__srmExtendFileLifeTimeInSpaceResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfChangeSpaceForFilesRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequest;
			return soap_in_ns1__srmStatusOfChangeSpaceForFilesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfChangeSpaceForFilesRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_;
			return soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmChangeSpaceForFiles"))
		{	*type = SOAP_TYPE_ns1__srmChangeSpaceForFiles;
			return soap_in_ns1__srmChangeSpaceForFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmChangeSpaceForFilesResponse"))
		{	*type = SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse_;
			return soap_in_ns1__srmChangeSpaceForFilesResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetSpaceMetaData"))
		{	*type = SOAP_TYPE_ns1__srmGetSpaceMetaData;
			return soap_in_ns1__srmGetSpaceMetaData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetSpaceMetaDataResponse"))
		{	*type = SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse_;
			return soap_in_ns1__srmGetSpaceMetaDataResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfUpdateSpaceRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequest;
			return soap_in_ns1__srmStatusOfUpdateSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfUpdateSpaceRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse_;
			return soap_in_ns1__srmStatusOfUpdateSpaceRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmUpdateSpace"))
		{	*type = SOAP_TYPE_ns1__srmUpdateSpace;
			return soap_in_ns1__srmUpdateSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmUpdateSpaceResponse"))
		{	*type = SOAP_TYPE_ns1__srmUpdateSpaceResponse_;
			return soap_in_ns1__srmUpdateSpaceResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmReleaseSpace"))
		{	*type = SOAP_TYPE_ns1__srmReleaseSpace;
			return soap_in_ns1__srmReleaseSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmReleaseSpaceResponse"))
		{	*type = SOAP_TYPE_ns1__srmReleaseSpaceResponse_;
			return soap_in_ns1__srmReleaseSpaceResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfReserveSpaceRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequest;
			return soap_in_ns1__srmStatusOfReserveSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfReserveSpaceRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse_;
			return soap_in_ns1__srmStatusOfReserveSpaceRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmReserveSpace"))
		{	*type = SOAP_TYPE_ns1__srmReserveSpace;
			return soap_in_ns1__srmReserveSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmReserveSpaceResponse"))
		{	*type = SOAP_TYPE_ns1__srmReserveSpaceResponse_;
			return soap_in_ns1__srmReserveSpaceResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPingResponse"))
		{	*type = SOAP_TYPE_ns1__srmPingResponse;
			return soap_in_ns1__srmPingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPingRequest"))
		{	*type = SOAP_TYPE_ns1__srmPingRequest;
			return soap_in_ns1__srmPingRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetTransferProtocolsResponse"))
		{	*type = SOAP_TYPE_ns1__srmGetTransferProtocolsResponse;
			return soap_in_ns1__srmGetTransferProtocolsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetTransferProtocolsRequest"))
		{	*type = SOAP_TYPE_ns1__srmGetTransferProtocolsRequest;
			return soap_in_ns1__srmGetTransferProtocolsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetRequestTokensResponse"))
		{	*type = SOAP_TYPE_ns1__srmGetRequestTokensResponse;
			return soap_in_ns1__srmGetRequestTokensResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetRequestTokensRequest"))
		{	*type = SOAP_TYPE_ns1__srmGetRequestTokensRequest;
			return soap_in_ns1__srmGetRequestTokensRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmExtendFileLifeTimeResponse"))
		{	*type = SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse;
			return soap_in_ns1__srmExtendFileLifeTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmExtendFileLifeTimeRequest"))
		{	*type = SOAP_TYPE_ns1__srmExtendFileLifeTimeRequest;
			return soap_in_ns1__srmExtendFileLifeTimeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetRequestSummaryResponse"))
		{	*type = SOAP_TYPE_ns1__srmGetRequestSummaryResponse;
			return soap_in_ns1__srmGetRequestSummaryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetRequestSummaryRequest"))
		{	*type = SOAP_TYPE_ns1__srmGetRequestSummaryRequest;
			return soap_in_ns1__srmGetRequestSummaryRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmResumeRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmResumeRequestResponse;
			return soap_in_ns1__srmResumeRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmResumeRequestRequest"))
		{	*type = SOAP_TYPE_ns1__srmResumeRequestRequest;
			return soap_in_ns1__srmResumeRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmSuspendRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmSuspendRequestResponse;
			return soap_in_ns1__srmSuspendRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmSuspendRequestRequest"))
		{	*type = SOAP_TYPE_ns1__srmSuspendRequestRequest;
			return soap_in_ns1__srmSuspendRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmAbortFilesResponse"))
		{	*type = SOAP_TYPE_ns1__srmAbortFilesResponse;
			return soap_in_ns1__srmAbortFilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmAbortFilesRequest"))
		{	*type = SOAP_TYPE_ns1__srmAbortFilesRequest;
			return soap_in_ns1__srmAbortFilesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmAbortRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmAbortRequestResponse;
			return soap_in_ns1__srmAbortRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmAbortRequestRequest"))
		{	*type = SOAP_TYPE_ns1__srmAbortRequestRequest;
			return soap_in_ns1__srmAbortRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPutDoneResponse"))
		{	*type = SOAP_TYPE_ns1__srmPutDoneResponse;
			return soap_in_ns1__srmPutDoneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPutDoneRequest"))
		{	*type = SOAP_TYPE_ns1__srmPutDoneRequest;
			return soap_in_ns1__srmPutDoneRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmReleaseFilesResponse"))
		{	*type = SOAP_TYPE_ns1__srmReleaseFilesResponse;
			return soap_in_ns1__srmReleaseFilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmReleaseFilesRequest"))
		{	*type = SOAP_TYPE_ns1__srmReleaseFilesRequest;
			return soap_in_ns1__srmReleaseFilesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfCopyRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse;
			return soap_in_ns1__srmStatusOfCopyRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfCopyRequestRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfCopyRequestRequest;
			return soap_in_ns1__srmStatusOfCopyRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmCopyResponse"))
		{	*type = SOAP_TYPE_ns1__srmCopyResponse;
			return soap_in_ns1__srmCopyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmCopyRequest"))
		{	*type = SOAP_TYPE_ns1__srmCopyRequest;
			return soap_in_ns1__srmCopyRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfPutRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfPutRequestResponse;
			return soap_in_ns1__srmStatusOfPutRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfPutRequestRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfPutRequestRequest;
			return soap_in_ns1__srmStatusOfPutRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPrepareToPutResponse"))
		{	*type = SOAP_TYPE_ns1__srmPrepareToPutResponse;
			return soap_in_ns1__srmPrepareToPutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPrepareToPutRequest"))
		{	*type = SOAP_TYPE_ns1__srmPrepareToPutRequest;
			return soap_in_ns1__srmPrepareToPutRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfBringOnlineRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse;
			return soap_in_ns1__srmStatusOfBringOnlineRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfBringOnlineRequestRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestRequest;
			return soap_in_ns1__srmStatusOfBringOnlineRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmBringOnlineResponse"))
		{	*type = SOAP_TYPE_ns1__srmBringOnlineResponse;
			return soap_in_ns1__srmBringOnlineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmBringOnlineRequest"))
		{	*type = SOAP_TYPE_ns1__srmBringOnlineRequest;
			return soap_in_ns1__srmBringOnlineRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfGetRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfGetRequestResponse;
			return soap_in_ns1__srmStatusOfGetRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfGetRequestRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfGetRequestRequest;
			return soap_in_ns1__srmStatusOfGetRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPrepareToGetResponse"))
		{	*type = SOAP_TYPE_ns1__srmPrepareToGetResponse;
			return soap_in_ns1__srmPrepareToGetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPrepareToGetRequest"))
		{	*type = SOAP_TYPE_ns1__srmPrepareToGetRequest;
			return soap_in_ns1__srmPrepareToGetRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmMvResponse"))
		{	*type = SOAP_TYPE_ns1__srmMvResponse;
			return soap_in_ns1__srmMvResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmMvRequest"))
		{	*type = SOAP_TYPE_ns1__srmMvRequest;
			return soap_in_ns1__srmMvRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfLsRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfLsRequestResponse;
			return soap_in_ns1__srmStatusOfLsRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfLsRequestRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfLsRequestRequest;
			return soap_in_ns1__srmStatusOfLsRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmLsResponse"))
		{	*type = SOAP_TYPE_ns1__srmLsResponse;
			return soap_in_ns1__srmLsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmLsRequest"))
		{	*type = SOAP_TYPE_ns1__srmLsRequest;
			return soap_in_ns1__srmLsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmRmResponse"))
		{	*type = SOAP_TYPE_ns1__srmRmResponse;
			return soap_in_ns1__srmRmResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmRmRequest"))
		{	*type = SOAP_TYPE_ns1__srmRmRequest;
			return soap_in_ns1__srmRmRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmRmdirResponse"))
		{	*type = SOAP_TYPE_ns1__srmRmdirResponse;
			return soap_in_ns1__srmRmdirResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmRmdirRequest"))
		{	*type = SOAP_TYPE_ns1__srmRmdirRequest;
			return soap_in_ns1__srmRmdirRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmMkdirResponse"))
		{	*type = SOAP_TYPE_ns1__srmMkdirResponse;
			return soap_in_ns1__srmMkdirResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmMkdirRequest"))
		{	*type = SOAP_TYPE_ns1__srmMkdirRequest;
			return soap_in_ns1__srmMkdirRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetPermissionResponse"))
		{	*type = SOAP_TYPE_ns1__srmGetPermissionResponse;
			return soap_in_ns1__srmGetPermissionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetPermissionRequest"))
		{	*type = SOAP_TYPE_ns1__srmGetPermissionRequest;
			return soap_in_ns1__srmGetPermissionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmCheckPermissionResponse"))
		{	*type = SOAP_TYPE_ns1__srmCheckPermissionResponse;
			return soap_in_ns1__srmCheckPermissionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmCheckPermissionRequest"))
		{	*type = SOAP_TYPE_ns1__srmCheckPermissionRequest;
			return soap_in_ns1__srmCheckPermissionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmSetPermissionResponse"))
		{	*type = SOAP_TYPE_ns1__srmSetPermissionResponse;
			return soap_in_ns1__srmSetPermissionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmSetPermissionRequest"))
		{	*type = SOAP_TYPE_ns1__srmSetPermissionRequest;
			return soap_in_ns1__srmSetPermissionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetSpaceTokensResponse"))
		{	*type = SOAP_TYPE_ns1__srmGetSpaceTokensResponse;
			return soap_in_ns1__srmGetSpaceTokensResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetSpaceTokensRequest"))
		{	*type = SOAP_TYPE_ns1__srmGetSpaceTokensRequest;
			return soap_in_ns1__srmGetSpaceTokensRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPurgeFromSpaceResponse"))
		{	*type = SOAP_TYPE_ns1__srmPurgeFromSpaceResponse;
			return soap_in_ns1__srmPurgeFromSpaceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmPurgeFromSpaceRequest"))
		{	*type = SOAP_TYPE_ns1__srmPurgeFromSpaceRequest;
			return soap_in_ns1__srmPurgeFromSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmExtendFileLifeTimeInSpaceResponse"))
		{	*type = SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse;
			return soap_in_ns1__srmExtendFileLifeTimeInSpaceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmExtendFileLifeTimeInSpaceRequest"))
		{	*type = SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceRequest;
			return soap_in_ns1__srmExtendFileLifeTimeInSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfChangeSpaceForFilesRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse;
			return soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfChangeSpaceForFilesRequestRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestRequest;
			return soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmChangeSpaceForFilesResponse"))
		{	*type = SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse;
			return soap_in_ns1__srmChangeSpaceForFilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmChangeSpaceForFilesRequest"))
		{	*type = SOAP_TYPE_ns1__srmChangeSpaceForFilesRequest;
			return soap_in_ns1__srmChangeSpaceForFilesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetSpaceMetaDataResponse"))
		{	*type = SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse;
			return soap_in_ns1__srmGetSpaceMetaDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmGetSpaceMetaDataRequest"))
		{	*type = SOAP_TYPE_ns1__srmGetSpaceMetaDataRequest;
			return soap_in_ns1__srmGetSpaceMetaDataRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfUpdateSpaceRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse;
			return soap_in_ns1__srmStatusOfUpdateSpaceRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfUpdateSpaceRequestRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestRequest;
			return soap_in_ns1__srmStatusOfUpdateSpaceRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmUpdateSpaceResponse"))
		{	*type = SOAP_TYPE_ns1__srmUpdateSpaceResponse;
			return soap_in_ns1__srmUpdateSpaceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmUpdateSpaceRequest"))
		{	*type = SOAP_TYPE_ns1__srmUpdateSpaceRequest;
			return soap_in_ns1__srmUpdateSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmReleaseSpaceResponse"))
		{	*type = SOAP_TYPE_ns1__srmReleaseSpaceResponse;
			return soap_in_ns1__srmReleaseSpaceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmReleaseSpaceRequest"))
		{	*type = SOAP_TYPE_ns1__srmReleaseSpaceRequest;
			return soap_in_ns1__srmReleaseSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfReserveSpaceRequestResponse"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse;
			return soap_in_ns1__srmStatusOfReserveSpaceRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmStatusOfReserveSpaceRequestRequest"))
		{	*type = SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestRequest;
			return soap_in_ns1__srmStatusOfReserveSpaceRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmReserveSpaceResponse"))
		{	*type = SOAP_TYPE_ns1__srmReserveSpaceResponse;
			return soap_in_ns1__srmReserveSpaceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:srmReserveSpaceRequest"))
		{	*type = SOAP_TYPE_ns1__srmReserveSpaceRequest;
			return soap_in_ns1__srmReserveSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTSupportedTransferProtocol"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTSupportedTransferProtocol;
			return soap_in_ns1__ArrayOfTSupportedTransferProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TSupportedTransferProtocol"))
		{	*type = SOAP_TYPE_ns1__TSupportedTransferProtocol;
			return soap_in_ns1__TSupportedTransferProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTRequestTokenReturn"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTRequestTokenReturn;
			return soap_in_ns1__ArrayOfTRequestTokenReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TRequestTokenReturn"))
		{	*type = SOAP_TYPE_ns1__TRequestTokenReturn;
			return soap_in_ns1__TRequestTokenReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTPermissionReturn"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTPermissionReturn;
			return soap_in_ns1__ArrayOfTPermissionReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TPermissionReturn"))
		{	*type = SOAP_TYPE_ns1__TPermissionReturn;
			return soap_in_ns1__TPermissionReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTSURLPermissionReturn"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTSURLPermissionReturn;
			return soap_in_ns1__ArrayOfTSURLPermissionReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TSURLPermissionReturn"))
		{	*type = SOAP_TYPE_ns1__TSURLPermissionReturn;
			return soap_in_ns1__TSURLPermissionReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTRequestSummary"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTRequestSummary;
			return soap_in_ns1__ArrayOfTRequestSummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TRequestSummary"))
		{	*type = SOAP_TYPE_ns1__TRequestSummary;
			return soap_in_ns1__TRequestSummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTCopyRequestFileStatus"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTCopyRequestFileStatus;
			return soap_in_ns1__ArrayOfTCopyRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TCopyRequestFileStatus"))
		{	*type = SOAP_TYPE_ns1__TCopyRequestFileStatus;
			return soap_in_ns1__TCopyRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTPutRequestFileStatus"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTPutRequestFileStatus;
			return soap_in_ns1__ArrayOfTPutRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TPutRequestFileStatus"))
		{	*type = SOAP_TYPE_ns1__TPutRequestFileStatus;
			return soap_in_ns1__TPutRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTBringOnlineRequestFileStatus"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTBringOnlineRequestFileStatus;
			return soap_in_ns1__ArrayOfTBringOnlineRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TBringOnlineRequestFileStatus"))
		{	*type = SOAP_TYPE_ns1__TBringOnlineRequestFileStatus;
			return soap_in_ns1__TBringOnlineRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTGetRequestFileStatus"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTGetRequestFileStatus;
			return soap_in_ns1__ArrayOfTGetRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TGetRequestFileStatus"))
		{	*type = SOAP_TYPE_ns1__TGetRequestFileStatus;
			return soap_in_ns1__TGetRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTCopyFileRequest"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTCopyFileRequest;
			return soap_in_ns1__ArrayOfTCopyFileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TCopyFileRequest"))
		{	*type = SOAP_TYPE_ns1__TCopyFileRequest;
			return soap_in_ns1__TCopyFileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTPutFileRequest"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTPutFileRequest;
			return soap_in_ns1__ArrayOfTPutFileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TPutFileRequest"))
		{	*type = SOAP_TYPE_ns1__TPutFileRequest;
			return soap_in_ns1__TPutFileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTGetFileRequest"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTGetFileRequest;
			return soap_in_ns1__ArrayOfTGetFileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TGetFileRequest"))
		{	*type = SOAP_TYPE_ns1__TGetFileRequest;
			return soap_in_ns1__TGetFileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TTransferParameters"))
		{	*type = SOAP_TYPE_ns1__TTransferParameters;
			return soap_in_ns1__TTransferParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfAnyURI"))
		{	*type = SOAP_TYPE_ns1__ArrayOfAnyURI;
			return soap_in_ns1__ArrayOfAnyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTExtraInfo"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTExtraInfo;
			return soap_in_ns1__ArrayOfTExtraInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TExtraInfo"))
		{	*type = SOAP_TYPE_ns1__TExtraInfo;
			return soap_in_ns1__TExtraInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TDirOption"))
		{	*type = SOAP_TYPE_ns1__TDirOption;
			return soap_in_ns1__TDirOption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTMetaDataSpace"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTMetaDataSpace;
			return soap_in_ns1__ArrayOfTMetaDataSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TMetaDataSpace"))
		{	*type = SOAP_TYPE_ns1__TMetaDataSpace;
			return soap_in_ns1__TMetaDataSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTMetaDataPathDetail"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTMetaDataPathDetail;
			return soap_in_ns1__ArrayOfTMetaDataPathDetail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TMetaDataPathDetail"))
		{	*type = SOAP_TYPE_ns1__TMetaDataPathDetail;
			return soap_in_ns1__TMetaDataPathDetail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTSURLLifetimeReturnStatus"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTSURLLifetimeReturnStatus;
			return soap_in_ns1__ArrayOfTSURLLifetimeReturnStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TSURLLifetimeReturnStatus"))
		{	*type = SOAP_TYPE_ns1__TSURLLifetimeReturnStatus;
			return soap_in_ns1__TSURLLifetimeReturnStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTSURLReturnStatus"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTSURLReturnStatus;
			return soap_in_ns1__ArrayOfTSURLReturnStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TSURLReturnStatus"))
		{	*type = SOAP_TYPE_ns1__TSURLReturnStatus;
			return soap_in_ns1__TSURLReturnStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TReturnStatus"))
		{	*type = SOAP_TYPE_ns1__TReturnStatus;
			return soap_in_ns1__TReturnStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfString"))
		{	*type = SOAP_TYPE_ns1__ArrayOfString;
			return soap_in_ns1__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfUnsignedLong"))
		{	*type = SOAP_TYPE_ns1__ArrayOfUnsignedLong;
			return soap_in_ns1__ArrayOfUnsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTGroupPermission"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTGroupPermission;
			return soap_in_ns1__ArrayOfTGroupPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TGroupPermission"))
		{	*type = SOAP_TYPE_ns1__TGroupPermission;
			return soap_in_ns1__TGroupPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTUserPermission"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTUserPermission;
			return soap_in_ns1__ArrayOfTUserPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TUserPermission"))
		{	*type = SOAP_TYPE_ns1__TUserPermission;
			return soap_in_ns1__TUserPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TRetentionPolicyInfo"))
		{	*type = SOAP_TYPE_ns1__TRetentionPolicyInfo;
			return soap_in_ns1__TRetentionPolicyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns1__TStatusCode:
		return soap_out_ns1__TStatusCode(soap, tag, id, (const enum ns1__TStatusCode *)ptr, "ns1:TStatusCode");
	case SOAP_TYPE_ns1__TConnectionType:
		return soap_out_ns1__TConnectionType(soap, tag, id, (const enum ns1__TConnectionType *)ptr, "ns1:TConnectionType");
	case SOAP_TYPE_ns1__TAccessPattern:
		return soap_out_ns1__TAccessPattern(soap, tag, id, (const enum ns1__TAccessPattern *)ptr, "ns1:TAccessPattern");
	case SOAP_TYPE_ns1__TFileLocality:
		return soap_out_ns1__TFileLocality(soap, tag, id, (const enum ns1__TFileLocality *)ptr, "ns1:TFileLocality");
	case SOAP_TYPE_ns1__TOverwriteMode:
		return soap_out_ns1__TOverwriteMode(soap, tag, id, (const enum ns1__TOverwriteMode *)ptr, "ns1:TOverwriteMode");
	case SOAP_TYPE_ns1__TRequestType:
		return soap_out_ns1__TRequestType(soap, tag, id, (const enum ns1__TRequestType *)ptr, "ns1:TRequestType");
	case SOAP_TYPE_ns1__TPermissionType:
		return soap_out_ns1__TPermissionType(soap, tag, id, (const enum ns1__TPermissionType *)ptr, "ns1:TPermissionType");
	case SOAP_TYPE_ns1__TPermissionMode:
		return soap_out_ns1__TPermissionMode(soap, tag, id, (const enum ns1__TPermissionMode *)ptr, "ns1:TPermissionMode");
	case SOAP_TYPE_ns1__TAccessLatency:
		return soap_out_ns1__TAccessLatency(soap, tag, id, (const enum ns1__TAccessLatency *)ptr, "ns1:TAccessLatency");
	case SOAP_TYPE_ns1__TRetentionPolicy:
		return soap_out_ns1__TRetentionPolicy(soap, tag, id, (const enum ns1__TRetentionPolicy *)ptr, "ns1:TRetentionPolicy");
	case SOAP_TYPE_ns1__TFileType:
		return soap_out_ns1__TFileType(soap, tag, id, (const enum ns1__TFileType *)ptr, "ns1:TFileType");
	case SOAP_TYPE_ns1__TFileStorageType:
		return soap_out_ns1__TFileStorageType(soap, tag, id, (const enum ns1__TFileStorageType *)ptr, "ns1:TFileStorageType");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__srmPing:
		return soap_out_ns1__srmPing(soap, tag, id, (const struct ns1__srmPing *)ptr, "ns1:srmPing");
	case SOAP_TYPE_ns1__srmPingResponse_:
		return soap_out_ns1__srmPingResponse_(soap, tag, id, (const struct ns1__srmPingResponse_ *)ptr, "ns1:srmPingResponse");
	case SOAP_TYPE_ns1__srmGetTransferProtocols:
		return soap_out_ns1__srmGetTransferProtocols(soap, tag, id, (const struct ns1__srmGetTransferProtocols *)ptr, "ns1:srmGetTransferProtocols");
	case SOAP_TYPE_ns1__srmGetTransferProtocolsResponse_:
		return soap_out_ns1__srmGetTransferProtocolsResponse_(soap, tag, id, (const struct ns1__srmGetTransferProtocolsResponse_ *)ptr, "ns1:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_ns1__srmGetRequestTokens:
		return soap_out_ns1__srmGetRequestTokens(soap, tag, id, (const struct ns1__srmGetRequestTokens *)ptr, "ns1:srmGetRequestTokens");
	case SOAP_TYPE_ns1__srmGetRequestTokensResponse_:
		return soap_out_ns1__srmGetRequestTokensResponse_(soap, tag, id, (const struct ns1__srmGetRequestTokensResponse_ *)ptr, "ns1:srmGetRequestTokensResponse");
	case SOAP_TYPE_ns1__srmExtendFileLifeTime:
		return soap_out_ns1__srmExtendFileLifeTime(soap, tag, id, (const struct ns1__srmExtendFileLifeTime *)ptr, "ns1:srmExtendFileLifeTime");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse_:
		return soap_out_ns1__srmExtendFileLifeTimeResponse_(soap, tag, id, (const struct ns1__srmExtendFileLifeTimeResponse_ *)ptr, "ns1:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_ns1__srmGetRequestSummary:
		return soap_out_ns1__srmGetRequestSummary(soap, tag, id, (const struct ns1__srmGetRequestSummary *)ptr, "ns1:srmGetRequestSummary");
	case SOAP_TYPE_ns1__srmGetRequestSummaryResponse_:
		return soap_out_ns1__srmGetRequestSummaryResponse_(soap, tag, id, (const struct ns1__srmGetRequestSummaryResponse_ *)ptr, "ns1:srmGetRequestSummaryResponse");
	case SOAP_TYPE_ns1__srmResumeRequest:
		return soap_out_ns1__srmResumeRequest(soap, tag, id, (const struct ns1__srmResumeRequest *)ptr, "ns1:srmResumeRequest");
	case SOAP_TYPE_ns1__srmResumeRequestResponse_:
		return soap_out_ns1__srmResumeRequestResponse_(soap, tag, id, (const struct ns1__srmResumeRequestResponse_ *)ptr, "ns1:srmResumeRequestResponse");
	case SOAP_TYPE_ns1__srmSuspendRequest:
		return soap_out_ns1__srmSuspendRequest(soap, tag, id, (const struct ns1__srmSuspendRequest *)ptr, "ns1:srmSuspendRequest");
	case SOAP_TYPE_ns1__srmSuspendRequestResponse_:
		return soap_out_ns1__srmSuspendRequestResponse_(soap, tag, id, (const struct ns1__srmSuspendRequestResponse_ *)ptr, "ns1:srmSuspendRequestResponse");
	case SOAP_TYPE_ns1__srmAbortFiles:
		return soap_out_ns1__srmAbortFiles(soap, tag, id, (const struct ns1__srmAbortFiles *)ptr, "ns1:srmAbortFiles");
	case SOAP_TYPE_ns1__srmAbortFilesResponse_:
		return soap_out_ns1__srmAbortFilesResponse_(soap, tag, id, (const struct ns1__srmAbortFilesResponse_ *)ptr, "ns1:srmAbortFilesResponse");
	case SOAP_TYPE_ns1__srmAbortRequest:
		return soap_out_ns1__srmAbortRequest(soap, tag, id, (const struct ns1__srmAbortRequest *)ptr, "ns1:srmAbortRequest");
	case SOAP_TYPE_ns1__srmAbortRequestResponse_:
		return soap_out_ns1__srmAbortRequestResponse_(soap, tag, id, (const struct ns1__srmAbortRequestResponse_ *)ptr, "ns1:srmAbortRequestResponse");
	case SOAP_TYPE_ns1__srmPutDone:
		return soap_out_ns1__srmPutDone(soap, tag, id, (const struct ns1__srmPutDone *)ptr, "ns1:srmPutDone");
	case SOAP_TYPE_ns1__srmPutDoneResponse_:
		return soap_out_ns1__srmPutDoneResponse_(soap, tag, id, (const struct ns1__srmPutDoneResponse_ *)ptr, "ns1:srmPutDoneResponse");
	case SOAP_TYPE_ns1__srmReleaseFiles:
		return soap_out_ns1__srmReleaseFiles(soap, tag, id, (const struct ns1__srmReleaseFiles *)ptr, "ns1:srmReleaseFiles");
	case SOAP_TYPE_ns1__srmReleaseFilesResponse_:
		return soap_out_ns1__srmReleaseFilesResponse_(soap, tag, id, (const struct ns1__srmReleaseFilesResponse_ *)ptr, "ns1:srmReleaseFilesResponse");
	case SOAP_TYPE_ns1__srmStatusOfCopyRequest:
		return soap_out_ns1__srmStatusOfCopyRequest(soap, tag, id, (const struct ns1__srmStatusOfCopyRequest *)ptr, "ns1:srmStatusOfCopyRequest");
	case SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse_:
		return soap_out_ns1__srmStatusOfCopyRequestResponse_(soap, tag, id, (const struct ns1__srmStatusOfCopyRequestResponse_ *)ptr, "ns1:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_ns1__srmCopy:
		return soap_out_ns1__srmCopy(soap, tag, id, (const struct ns1__srmCopy *)ptr, "ns1:srmCopy");
	case SOAP_TYPE_ns1__srmCopyResponse_:
		return soap_out_ns1__srmCopyResponse_(soap, tag, id, (const struct ns1__srmCopyResponse_ *)ptr, "ns1:srmCopyResponse");
	case SOAP_TYPE_ns1__srmStatusOfPutRequest:
		return soap_out_ns1__srmStatusOfPutRequest(soap, tag, id, (const struct ns1__srmStatusOfPutRequest *)ptr, "ns1:srmStatusOfPutRequest");
	case SOAP_TYPE_ns1__srmStatusOfPutRequestResponse_:
		return soap_out_ns1__srmStatusOfPutRequestResponse_(soap, tag, id, (const struct ns1__srmStatusOfPutRequestResponse_ *)ptr, "ns1:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_ns1__srmPrepareToPut:
		return soap_out_ns1__srmPrepareToPut(soap, tag, id, (const struct ns1__srmPrepareToPut *)ptr, "ns1:srmPrepareToPut");
	case SOAP_TYPE_ns1__srmPrepareToPutResponse_:
		return soap_out_ns1__srmPrepareToPutResponse_(soap, tag, id, (const struct ns1__srmPrepareToPutResponse_ *)ptr, "ns1:srmPrepareToPutResponse");
	case SOAP_TYPE_ns1__srmStatusOfBringOnlineRequest:
		return soap_out_ns1__srmStatusOfBringOnlineRequest(soap, tag, id, (const struct ns1__srmStatusOfBringOnlineRequest *)ptr, "ns1:srmStatusOfBringOnlineRequest");
	case SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse_:
		return soap_out_ns1__srmStatusOfBringOnlineRequestResponse_(soap, tag, id, (const struct ns1__srmStatusOfBringOnlineRequestResponse_ *)ptr, "ns1:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_ns1__srmBringOnline:
		return soap_out_ns1__srmBringOnline(soap, tag, id, (const struct ns1__srmBringOnline *)ptr, "ns1:srmBringOnline");
	case SOAP_TYPE_ns1__srmBringOnlineResponse_:
		return soap_out_ns1__srmBringOnlineResponse_(soap, tag, id, (const struct ns1__srmBringOnlineResponse_ *)ptr, "ns1:srmBringOnlineResponse");
	case SOAP_TYPE_ns1__srmStatusOfGetRequest:
		return soap_out_ns1__srmStatusOfGetRequest(soap, tag, id, (const struct ns1__srmStatusOfGetRequest *)ptr, "ns1:srmStatusOfGetRequest");
	case SOAP_TYPE_ns1__srmStatusOfGetRequestResponse_:
		return soap_out_ns1__srmStatusOfGetRequestResponse_(soap, tag, id, (const struct ns1__srmStatusOfGetRequestResponse_ *)ptr, "ns1:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_ns1__srmPrepareToGet:
		return soap_out_ns1__srmPrepareToGet(soap, tag, id, (const struct ns1__srmPrepareToGet *)ptr, "ns1:srmPrepareToGet");
	case SOAP_TYPE_ns1__srmPrepareToGetResponse_:
		return soap_out_ns1__srmPrepareToGetResponse_(soap, tag, id, (const struct ns1__srmPrepareToGetResponse_ *)ptr, "ns1:srmPrepareToGetResponse");
	case SOAP_TYPE_ns1__srmMv:
		return soap_out_ns1__srmMv(soap, tag, id, (const struct ns1__srmMv *)ptr, "ns1:srmMv");
	case SOAP_TYPE_ns1__srmMvResponse_:
		return soap_out_ns1__srmMvResponse_(soap, tag, id, (const struct ns1__srmMvResponse_ *)ptr, "ns1:srmMvResponse");
	case SOAP_TYPE_ns1__srmStatusOfLsRequest:
		return soap_out_ns1__srmStatusOfLsRequest(soap, tag, id, (const struct ns1__srmStatusOfLsRequest *)ptr, "ns1:srmStatusOfLsRequest");
	case SOAP_TYPE_ns1__srmStatusOfLsRequestResponse_:
		return soap_out_ns1__srmStatusOfLsRequestResponse_(soap, tag, id, (const struct ns1__srmStatusOfLsRequestResponse_ *)ptr, "ns1:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_ns1__srmLs:
		return soap_out_ns1__srmLs(soap, tag, id, (const struct ns1__srmLs *)ptr, "ns1:srmLs");
	case SOAP_TYPE_ns1__srmLsResponse_:
		return soap_out_ns1__srmLsResponse_(soap, tag, id, (const struct ns1__srmLsResponse_ *)ptr, "ns1:srmLsResponse");
	case SOAP_TYPE_ns1__srmRm:
		return soap_out_ns1__srmRm(soap, tag, id, (const struct ns1__srmRm *)ptr, "ns1:srmRm");
	case SOAP_TYPE_ns1__srmRmResponse_:
		return soap_out_ns1__srmRmResponse_(soap, tag, id, (const struct ns1__srmRmResponse_ *)ptr, "ns1:srmRmResponse");
	case SOAP_TYPE_ns1__srmRmdir:
		return soap_out_ns1__srmRmdir(soap, tag, id, (const struct ns1__srmRmdir *)ptr, "ns1:srmRmdir");
	case SOAP_TYPE_ns1__srmRmdirResponse_:
		return soap_out_ns1__srmRmdirResponse_(soap, tag, id, (const struct ns1__srmRmdirResponse_ *)ptr, "ns1:srmRmdirResponse");
	case SOAP_TYPE_ns1__srmMkdir:
		return soap_out_ns1__srmMkdir(soap, tag, id, (const struct ns1__srmMkdir *)ptr, "ns1:srmMkdir");
	case SOAP_TYPE_ns1__srmMkdirResponse_:
		return soap_out_ns1__srmMkdirResponse_(soap, tag, id, (const struct ns1__srmMkdirResponse_ *)ptr, "ns1:srmMkdirResponse");
	case SOAP_TYPE_ns1__srmGetPermission:
		return soap_out_ns1__srmGetPermission(soap, tag, id, (const struct ns1__srmGetPermission *)ptr, "ns1:srmGetPermission");
	case SOAP_TYPE_ns1__srmGetPermissionResponse_:
		return soap_out_ns1__srmGetPermissionResponse_(soap, tag, id, (const struct ns1__srmGetPermissionResponse_ *)ptr, "ns1:srmGetPermissionResponse");
	case SOAP_TYPE_ns1__srmCheckPermission:
		return soap_out_ns1__srmCheckPermission(soap, tag, id, (const struct ns1__srmCheckPermission *)ptr, "ns1:srmCheckPermission");
	case SOAP_TYPE_ns1__srmCheckPermissionResponse_:
		return soap_out_ns1__srmCheckPermissionResponse_(soap, tag, id, (const struct ns1__srmCheckPermissionResponse_ *)ptr, "ns1:srmCheckPermissionResponse");
	case SOAP_TYPE_ns1__srmSetPermission:
		return soap_out_ns1__srmSetPermission(soap, tag, id, (const struct ns1__srmSetPermission *)ptr, "ns1:srmSetPermission");
	case SOAP_TYPE_ns1__srmSetPermissionResponse_:
		return soap_out_ns1__srmSetPermissionResponse_(soap, tag, id, (const struct ns1__srmSetPermissionResponse_ *)ptr, "ns1:srmSetPermissionResponse");
	case SOAP_TYPE_ns1__srmGetSpaceTokens:
		return soap_out_ns1__srmGetSpaceTokens(soap, tag, id, (const struct ns1__srmGetSpaceTokens *)ptr, "ns1:srmGetSpaceTokens");
	case SOAP_TYPE_ns1__srmGetSpaceTokensResponse_:
		return soap_out_ns1__srmGetSpaceTokensResponse_(soap, tag, id, (const struct ns1__srmGetSpaceTokensResponse_ *)ptr, "ns1:srmGetSpaceTokensResponse");
	case SOAP_TYPE_ns1__srmPurgeFromSpace:
		return soap_out_ns1__srmPurgeFromSpace(soap, tag, id, (const struct ns1__srmPurgeFromSpace *)ptr, "ns1:srmPurgeFromSpace");
	case SOAP_TYPE_ns1__srmPurgeFromSpaceResponse_:
		return soap_out_ns1__srmPurgeFromSpaceResponse_(soap, tag, id, (const struct ns1__srmPurgeFromSpaceResponse_ *)ptr, "ns1:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpace:
		return soap_out_ns1__srmExtendFileLifeTimeInSpace(soap, tag, id, (const struct ns1__srmExtendFileLifeTimeInSpace *)ptr, "ns1:srmExtendFileLifeTimeInSpace");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse_:
		return soap_out_ns1__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, id, (const struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *)ptr, "ns1:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequest:
		return soap_out_ns1__srmStatusOfChangeSpaceForFilesRequest(soap, tag, id, (const struct ns1__srmStatusOfChangeSpaceForFilesRequest *)ptr, "ns1:srmStatusOfChangeSpaceForFilesRequest");
	case SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_:
		return soap_out_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, id, (const struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *)ptr, "ns1:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_ns1__srmChangeSpaceForFiles:
		return soap_out_ns1__srmChangeSpaceForFiles(soap, tag, id, (const struct ns1__srmChangeSpaceForFiles *)ptr, "ns1:srmChangeSpaceForFiles");
	case SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse_:
		return soap_out_ns1__srmChangeSpaceForFilesResponse_(soap, tag, id, (const struct ns1__srmChangeSpaceForFilesResponse_ *)ptr, "ns1:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_ns1__srmGetSpaceMetaData:
		return soap_out_ns1__srmGetSpaceMetaData(soap, tag, id, (const struct ns1__srmGetSpaceMetaData *)ptr, "ns1:srmGetSpaceMetaData");
	case SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse_:
		return soap_out_ns1__srmGetSpaceMetaDataResponse_(soap, tag, id, (const struct ns1__srmGetSpaceMetaDataResponse_ *)ptr, "ns1:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequest:
		return soap_out_ns1__srmStatusOfUpdateSpaceRequest(soap, tag, id, (const struct ns1__srmStatusOfUpdateSpaceRequest *)ptr, "ns1:srmStatusOfUpdateSpaceRequest");
	case SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse_:
		return soap_out_ns1__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, id, (const struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *)ptr, "ns1:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_ns1__srmUpdateSpace:
		return soap_out_ns1__srmUpdateSpace(soap, tag, id, (const struct ns1__srmUpdateSpace *)ptr, "ns1:srmUpdateSpace");
	case SOAP_TYPE_ns1__srmUpdateSpaceResponse_:
		return soap_out_ns1__srmUpdateSpaceResponse_(soap, tag, id, (const struct ns1__srmUpdateSpaceResponse_ *)ptr, "ns1:srmUpdateSpaceResponse");
	case SOAP_TYPE_ns1__srmReleaseSpace:
		return soap_out_ns1__srmReleaseSpace(soap, tag, id, (const struct ns1__srmReleaseSpace *)ptr, "ns1:srmReleaseSpace");
	case SOAP_TYPE_ns1__srmReleaseSpaceResponse_:
		return soap_out_ns1__srmReleaseSpaceResponse_(soap, tag, id, (const struct ns1__srmReleaseSpaceResponse_ *)ptr, "ns1:srmReleaseSpaceResponse");
	case SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequest:
		return soap_out_ns1__srmStatusOfReserveSpaceRequest(soap, tag, id, (const struct ns1__srmStatusOfReserveSpaceRequest *)ptr, "ns1:srmStatusOfReserveSpaceRequest");
	case SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse_:
		return soap_out_ns1__srmStatusOfReserveSpaceRequestResponse_(soap, tag, id, (const struct ns1__srmStatusOfReserveSpaceRequestResponse_ *)ptr, "ns1:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_ns1__srmReserveSpace:
		return soap_out_ns1__srmReserveSpace(soap, tag, id, (const struct ns1__srmReserveSpace *)ptr, "ns1:srmReserveSpace");
	case SOAP_TYPE_ns1__srmReserveSpaceResponse_:
		return soap_out_ns1__srmReserveSpaceResponse_(soap, tag, id, (const struct ns1__srmReserveSpaceResponse_ *)ptr, "ns1:srmReserveSpaceResponse");
	case SOAP_TYPE_ns1__srmPingResponse:
		return soap_out_ns1__srmPingResponse(soap, tag, id, (const struct ns1__srmPingResponse *)ptr, "ns1:srmPingResponse");
	case SOAP_TYPE_ns1__srmPingRequest:
		return soap_out_ns1__srmPingRequest(soap, tag, id, (const struct ns1__srmPingRequest *)ptr, "ns1:srmPingRequest");
	case SOAP_TYPE_ns1__srmGetTransferProtocolsResponse:
		return soap_out_ns1__srmGetTransferProtocolsResponse(soap, tag, id, (const struct ns1__srmGetTransferProtocolsResponse *)ptr, "ns1:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_ns1__srmGetTransferProtocolsRequest:
		return soap_out_ns1__srmGetTransferProtocolsRequest(soap, tag, id, (const struct ns1__srmGetTransferProtocolsRequest *)ptr, "ns1:srmGetTransferProtocolsRequest");
	case SOAP_TYPE_ns1__srmGetRequestTokensResponse:
		return soap_out_ns1__srmGetRequestTokensResponse(soap, tag, id, (const struct ns1__srmGetRequestTokensResponse *)ptr, "ns1:srmGetRequestTokensResponse");
	case SOAP_TYPE_ns1__srmGetRequestTokensRequest:
		return soap_out_ns1__srmGetRequestTokensRequest(soap, tag, id, (const struct ns1__srmGetRequestTokensRequest *)ptr, "ns1:srmGetRequestTokensRequest");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse:
		return soap_out_ns1__srmExtendFileLifeTimeResponse(soap, tag, id, (const struct ns1__srmExtendFileLifeTimeResponse *)ptr, "ns1:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeRequest:
		return soap_out_ns1__srmExtendFileLifeTimeRequest(soap, tag, id, (const struct ns1__srmExtendFileLifeTimeRequest *)ptr, "ns1:srmExtendFileLifeTimeRequest");
	case SOAP_TYPE_ns1__srmGetRequestSummaryResponse:
		return soap_out_ns1__srmGetRequestSummaryResponse(soap, tag, id, (const struct ns1__srmGetRequestSummaryResponse *)ptr, "ns1:srmGetRequestSummaryResponse");
	case SOAP_TYPE_ns1__srmGetRequestSummaryRequest:
		return soap_out_ns1__srmGetRequestSummaryRequest(soap, tag, id, (const struct ns1__srmGetRequestSummaryRequest *)ptr, "ns1:srmGetRequestSummaryRequest");
	case SOAP_TYPE_ns1__srmResumeRequestResponse:
		return soap_out_ns1__srmResumeRequestResponse(soap, tag, id, (const struct ns1__srmResumeRequestResponse *)ptr, "ns1:srmResumeRequestResponse");
	case SOAP_TYPE_ns1__srmResumeRequestRequest:
		return soap_out_ns1__srmResumeRequestRequest(soap, tag, id, (const struct ns1__srmResumeRequestRequest *)ptr, "ns1:srmResumeRequestRequest");
	case SOAP_TYPE_ns1__srmSuspendRequestResponse:
		return soap_out_ns1__srmSuspendRequestResponse(soap, tag, id, (const struct ns1__srmSuspendRequestResponse *)ptr, "ns1:srmSuspendRequestResponse");
	case SOAP_TYPE_ns1__srmSuspendRequestRequest:
		return soap_out_ns1__srmSuspendRequestRequest(soap, tag, id, (const struct ns1__srmSuspendRequestRequest *)ptr, "ns1:srmSuspendRequestRequest");
	case SOAP_TYPE_ns1__srmAbortFilesResponse:
		return soap_out_ns1__srmAbortFilesResponse(soap, tag, id, (const struct ns1__srmAbortFilesResponse *)ptr, "ns1:srmAbortFilesResponse");
	case SOAP_TYPE_ns1__srmAbortFilesRequest:
		return soap_out_ns1__srmAbortFilesRequest(soap, tag, id, (const struct ns1__srmAbortFilesRequest *)ptr, "ns1:srmAbortFilesRequest");
	case SOAP_TYPE_ns1__srmAbortRequestResponse:
		return soap_out_ns1__srmAbortRequestResponse(soap, tag, id, (const struct ns1__srmAbortRequestResponse *)ptr, "ns1:srmAbortRequestResponse");
	case SOAP_TYPE_ns1__srmAbortRequestRequest:
		return soap_out_ns1__srmAbortRequestRequest(soap, tag, id, (const struct ns1__srmAbortRequestRequest *)ptr, "ns1:srmAbortRequestRequest");
	case SOAP_TYPE_ns1__srmPutDoneResponse:
		return soap_out_ns1__srmPutDoneResponse(soap, tag, id, (const struct ns1__srmPutDoneResponse *)ptr, "ns1:srmPutDoneResponse");
	case SOAP_TYPE_ns1__srmPutDoneRequest:
		return soap_out_ns1__srmPutDoneRequest(soap, tag, id, (const struct ns1__srmPutDoneRequest *)ptr, "ns1:srmPutDoneRequest");
	case SOAP_TYPE_ns1__srmReleaseFilesResponse:
		return soap_out_ns1__srmReleaseFilesResponse(soap, tag, id, (const struct ns1__srmReleaseFilesResponse *)ptr, "ns1:srmReleaseFilesResponse");
	case SOAP_TYPE_ns1__srmReleaseFilesRequest:
		return soap_out_ns1__srmReleaseFilesRequest(soap, tag, id, (const struct ns1__srmReleaseFilesRequest *)ptr, "ns1:srmReleaseFilesRequest");
	case SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse:
		return soap_out_ns1__srmStatusOfCopyRequestResponse(soap, tag, id, (const struct ns1__srmStatusOfCopyRequestResponse *)ptr, "ns1:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfCopyRequestRequest:
		return soap_out_ns1__srmStatusOfCopyRequestRequest(soap, tag, id, (const struct ns1__srmStatusOfCopyRequestRequest *)ptr, "ns1:srmStatusOfCopyRequestRequest");
	case SOAP_TYPE_ns1__srmCopyResponse:
		return soap_out_ns1__srmCopyResponse(soap, tag, id, (const struct ns1__srmCopyResponse *)ptr, "ns1:srmCopyResponse");
	case SOAP_TYPE_ns1__srmCopyRequest:
		return soap_out_ns1__srmCopyRequest(soap, tag, id, (const struct ns1__srmCopyRequest *)ptr, "ns1:srmCopyRequest");
	case SOAP_TYPE_ns1__srmStatusOfPutRequestResponse:
		return soap_out_ns1__srmStatusOfPutRequestResponse(soap, tag, id, (const struct ns1__srmStatusOfPutRequestResponse *)ptr, "ns1:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfPutRequestRequest:
		return soap_out_ns1__srmStatusOfPutRequestRequest(soap, tag, id, (const struct ns1__srmStatusOfPutRequestRequest *)ptr, "ns1:srmStatusOfPutRequestRequest");
	case SOAP_TYPE_ns1__srmPrepareToPutResponse:
		return soap_out_ns1__srmPrepareToPutResponse(soap, tag, id, (const struct ns1__srmPrepareToPutResponse *)ptr, "ns1:srmPrepareToPutResponse");
	case SOAP_TYPE_ns1__srmPrepareToPutRequest:
		return soap_out_ns1__srmPrepareToPutRequest(soap, tag, id, (const struct ns1__srmPrepareToPutRequest *)ptr, "ns1:srmPrepareToPutRequest");
	case SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse:
		return soap_out_ns1__srmStatusOfBringOnlineRequestResponse(soap, tag, id, (const struct ns1__srmStatusOfBringOnlineRequestResponse *)ptr, "ns1:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestRequest:
		return soap_out_ns1__srmStatusOfBringOnlineRequestRequest(soap, tag, id, (const struct ns1__srmStatusOfBringOnlineRequestRequest *)ptr, "ns1:srmStatusOfBringOnlineRequestRequest");
	case SOAP_TYPE_ns1__srmBringOnlineResponse:
		return soap_out_ns1__srmBringOnlineResponse(soap, tag, id, (const struct ns1__srmBringOnlineResponse *)ptr, "ns1:srmBringOnlineResponse");
	case SOAP_TYPE_ns1__srmBringOnlineRequest:
		return soap_out_ns1__srmBringOnlineRequest(soap, tag, id, (const struct ns1__srmBringOnlineRequest *)ptr, "ns1:srmBringOnlineRequest");
	case SOAP_TYPE_ns1__srmStatusOfGetRequestResponse:
		return soap_out_ns1__srmStatusOfGetRequestResponse(soap, tag, id, (const struct ns1__srmStatusOfGetRequestResponse *)ptr, "ns1:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfGetRequestRequest:
		return soap_out_ns1__srmStatusOfGetRequestRequest(soap, tag, id, (const struct ns1__srmStatusOfGetRequestRequest *)ptr, "ns1:srmStatusOfGetRequestRequest");
	case SOAP_TYPE_ns1__srmPrepareToGetResponse:
		return soap_out_ns1__srmPrepareToGetResponse(soap, tag, id, (const struct ns1__srmPrepareToGetResponse *)ptr, "ns1:srmPrepareToGetResponse");
	case SOAP_TYPE_ns1__srmPrepareToGetRequest:
		return soap_out_ns1__srmPrepareToGetRequest(soap, tag, id, (const struct ns1__srmPrepareToGetRequest *)ptr, "ns1:srmPrepareToGetRequest");
	case SOAP_TYPE_ns1__srmMvResponse:
		return soap_out_ns1__srmMvResponse(soap, tag, id, (const struct ns1__srmMvResponse *)ptr, "ns1:srmMvResponse");
	case SOAP_TYPE_ns1__srmMvRequest:
		return soap_out_ns1__srmMvRequest(soap, tag, id, (const struct ns1__srmMvRequest *)ptr, "ns1:srmMvRequest");
	case SOAP_TYPE_ns1__srmStatusOfLsRequestResponse:
		return soap_out_ns1__srmStatusOfLsRequestResponse(soap, tag, id, (const struct ns1__srmStatusOfLsRequestResponse *)ptr, "ns1:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfLsRequestRequest:
		return soap_out_ns1__srmStatusOfLsRequestRequest(soap, tag, id, (const struct ns1__srmStatusOfLsRequestRequest *)ptr, "ns1:srmStatusOfLsRequestRequest");
	case SOAP_TYPE_ns1__srmLsResponse:
		return soap_out_ns1__srmLsResponse(soap, tag, id, (const struct ns1__srmLsResponse *)ptr, "ns1:srmLsResponse");
	case SOAP_TYPE_ns1__srmLsRequest:
		return soap_out_ns1__srmLsRequest(soap, tag, id, (const struct ns1__srmLsRequest *)ptr, "ns1:srmLsRequest");
	case SOAP_TYPE_ns1__srmRmResponse:
		return soap_out_ns1__srmRmResponse(soap, tag, id, (const struct ns1__srmRmResponse *)ptr, "ns1:srmRmResponse");
	case SOAP_TYPE_ns1__srmRmRequest:
		return soap_out_ns1__srmRmRequest(soap, tag, id, (const struct ns1__srmRmRequest *)ptr, "ns1:srmRmRequest");
	case SOAP_TYPE_ns1__srmRmdirResponse:
		return soap_out_ns1__srmRmdirResponse(soap, tag, id, (const struct ns1__srmRmdirResponse *)ptr, "ns1:srmRmdirResponse");
	case SOAP_TYPE_ns1__srmRmdirRequest:
		return soap_out_ns1__srmRmdirRequest(soap, tag, id, (const struct ns1__srmRmdirRequest *)ptr, "ns1:srmRmdirRequest");
	case SOAP_TYPE_ns1__srmMkdirResponse:
		return soap_out_ns1__srmMkdirResponse(soap, tag, id, (const struct ns1__srmMkdirResponse *)ptr, "ns1:srmMkdirResponse");
	case SOAP_TYPE_ns1__srmMkdirRequest:
		return soap_out_ns1__srmMkdirRequest(soap, tag, id, (const struct ns1__srmMkdirRequest *)ptr, "ns1:srmMkdirRequest");
	case SOAP_TYPE_ns1__srmGetPermissionResponse:
		return soap_out_ns1__srmGetPermissionResponse(soap, tag, id, (const struct ns1__srmGetPermissionResponse *)ptr, "ns1:srmGetPermissionResponse");
	case SOAP_TYPE_ns1__srmGetPermissionRequest:
		return soap_out_ns1__srmGetPermissionRequest(soap, tag, id, (const struct ns1__srmGetPermissionRequest *)ptr, "ns1:srmGetPermissionRequest");
	case SOAP_TYPE_ns1__srmCheckPermissionResponse:
		return soap_out_ns1__srmCheckPermissionResponse(soap, tag, id, (const struct ns1__srmCheckPermissionResponse *)ptr, "ns1:srmCheckPermissionResponse");
	case SOAP_TYPE_ns1__srmCheckPermissionRequest:
		return soap_out_ns1__srmCheckPermissionRequest(soap, tag, id, (const struct ns1__srmCheckPermissionRequest *)ptr, "ns1:srmCheckPermissionRequest");
	case SOAP_TYPE_ns1__srmSetPermissionResponse:
		return soap_out_ns1__srmSetPermissionResponse(soap, tag, id, (const struct ns1__srmSetPermissionResponse *)ptr, "ns1:srmSetPermissionResponse");
	case SOAP_TYPE_ns1__srmSetPermissionRequest:
		return soap_out_ns1__srmSetPermissionRequest(soap, tag, id, (const struct ns1__srmSetPermissionRequest *)ptr, "ns1:srmSetPermissionRequest");
	case SOAP_TYPE_ns1__srmGetSpaceTokensResponse:
		return soap_out_ns1__srmGetSpaceTokensResponse(soap, tag, id, (const struct ns1__srmGetSpaceTokensResponse *)ptr, "ns1:srmGetSpaceTokensResponse");
	case SOAP_TYPE_ns1__srmGetSpaceTokensRequest:
		return soap_out_ns1__srmGetSpaceTokensRequest(soap, tag, id, (const struct ns1__srmGetSpaceTokensRequest *)ptr, "ns1:srmGetSpaceTokensRequest");
	case SOAP_TYPE_ns1__srmPurgeFromSpaceResponse:
		return soap_out_ns1__srmPurgeFromSpaceResponse(soap, tag, id, (const struct ns1__srmPurgeFromSpaceResponse *)ptr, "ns1:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_ns1__srmPurgeFromSpaceRequest:
		return soap_out_ns1__srmPurgeFromSpaceRequest(soap, tag, id, (const struct ns1__srmPurgeFromSpaceRequest *)ptr, "ns1:srmPurgeFromSpaceRequest");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse:
		return soap_out_ns1__srmExtendFileLifeTimeInSpaceResponse(soap, tag, id, (const struct ns1__srmExtendFileLifeTimeInSpaceResponse *)ptr, "ns1:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceRequest:
		return soap_out_ns1__srmExtendFileLifeTimeInSpaceRequest(soap, tag, id, (const struct ns1__srmExtendFileLifeTimeInSpaceRequest *)ptr, "ns1:srmExtendFileLifeTimeInSpaceRequest");
	case SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse:
		return soap_out_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, id, (const struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *)ptr, "ns1:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestRequest:
		return soap_out_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, id, (const struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *)ptr, "ns1:srmStatusOfChangeSpaceForFilesRequestRequest");
	case SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse:
		return soap_out_ns1__srmChangeSpaceForFilesResponse(soap, tag, id, (const struct ns1__srmChangeSpaceForFilesResponse *)ptr, "ns1:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_ns1__srmChangeSpaceForFilesRequest:
		return soap_out_ns1__srmChangeSpaceForFilesRequest(soap, tag, id, (const struct ns1__srmChangeSpaceForFilesRequest *)ptr, "ns1:srmChangeSpaceForFilesRequest");
	case SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse:
		return soap_out_ns1__srmGetSpaceMetaDataResponse(soap, tag, id, (const struct ns1__srmGetSpaceMetaDataResponse *)ptr, "ns1:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_ns1__srmGetSpaceMetaDataRequest:
		return soap_out_ns1__srmGetSpaceMetaDataRequest(soap, tag, id, (const struct ns1__srmGetSpaceMetaDataRequest *)ptr, "ns1:srmGetSpaceMetaDataRequest");
	case SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse:
		return soap_out_ns1__srmStatusOfUpdateSpaceRequestResponse(soap, tag, id, (const struct ns1__srmStatusOfUpdateSpaceRequestResponse *)ptr, "ns1:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestRequest:
		return soap_out_ns1__srmStatusOfUpdateSpaceRequestRequest(soap, tag, id, (const struct ns1__srmStatusOfUpdateSpaceRequestRequest *)ptr, "ns1:srmStatusOfUpdateSpaceRequestRequest");
	case SOAP_TYPE_ns1__srmUpdateSpaceResponse:
		return soap_out_ns1__srmUpdateSpaceResponse(soap, tag, id, (const struct ns1__srmUpdateSpaceResponse *)ptr, "ns1:srmUpdateSpaceResponse");
	case SOAP_TYPE_ns1__srmUpdateSpaceRequest:
		return soap_out_ns1__srmUpdateSpaceRequest(soap, tag, id, (const struct ns1__srmUpdateSpaceRequest *)ptr, "ns1:srmUpdateSpaceRequest");
	case SOAP_TYPE_ns1__srmReleaseSpaceResponse:
		return soap_out_ns1__srmReleaseSpaceResponse(soap, tag, id, (const struct ns1__srmReleaseSpaceResponse *)ptr, "ns1:srmReleaseSpaceResponse");
	case SOAP_TYPE_ns1__srmReleaseSpaceRequest:
		return soap_out_ns1__srmReleaseSpaceRequest(soap, tag, id, (const struct ns1__srmReleaseSpaceRequest *)ptr, "ns1:srmReleaseSpaceRequest");
	case SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse:
		return soap_out_ns1__srmStatusOfReserveSpaceRequestResponse(soap, tag, id, (const struct ns1__srmStatusOfReserveSpaceRequestResponse *)ptr, "ns1:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestRequest:
		return soap_out_ns1__srmStatusOfReserveSpaceRequestRequest(soap, tag, id, (const struct ns1__srmStatusOfReserveSpaceRequestRequest *)ptr, "ns1:srmStatusOfReserveSpaceRequestRequest");
	case SOAP_TYPE_ns1__srmReserveSpaceResponse:
		return soap_out_ns1__srmReserveSpaceResponse(soap, tag, id, (const struct ns1__srmReserveSpaceResponse *)ptr, "ns1:srmReserveSpaceResponse");
	case SOAP_TYPE_ns1__srmReserveSpaceRequest:
		return soap_out_ns1__srmReserveSpaceRequest(soap, tag, id, (const struct ns1__srmReserveSpaceRequest *)ptr, "ns1:srmReserveSpaceRequest");
	case SOAP_TYPE_ns1__ArrayOfTSupportedTransferProtocol:
		return soap_out_ns1__ArrayOfTSupportedTransferProtocol(soap, tag, id, (const struct ns1__ArrayOfTSupportedTransferProtocol *)ptr, "ns1:ArrayOfTSupportedTransferProtocol");
	case SOAP_TYPE_ns1__TSupportedTransferProtocol:
		return soap_out_ns1__TSupportedTransferProtocol(soap, tag, id, (const struct ns1__TSupportedTransferProtocol *)ptr, "ns1:TSupportedTransferProtocol");
	case SOAP_TYPE_ns1__ArrayOfTRequestTokenReturn:
		return soap_out_ns1__ArrayOfTRequestTokenReturn(soap, tag, id, (const struct ns1__ArrayOfTRequestTokenReturn *)ptr, "ns1:ArrayOfTRequestTokenReturn");
	case SOAP_TYPE_ns1__TRequestTokenReturn:
		return soap_out_ns1__TRequestTokenReturn(soap, tag, id, (const struct ns1__TRequestTokenReturn *)ptr, "ns1:TRequestTokenReturn");
	case SOAP_TYPE_ns1__ArrayOfTPermissionReturn:
		return soap_out_ns1__ArrayOfTPermissionReturn(soap, tag, id, (const struct ns1__ArrayOfTPermissionReturn *)ptr, "ns1:ArrayOfTPermissionReturn");
	case SOAP_TYPE_ns1__TPermissionReturn:
		return soap_out_ns1__TPermissionReturn(soap, tag, id, (const struct ns1__TPermissionReturn *)ptr, "ns1:TPermissionReturn");
	case SOAP_TYPE_ns1__ArrayOfTSURLPermissionReturn:
		return soap_out_ns1__ArrayOfTSURLPermissionReturn(soap, tag, id, (const struct ns1__ArrayOfTSURLPermissionReturn *)ptr, "ns1:ArrayOfTSURLPermissionReturn");
	case SOAP_TYPE_ns1__TSURLPermissionReturn:
		return soap_out_ns1__TSURLPermissionReturn(soap, tag, id, (const struct ns1__TSURLPermissionReturn *)ptr, "ns1:TSURLPermissionReturn");
	case SOAP_TYPE_ns1__ArrayOfTRequestSummary:
		return soap_out_ns1__ArrayOfTRequestSummary(soap, tag, id, (const struct ns1__ArrayOfTRequestSummary *)ptr, "ns1:ArrayOfTRequestSummary");
	case SOAP_TYPE_ns1__TRequestSummary:
		return soap_out_ns1__TRequestSummary(soap, tag, id, (const struct ns1__TRequestSummary *)ptr, "ns1:TRequestSummary");
	case SOAP_TYPE_ns1__ArrayOfTCopyRequestFileStatus:
		return soap_out_ns1__ArrayOfTCopyRequestFileStatus(soap, tag, id, (const struct ns1__ArrayOfTCopyRequestFileStatus *)ptr, "ns1:ArrayOfTCopyRequestFileStatus");
	case SOAP_TYPE_ns1__TCopyRequestFileStatus:
		return soap_out_ns1__TCopyRequestFileStatus(soap, tag, id, (const struct ns1__TCopyRequestFileStatus *)ptr, "ns1:TCopyRequestFileStatus");
	case SOAP_TYPE_ns1__ArrayOfTPutRequestFileStatus:
		return soap_out_ns1__ArrayOfTPutRequestFileStatus(soap, tag, id, (const struct ns1__ArrayOfTPutRequestFileStatus *)ptr, "ns1:ArrayOfTPutRequestFileStatus");
	case SOAP_TYPE_ns1__TPutRequestFileStatus:
		return soap_out_ns1__TPutRequestFileStatus(soap, tag, id, (const struct ns1__TPutRequestFileStatus *)ptr, "ns1:TPutRequestFileStatus");
	case SOAP_TYPE_ns1__ArrayOfTBringOnlineRequestFileStatus:
		return soap_out_ns1__ArrayOfTBringOnlineRequestFileStatus(soap, tag, id, (const struct ns1__ArrayOfTBringOnlineRequestFileStatus *)ptr, "ns1:ArrayOfTBringOnlineRequestFileStatus");
	case SOAP_TYPE_ns1__TBringOnlineRequestFileStatus:
		return soap_out_ns1__TBringOnlineRequestFileStatus(soap, tag, id, (const struct ns1__TBringOnlineRequestFileStatus *)ptr, "ns1:TBringOnlineRequestFileStatus");
	case SOAP_TYPE_ns1__ArrayOfTGetRequestFileStatus:
		return soap_out_ns1__ArrayOfTGetRequestFileStatus(soap, tag, id, (const struct ns1__ArrayOfTGetRequestFileStatus *)ptr, "ns1:ArrayOfTGetRequestFileStatus");
	case SOAP_TYPE_ns1__TGetRequestFileStatus:
		return soap_out_ns1__TGetRequestFileStatus(soap, tag, id, (const struct ns1__TGetRequestFileStatus *)ptr, "ns1:TGetRequestFileStatus");
	case SOAP_TYPE_ns1__ArrayOfTCopyFileRequest:
		return soap_out_ns1__ArrayOfTCopyFileRequest(soap, tag, id, (const struct ns1__ArrayOfTCopyFileRequest *)ptr, "ns1:ArrayOfTCopyFileRequest");
	case SOAP_TYPE_ns1__TCopyFileRequest:
		return soap_out_ns1__TCopyFileRequest(soap, tag, id, (const struct ns1__TCopyFileRequest *)ptr, "ns1:TCopyFileRequest");
	case SOAP_TYPE_ns1__ArrayOfTPutFileRequest:
		return soap_out_ns1__ArrayOfTPutFileRequest(soap, tag, id, (const struct ns1__ArrayOfTPutFileRequest *)ptr, "ns1:ArrayOfTPutFileRequest");
	case SOAP_TYPE_ns1__TPutFileRequest:
		return soap_out_ns1__TPutFileRequest(soap, tag, id, (const struct ns1__TPutFileRequest *)ptr, "ns1:TPutFileRequest");
	case SOAP_TYPE_ns1__ArrayOfTGetFileRequest:
		return soap_out_ns1__ArrayOfTGetFileRequest(soap, tag, id, (const struct ns1__ArrayOfTGetFileRequest *)ptr, "ns1:ArrayOfTGetFileRequest");
	case SOAP_TYPE_ns1__TGetFileRequest:
		return soap_out_ns1__TGetFileRequest(soap, tag, id, (const struct ns1__TGetFileRequest *)ptr, "ns1:TGetFileRequest");
	case SOAP_TYPE_ns1__TTransferParameters:
		return soap_out_ns1__TTransferParameters(soap, tag, id, (const struct ns1__TTransferParameters *)ptr, "ns1:TTransferParameters");
	case SOAP_TYPE_ns1__ArrayOfAnyURI:
		return soap_out_ns1__ArrayOfAnyURI(soap, tag, id, (const struct ns1__ArrayOfAnyURI *)ptr, "ns1:ArrayOfAnyURI");
	case SOAP_TYPE_ns1__ArrayOfTExtraInfo:
		return soap_out_ns1__ArrayOfTExtraInfo(soap, tag, id, (const struct ns1__ArrayOfTExtraInfo *)ptr, "ns1:ArrayOfTExtraInfo");
	case SOAP_TYPE_ns1__TExtraInfo:
		return soap_out_ns1__TExtraInfo(soap, tag, id, (const struct ns1__TExtraInfo *)ptr, "ns1:TExtraInfo");
	case SOAP_TYPE_ns1__TDirOption:
		return soap_out_ns1__TDirOption(soap, tag, id, (const struct ns1__TDirOption *)ptr, "ns1:TDirOption");
	case SOAP_TYPE_ns1__ArrayOfTMetaDataSpace:
		return soap_out_ns1__ArrayOfTMetaDataSpace(soap, tag, id, (const struct ns1__ArrayOfTMetaDataSpace *)ptr, "ns1:ArrayOfTMetaDataSpace");
	case SOAP_TYPE_ns1__TMetaDataSpace:
		return soap_out_ns1__TMetaDataSpace(soap, tag, id, (const struct ns1__TMetaDataSpace *)ptr, "ns1:TMetaDataSpace");
	case SOAP_TYPE_ns1__ArrayOfTMetaDataPathDetail:
		return soap_out_ns1__ArrayOfTMetaDataPathDetail(soap, tag, id, (const struct ns1__ArrayOfTMetaDataPathDetail *)ptr, "ns1:ArrayOfTMetaDataPathDetail");
	case SOAP_TYPE_ns1__TMetaDataPathDetail:
		return soap_out_ns1__TMetaDataPathDetail(soap, tag, id, (const struct ns1__TMetaDataPathDetail *)ptr, "ns1:TMetaDataPathDetail");
	case SOAP_TYPE_ns1__ArrayOfTSURLLifetimeReturnStatus:
		return soap_out_ns1__ArrayOfTSURLLifetimeReturnStatus(soap, tag, id, (const struct ns1__ArrayOfTSURLLifetimeReturnStatus *)ptr, "ns1:ArrayOfTSURLLifetimeReturnStatus");
	case SOAP_TYPE_ns1__TSURLLifetimeReturnStatus:
		return soap_out_ns1__TSURLLifetimeReturnStatus(soap, tag, id, (const struct ns1__TSURLLifetimeReturnStatus *)ptr, "ns1:TSURLLifetimeReturnStatus");
	case SOAP_TYPE_ns1__ArrayOfTSURLReturnStatus:
		return soap_out_ns1__ArrayOfTSURLReturnStatus(soap, tag, id, (const struct ns1__ArrayOfTSURLReturnStatus *)ptr, "ns1:ArrayOfTSURLReturnStatus");
	case SOAP_TYPE_ns1__TSURLReturnStatus:
		return soap_out_ns1__TSURLReturnStatus(soap, tag, id, (const struct ns1__TSURLReturnStatus *)ptr, "ns1:TSURLReturnStatus");
	case SOAP_TYPE_ns1__TReturnStatus:
		return soap_out_ns1__TReturnStatus(soap, tag, id, (const struct ns1__TReturnStatus *)ptr, "ns1:TReturnStatus");
	case SOAP_TYPE_ns1__ArrayOfString:
		return soap_out_ns1__ArrayOfString(soap, tag, id, (const struct ns1__ArrayOfString *)ptr, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__ArrayOfUnsignedLong:
		return soap_out_ns1__ArrayOfUnsignedLong(soap, tag, id, (const struct ns1__ArrayOfUnsignedLong *)ptr, "ns1:ArrayOfUnsignedLong");
	case SOAP_TYPE_ns1__ArrayOfTGroupPermission:
		return soap_out_ns1__ArrayOfTGroupPermission(soap, tag, id, (const struct ns1__ArrayOfTGroupPermission *)ptr, "ns1:ArrayOfTGroupPermission");
	case SOAP_TYPE_ns1__TGroupPermission:
		return soap_out_ns1__TGroupPermission(soap, tag, id, (const struct ns1__TGroupPermission *)ptr, "ns1:TGroupPermission");
	case SOAP_TYPE_ns1__ArrayOfTUserPermission:
		return soap_out_ns1__ArrayOfTUserPermission(soap, tag, id, (const struct ns1__ArrayOfTUserPermission *)ptr, "ns1:ArrayOfTUserPermission");
	case SOAP_TYPE_ns1__TUserPermission:
		return soap_out_ns1__TUserPermission(soap, tag, id, (const struct ns1__TUserPermission *)ptr, "ns1:TUserPermission");
	case SOAP_TYPE_ns1__TRetentionPolicyInfo:
		return soap_out_ns1__TRetentionPolicyInfo(soap, tag, id, (const struct ns1__TRetentionPolicyInfo *)ptr, "ns1:TRetentionPolicyInfo");
	case SOAP_TYPE_PointerTons1__srmPingResponse_:
		return soap_out_PointerTons1__srmPingResponse_(soap, tag, id, (struct ns1__srmPingResponse_ *const*)ptr, "ns1:srmPingResponse");
	case SOAP_TYPE_PointerTons1__srmPingRequest:
		return soap_out_PointerTons1__srmPingRequest(soap, tag, id, (struct ns1__srmPingRequest *const*)ptr, "ns1:srmPingRequest");
	case SOAP_TYPE_PointerTons1__srmPingResponse:
		return soap_out_PointerTons1__srmPingResponse(soap, tag, id, (struct ns1__srmPingResponse *const*)ptr, "ns1:srmPingResponse");
	case SOAP_TYPE_PointerTons1__srmGetTransferProtocolsResponse_:
		return soap_out_PointerTons1__srmGetTransferProtocolsResponse_(soap, tag, id, (struct ns1__srmGetTransferProtocolsResponse_ *const*)ptr, "ns1:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_PointerTons1__srmGetTransferProtocolsRequest:
		return soap_out_PointerTons1__srmGetTransferProtocolsRequest(soap, tag, id, (struct ns1__srmGetTransferProtocolsRequest *const*)ptr, "ns1:srmGetTransferProtocolsRequest");
	case SOAP_TYPE_PointerTons1__srmGetTransferProtocolsResponse:
		return soap_out_PointerTons1__srmGetTransferProtocolsResponse(soap, tag, id, (struct ns1__srmGetTransferProtocolsResponse *const*)ptr, "ns1:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_PointerTons1__srmGetRequestTokensResponse_:
		return soap_out_PointerTons1__srmGetRequestTokensResponse_(soap, tag, id, (struct ns1__srmGetRequestTokensResponse_ *const*)ptr, "ns1:srmGetRequestTokensResponse");
	case SOAP_TYPE_PointerTons1__srmGetRequestTokensRequest:
		return soap_out_PointerTons1__srmGetRequestTokensRequest(soap, tag, id, (struct ns1__srmGetRequestTokensRequest *const*)ptr, "ns1:srmGetRequestTokensRequest");
	case SOAP_TYPE_PointerTons1__srmGetRequestTokensResponse:
		return soap_out_PointerTons1__srmGetRequestTokensResponse(soap, tag, id, (struct ns1__srmGetRequestTokensResponse *const*)ptr, "ns1:srmGetRequestTokensResponse");
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeResponse_:
		return soap_out_PointerTons1__srmExtendFileLifeTimeResponse_(soap, tag, id, (struct ns1__srmExtendFileLifeTimeResponse_ *const*)ptr, "ns1:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeRequest:
		return soap_out_PointerTons1__srmExtendFileLifeTimeRequest(soap, tag, id, (struct ns1__srmExtendFileLifeTimeRequest *const*)ptr, "ns1:srmExtendFileLifeTimeRequest");
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeResponse:
		return soap_out_PointerTons1__srmExtendFileLifeTimeResponse(soap, tag, id, (struct ns1__srmExtendFileLifeTimeResponse *const*)ptr, "ns1:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_PointerTons1__srmGetRequestSummaryResponse_:
		return soap_out_PointerTons1__srmGetRequestSummaryResponse_(soap, tag, id, (struct ns1__srmGetRequestSummaryResponse_ *const*)ptr, "ns1:srmGetRequestSummaryResponse");
	case SOAP_TYPE_PointerTons1__srmGetRequestSummaryRequest:
		return soap_out_PointerTons1__srmGetRequestSummaryRequest(soap, tag, id, (struct ns1__srmGetRequestSummaryRequest *const*)ptr, "ns1:srmGetRequestSummaryRequest");
	case SOAP_TYPE_PointerTons1__srmGetRequestSummaryResponse:
		return soap_out_PointerTons1__srmGetRequestSummaryResponse(soap, tag, id, (struct ns1__srmGetRequestSummaryResponse *const*)ptr, "ns1:srmGetRequestSummaryResponse");
	case SOAP_TYPE_PointerTons1__srmResumeRequestResponse_:
		return soap_out_PointerTons1__srmResumeRequestResponse_(soap, tag, id, (struct ns1__srmResumeRequestResponse_ *const*)ptr, "ns1:srmResumeRequestResponse");
	case SOAP_TYPE_PointerTons1__srmResumeRequestRequest:
		return soap_out_PointerTons1__srmResumeRequestRequest(soap, tag, id, (struct ns1__srmResumeRequestRequest *const*)ptr, "ns1:srmResumeRequestRequest");
	case SOAP_TYPE_PointerTons1__srmResumeRequestResponse:
		return soap_out_PointerTons1__srmResumeRequestResponse(soap, tag, id, (struct ns1__srmResumeRequestResponse *const*)ptr, "ns1:srmResumeRequestResponse");
	case SOAP_TYPE_PointerTons1__srmSuspendRequestResponse_:
		return soap_out_PointerTons1__srmSuspendRequestResponse_(soap, tag, id, (struct ns1__srmSuspendRequestResponse_ *const*)ptr, "ns1:srmSuspendRequestResponse");
	case SOAP_TYPE_PointerTons1__srmSuspendRequestRequest:
		return soap_out_PointerTons1__srmSuspendRequestRequest(soap, tag, id, (struct ns1__srmSuspendRequestRequest *const*)ptr, "ns1:srmSuspendRequestRequest");
	case SOAP_TYPE_PointerTons1__srmSuspendRequestResponse:
		return soap_out_PointerTons1__srmSuspendRequestResponse(soap, tag, id, (struct ns1__srmSuspendRequestResponse *const*)ptr, "ns1:srmSuspendRequestResponse");
	case SOAP_TYPE_PointerTons1__srmAbortFilesResponse_:
		return soap_out_PointerTons1__srmAbortFilesResponse_(soap, tag, id, (struct ns1__srmAbortFilesResponse_ *const*)ptr, "ns1:srmAbortFilesResponse");
	case SOAP_TYPE_PointerTons1__srmAbortFilesRequest:
		return soap_out_PointerTons1__srmAbortFilesRequest(soap, tag, id, (struct ns1__srmAbortFilesRequest *const*)ptr, "ns1:srmAbortFilesRequest");
	case SOAP_TYPE_PointerTons1__srmAbortFilesResponse:
		return soap_out_PointerTons1__srmAbortFilesResponse(soap, tag, id, (struct ns1__srmAbortFilesResponse *const*)ptr, "ns1:srmAbortFilesResponse");
	case SOAP_TYPE_PointerTons1__srmAbortRequestResponse_:
		return soap_out_PointerTons1__srmAbortRequestResponse_(soap, tag, id, (struct ns1__srmAbortRequestResponse_ *const*)ptr, "ns1:srmAbortRequestResponse");
	case SOAP_TYPE_PointerTons1__srmAbortRequestRequest:
		return soap_out_PointerTons1__srmAbortRequestRequest(soap, tag, id, (struct ns1__srmAbortRequestRequest *const*)ptr, "ns1:srmAbortRequestRequest");
	case SOAP_TYPE_PointerTons1__srmAbortRequestResponse:
		return soap_out_PointerTons1__srmAbortRequestResponse(soap, tag, id, (struct ns1__srmAbortRequestResponse *const*)ptr, "ns1:srmAbortRequestResponse");
	case SOAP_TYPE_PointerTons1__srmPutDoneResponse_:
		return soap_out_PointerTons1__srmPutDoneResponse_(soap, tag, id, (struct ns1__srmPutDoneResponse_ *const*)ptr, "ns1:srmPutDoneResponse");
	case SOAP_TYPE_PointerTons1__srmPutDoneRequest:
		return soap_out_PointerTons1__srmPutDoneRequest(soap, tag, id, (struct ns1__srmPutDoneRequest *const*)ptr, "ns1:srmPutDoneRequest");
	case SOAP_TYPE_PointerTons1__srmPutDoneResponse:
		return soap_out_PointerTons1__srmPutDoneResponse(soap, tag, id, (struct ns1__srmPutDoneResponse *const*)ptr, "ns1:srmPutDoneResponse");
	case SOAP_TYPE_PointerTons1__srmReleaseFilesResponse_:
		return soap_out_PointerTons1__srmReleaseFilesResponse_(soap, tag, id, (struct ns1__srmReleaseFilesResponse_ *const*)ptr, "ns1:srmReleaseFilesResponse");
	case SOAP_TYPE_PointerTons1__srmReleaseFilesRequest:
		return soap_out_PointerTons1__srmReleaseFilesRequest(soap, tag, id, (struct ns1__srmReleaseFilesRequest *const*)ptr, "ns1:srmReleaseFilesRequest");
	case SOAP_TYPE_PointerTons1__srmReleaseFilesResponse:
		return soap_out_PointerTons1__srmReleaseFilesResponse(soap, tag, id, (struct ns1__srmReleaseFilesResponse *const*)ptr, "ns1:srmReleaseFilesResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfCopyRequestResponse_:
		return soap_out_PointerTons1__srmStatusOfCopyRequestResponse_(soap, tag, id, (struct ns1__srmStatusOfCopyRequestResponse_ *const*)ptr, "ns1:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfCopyRequestRequest:
		return soap_out_PointerTons1__srmStatusOfCopyRequestRequest(soap, tag, id, (struct ns1__srmStatusOfCopyRequestRequest *const*)ptr, "ns1:srmStatusOfCopyRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfCopyRequestResponse:
		return soap_out_PointerTons1__srmStatusOfCopyRequestResponse(soap, tag, id, (struct ns1__srmStatusOfCopyRequestResponse *const*)ptr, "ns1:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_PointerTons1__srmCopyResponse_:
		return soap_out_PointerTons1__srmCopyResponse_(soap, tag, id, (struct ns1__srmCopyResponse_ *const*)ptr, "ns1:srmCopyResponse");
	case SOAP_TYPE_PointerTons1__srmCopyRequest:
		return soap_out_PointerTons1__srmCopyRequest(soap, tag, id, (struct ns1__srmCopyRequest *const*)ptr, "ns1:srmCopyRequest");
	case SOAP_TYPE_PointerTons1__srmCopyResponse:
		return soap_out_PointerTons1__srmCopyResponse(soap, tag, id, (struct ns1__srmCopyResponse *const*)ptr, "ns1:srmCopyResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfPutRequestResponse_:
		return soap_out_PointerTons1__srmStatusOfPutRequestResponse_(soap, tag, id, (struct ns1__srmStatusOfPutRequestResponse_ *const*)ptr, "ns1:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfPutRequestRequest:
		return soap_out_PointerTons1__srmStatusOfPutRequestRequest(soap, tag, id, (struct ns1__srmStatusOfPutRequestRequest *const*)ptr, "ns1:srmStatusOfPutRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfPutRequestResponse:
		return soap_out_PointerTons1__srmStatusOfPutRequestResponse(soap, tag, id, (struct ns1__srmStatusOfPutRequestResponse *const*)ptr, "ns1:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_PointerTons1__srmPrepareToPutResponse_:
		return soap_out_PointerTons1__srmPrepareToPutResponse_(soap, tag, id, (struct ns1__srmPrepareToPutResponse_ *const*)ptr, "ns1:srmPrepareToPutResponse");
	case SOAP_TYPE_PointerTons1__srmPrepareToPutRequest:
		return soap_out_PointerTons1__srmPrepareToPutRequest(soap, tag, id, (struct ns1__srmPrepareToPutRequest *const*)ptr, "ns1:srmPrepareToPutRequest");
	case SOAP_TYPE_PointerTons1__srmPrepareToPutResponse:
		return soap_out_PointerTons1__srmPrepareToPutResponse(soap, tag, id, (struct ns1__srmPrepareToPutResponse *const*)ptr, "ns1:srmPrepareToPutResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfBringOnlineRequestResponse_:
		return soap_out_PointerTons1__srmStatusOfBringOnlineRequestResponse_(soap, tag, id, (struct ns1__srmStatusOfBringOnlineRequestResponse_ *const*)ptr, "ns1:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfBringOnlineRequestRequest:
		return soap_out_PointerTons1__srmStatusOfBringOnlineRequestRequest(soap, tag, id, (struct ns1__srmStatusOfBringOnlineRequestRequest *const*)ptr, "ns1:srmStatusOfBringOnlineRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfBringOnlineRequestResponse:
		return soap_out_PointerTons1__srmStatusOfBringOnlineRequestResponse(soap, tag, id, (struct ns1__srmStatusOfBringOnlineRequestResponse *const*)ptr, "ns1:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_PointerTons1__srmBringOnlineResponse_:
		return soap_out_PointerTons1__srmBringOnlineResponse_(soap, tag, id, (struct ns1__srmBringOnlineResponse_ *const*)ptr, "ns1:srmBringOnlineResponse");
	case SOAP_TYPE_PointerTons1__srmBringOnlineRequest:
		return soap_out_PointerTons1__srmBringOnlineRequest(soap, tag, id, (struct ns1__srmBringOnlineRequest *const*)ptr, "ns1:srmBringOnlineRequest");
	case SOAP_TYPE_PointerTons1__srmBringOnlineResponse:
		return soap_out_PointerTons1__srmBringOnlineResponse(soap, tag, id, (struct ns1__srmBringOnlineResponse *const*)ptr, "ns1:srmBringOnlineResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfGetRequestResponse_:
		return soap_out_PointerTons1__srmStatusOfGetRequestResponse_(soap, tag, id, (struct ns1__srmStatusOfGetRequestResponse_ *const*)ptr, "ns1:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfGetRequestRequest:
		return soap_out_PointerTons1__srmStatusOfGetRequestRequest(soap, tag, id, (struct ns1__srmStatusOfGetRequestRequest *const*)ptr, "ns1:srmStatusOfGetRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfGetRequestResponse:
		return soap_out_PointerTons1__srmStatusOfGetRequestResponse(soap, tag, id, (struct ns1__srmStatusOfGetRequestResponse *const*)ptr, "ns1:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_PointerTons1__srmPrepareToGetResponse_:
		return soap_out_PointerTons1__srmPrepareToGetResponse_(soap, tag, id, (struct ns1__srmPrepareToGetResponse_ *const*)ptr, "ns1:srmPrepareToGetResponse");
	case SOAP_TYPE_PointerTons1__srmPrepareToGetRequest:
		return soap_out_PointerTons1__srmPrepareToGetRequest(soap, tag, id, (struct ns1__srmPrepareToGetRequest *const*)ptr, "ns1:srmPrepareToGetRequest");
	case SOAP_TYPE_PointerTons1__srmPrepareToGetResponse:
		return soap_out_PointerTons1__srmPrepareToGetResponse(soap, tag, id, (struct ns1__srmPrepareToGetResponse *const*)ptr, "ns1:srmPrepareToGetResponse");
	case SOAP_TYPE_PointerTons1__srmMvResponse_:
		return soap_out_PointerTons1__srmMvResponse_(soap, tag, id, (struct ns1__srmMvResponse_ *const*)ptr, "ns1:srmMvResponse");
	case SOAP_TYPE_PointerTons1__srmMvRequest:
		return soap_out_PointerTons1__srmMvRequest(soap, tag, id, (struct ns1__srmMvRequest *const*)ptr, "ns1:srmMvRequest");
	case SOAP_TYPE_PointerTons1__srmMvResponse:
		return soap_out_PointerTons1__srmMvResponse(soap, tag, id, (struct ns1__srmMvResponse *const*)ptr, "ns1:srmMvResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfLsRequestResponse_:
		return soap_out_PointerTons1__srmStatusOfLsRequestResponse_(soap, tag, id, (struct ns1__srmStatusOfLsRequestResponse_ *const*)ptr, "ns1:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfLsRequestRequest:
		return soap_out_PointerTons1__srmStatusOfLsRequestRequest(soap, tag, id, (struct ns1__srmStatusOfLsRequestRequest *const*)ptr, "ns1:srmStatusOfLsRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfLsRequestResponse:
		return soap_out_PointerTons1__srmStatusOfLsRequestResponse(soap, tag, id, (struct ns1__srmStatusOfLsRequestResponse *const*)ptr, "ns1:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_PointerTons1__srmLsResponse_:
		return soap_out_PointerTons1__srmLsResponse_(soap, tag, id, (struct ns1__srmLsResponse_ *const*)ptr, "ns1:srmLsResponse");
	case SOAP_TYPE_PointerTons1__srmLsRequest:
		return soap_out_PointerTons1__srmLsRequest(soap, tag, id, (struct ns1__srmLsRequest *const*)ptr, "ns1:srmLsRequest");
	case SOAP_TYPE_PointerTons1__srmLsResponse:
		return soap_out_PointerTons1__srmLsResponse(soap, tag, id, (struct ns1__srmLsResponse *const*)ptr, "ns1:srmLsResponse");
	case SOAP_TYPE_PointerTons1__srmRmResponse_:
		return soap_out_PointerTons1__srmRmResponse_(soap, tag, id, (struct ns1__srmRmResponse_ *const*)ptr, "ns1:srmRmResponse");
	case SOAP_TYPE_PointerTons1__srmRmRequest:
		return soap_out_PointerTons1__srmRmRequest(soap, tag, id, (struct ns1__srmRmRequest *const*)ptr, "ns1:srmRmRequest");
	case SOAP_TYPE_PointerTons1__srmRmResponse:
		return soap_out_PointerTons1__srmRmResponse(soap, tag, id, (struct ns1__srmRmResponse *const*)ptr, "ns1:srmRmResponse");
	case SOAP_TYPE_PointerTons1__srmRmdirResponse_:
		return soap_out_PointerTons1__srmRmdirResponse_(soap, tag, id, (struct ns1__srmRmdirResponse_ *const*)ptr, "ns1:srmRmdirResponse");
	case SOAP_TYPE_PointerTons1__srmRmdirRequest:
		return soap_out_PointerTons1__srmRmdirRequest(soap, tag, id, (struct ns1__srmRmdirRequest *const*)ptr, "ns1:srmRmdirRequest");
	case SOAP_TYPE_PointerTons1__srmRmdirResponse:
		return soap_out_PointerTons1__srmRmdirResponse(soap, tag, id, (struct ns1__srmRmdirResponse *const*)ptr, "ns1:srmRmdirResponse");
	case SOAP_TYPE_PointerTons1__srmMkdirResponse_:
		return soap_out_PointerTons1__srmMkdirResponse_(soap, tag, id, (struct ns1__srmMkdirResponse_ *const*)ptr, "ns1:srmMkdirResponse");
	case SOAP_TYPE_PointerTons1__srmMkdirRequest:
		return soap_out_PointerTons1__srmMkdirRequest(soap, tag, id, (struct ns1__srmMkdirRequest *const*)ptr, "ns1:srmMkdirRequest");
	case SOAP_TYPE_PointerTons1__srmMkdirResponse:
		return soap_out_PointerTons1__srmMkdirResponse(soap, tag, id, (struct ns1__srmMkdirResponse *const*)ptr, "ns1:srmMkdirResponse");
	case SOAP_TYPE_PointerTons1__srmGetPermissionResponse_:
		return soap_out_PointerTons1__srmGetPermissionResponse_(soap, tag, id, (struct ns1__srmGetPermissionResponse_ *const*)ptr, "ns1:srmGetPermissionResponse");
	case SOAP_TYPE_PointerTons1__srmGetPermissionRequest:
		return soap_out_PointerTons1__srmGetPermissionRequest(soap, tag, id, (struct ns1__srmGetPermissionRequest *const*)ptr, "ns1:srmGetPermissionRequest");
	case SOAP_TYPE_PointerTons1__srmGetPermissionResponse:
		return soap_out_PointerTons1__srmGetPermissionResponse(soap, tag, id, (struct ns1__srmGetPermissionResponse *const*)ptr, "ns1:srmGetPermissionResponse");
	case SOAP_TYPE_PointerTons1__srmCheckPermissionResponse_:
		return soap_out_PointerTons1__srmCheckPermissionResponse_(soap, tag, id, (struct ns1__srmCheckPermissionResponse_ *const*)ptr, "ns1:srmCheckPermissionResponse");
	case SOAP_TYPE_PointerTons1__srmCheckPermissionRequest:
		return soap_out_PointerTons1__srmCheckPermissionRequest(soap, tag, id, (struct ns1__srmCheckPermissionRequest *const*)ptr, "ns1:srmCheckPermissionRequest");
	case SOAP_TYPE_PointerTons1__srmCheckPermissionResponse:
		return soap_out_PointerTons1__srmCheckPermissionResponse(soap, tag, id, (struct ns1__srmCheckPermissionResponse *const*)ptr, "ns1:srmCheckPermissionResponse");
	case SOAP_TYPE_PointerTons1__srmSetPermissionResponse_:
		return soap_out_PointerTons1__srmSetPermissionResponse_(soap, tag, id, (struct ns1__srmSetPermissionResponse_ *const*)ptr, "ns1:srmSetPermissionResponse");
	case SOAP_TYPE_PointerTons1__srmSetPermissionRequest:
		return soap_out_PointerTons1__srmSetPermissionRequest(soap, tag, id, (struct ns1__srmSetPermissionRequest *const*)ptr, "ns1:srmSetPermissionRequest");
	case SOAP_TYPE_PointerTons1__srmSetPermissionResponse:
		return soap_out_PointerTons1__srmSetPermissionResponse(soap, tag, id, (struct ns1__srmSetPermissionResponse *const*)ptr, "ns1:srmSetPermissionResponse");
	case SOAP_TYPE_PointerTons1__srmGetSpaceTokensResponse_:
		return soap_out_PointerTons1__srmGetSpaceTokensResponse_(soap, tag, id, (struct ns1__srmGetSpaceTokensResponse_ *const*)ptr, "ns1:srmGetSpaceTokensResponse");
	case SOAP_TYPE_PointerTons1__srmGetSpaceTokensRequest:
		return soap_out_PointerTons1__srmGetSpaceTokensRequest(soap, tag, id, (struct ns1__srmGetSpaceTokensRequest *const*)ptr, "ns1:srmGetSpaceTokensRequest");
	case SOAP_TYPE_PointerTons1__srmGetSpaceTokensResponse:
		return soap_out_PointerTons1__srmGetSpaceTokensResponse(soap, tag, id, (struct ns1__srmGetSpaceTokensResponse *const*)ptr, "ns1:srmGetSpaceTokensResponse");
	case SOAP_TYPE_PointerTons1__srmPurgeFromSpaceResponse_:
		return soap_out_PointerTons1__srmPurgeFromSpaceResponse_(soap, tag, id, (struct ns1__srmPurgeFromSpaceResponse_ *const*)ptr, "ns1:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmPurgeFromSpaceRequest:
		return soap_out_PointerTons1__srmPurgeFromSpaceRequest(soap, tag, id, (struct ns1__srmPurgeFromSpaceRequest *const*)ptr, "ns1:srmPurgeFromSpaceRequest");
	case SOAP_TYPE_PointerTons1__srmPurgeFromSpaceResponse:
		return soap_out_PointerTons1__srmPurgeFromSpaceResponse(soap, tag, id, (struct ns1__srmPurgeFromSpaceResponse *const*)ptr, "ns1:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_:
		return soap_out_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, id, (struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *const*)ptr, "ns1:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeInSpaceRequest:
		return soap_out_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(soap, tag, id, (struct ns1__srmExtendFileLifeTimeInSpaceRequest *const*)ptr, "ns1:srmExtendFileLifeTimeInSpaceRequest");
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeInSpaceResponse:
		return soap_out_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(soap, tag, id, (struct ns1__srmExtendFileLifeTimeInSpaceResponse *const*)ptr, "ns1:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_:
		return soap_out_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, id, (struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *const*)ptr, "ns1:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest:
		return soap_out_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, id, (struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *const*)ptr, "ns1:srmStatusOfChangeSpaceForFilesRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse:
		return soap_out_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, id, (struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *const*)ptr, "ns1:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_PointerTons1__srmChangeSpaceForFilesResponse_:
		return soap_out_PointerTons1__srmChangeSpaceForFilesResponse_(soap, tag, id, (struct ns1__srmChangeSpaceForFilesResponse_ *const*)ptr, "ns1:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_PointerTons1__srmChangeSpaceForFilesRequest:
		return soap_out_PointerTons1__srmChangeSpaceForFilesRequest(soap, tag, id, (struct ns1__srmChangeSpaceForFilesRequest *const*)ptr, "ns1:srmChangeSpaceForFilesRequest");
	case SOAP_TYPE_PointerTons1__srmChangeSpaceForFilesResponse:
		return soap_out_PointerTons1__srmChangeSpaceForFilesResponse(soap, tag, id, (struct ns1__srmChangeSpaceForFilesResponse *const*)ptr, "ns1:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_PointerTons1__srmGetSpaceMetaDataResponse_:
		return soap_out_PointerTons1__srmGetSpaceMetaDataResponse_(soap, tag, id, (struct ns1__srmGetSpaceMetaDataResponse_ *const*)ptr, "ns1:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_PointerTons1__srmGetSpaceMetaDataRequest:
		return soap_out_PointerTons1__srmGetSpaceMetaDataRequest(soap, tag, id, (struct ns1__srmGetSpaceMetaDataRequest *const*)ptr, "ns1:srmGetSpaceMetaDataRequest");
	case SOAP_TYPE_PointerTons1__srmGetSpaceMetaDataResponse:
		return soap_out_PointerTons1__srmGetSpaceMetaDataResponse(soap, tag, id, (struct ns1__srmGetSpaceMetaDataResponse *const*)ptr, "ns1:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_:
		return soap_out_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, id, (struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *const*)ptr, "ns1:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfUpdateSpaceRequestRequest:
		return soap_out_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(soap, tag, id, (struct ns1__srmStatusOfUpdateSpaceRequestRequest *const*)ptr, "ns1:srmStatusOfUpdateSpaceRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfUpdateSpaceRequestResponse:
		return soap_out_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(soap, tag, id, (struct ns1__srmStatusOfUpdateSpaceRequestResponse *const*)ptr, "ns1:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_PointerTons1__srmUpdateSpaceResponse_:
		return soap_out_PointerTons1__srmUpdateSpaceResponse_(soap, tag, id, (struct ns1__srmUpdateSpaceResponse_ *const*)ptr, "ns1:srmUpdateSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmUpdateSpaceRequest:
		return soap_out_PointerTons1__srmUpdateSpaceRequest(soap, tag, id, (struct ns1__srmUpdateSpaceRequest *const*)ptr, "ns1:srmUpdateSpaceRequest");
	case SOAP_TYPE_PointerTons1__srmUpdateSpaceResponse:
		return soap_out_PointerTons1__srmUpdateSpaceResponse(soap, tag, id, (struct ns1__srmUpdateSpaceResponse *const*)ptr, "ns1:srmUpdateSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmReleaseSpaceResponse_:
		return soap_out_PointerTons1__srmReleaseSpaceResponse_(soap, tag, id, (struct ns1__srmReleaseSpaceResponse_ *const*)ptr, "ns1:srmReleaseSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmReleaseSpaceRequest:
		return soap_out_PointerTons1__srmReleaseSpaceRequest(soap, tag, id, (struct ns1__srmReleaseSpaceRequest *const*)ptr, "ns1:srmReleaseSpaceRequest");
	case SOAP_TYPE_PointerTons1__srmReleaseSpaceResponse:
		return soap_out_PointerTons1__srmReleaseSpaceResponse(soap, tag, id, (struct ns1__srmReleaseSpaceResponse *const*)ptr, "ns1:srmReleaseSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfReserveSpaceRequestResponse_:
		return soap_out_PointerTons1__srmStatusOfReserveSpaceRequestResponse_(soap, tag, id, (struct ns1__srmStatusOfReserveSpaceRequestResponse_ *const*)ptr, "ns1:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_PointerTons1__srmStatusOfReserveSpaceRequestRequest:
		return soap_out_PointerTons1__srmStatusOfReserveSpaceRequestRequest(soap, tag, id, (struct ns1__srmStatusOfReserveSpaceRequestRequest *const*)ptr, "ns1:srmStatusOfReserveSpaceRequestRequest");
	case SOAP_TYPE_PointerTons1__srmStatusOfReserveSpaceRequestResponse:
		return soap_out_PointerTons1__srmStatusOfReserveSpaceRequestResponse(soap, tag, id, (struct ns1__srmStatusOfReserveSpaceRequestResponse *const*)ptr, "ns1:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_PointerTons1__srmReserveSpaceResponse_:
		return soap_out_PointerTons1__srmReserveSpaceResponse_(soap, tag, id, (struct ns1__srmReserveSpaceResponse_ *const*)ptr, "ns1:srmReserveSpaceResponse");
	case SOAP_TYPE_PointerTons1__srmReserveSpaceRequest:
		return soap_out_PointerTons1__srmReserveSpaceRequest(soap, tag, id, (struct ns1__srmReserveSpaceRequest *const*)ptr, "ns1:srmReserveSpaceRequest");
	case SOAP_TYPE_PointerTons1__srmReserveSpaceResponse:
		return soap_out_PointerTons1__srmReserveSpaceResponse(soap, tag, id, (struct ns1__srmReserveSpaceResponse *const*)ptr, "ns1:srmReserveSpaceResponse");
	case SOAP_TYPE_PointerTons1__ArrayOfTSupportedTransferProtocol:
		return soap_out_PointerTons1__ArrayOfTSupportedTransferProtocol(soap, tag, id, (struct ns1__ArrayOfTSupportedTransferProtocol *const*)ptr, "ns1:ArrayOfTSupportedTransferProtocol");
	case SOAP_TYPE_PointerTons1__ArrayOfTRequestTokenReturn:
		return soap_out_PointerTons1__ArrayOfTRequestTokenReturn(soap, tag, id, (struct ns1__ArrayOfTRequestTokenReturn *const*)ptr, "ns1:ArrayOfTRequestTokenReturn");
	case SOAP_TYPE_PointerTons1__ArrayOfTRequestSummary:
		return soap_out_PointerTons1__ArrayOfTRequestSummary(soap, tag, id, (struct ns1__ArrayOfTRequestSummary *const*)ptr, "ns1:ArrayOfTRequestSummary");
	case SOAP_TYPE_PointerTons1__ArrayOfTCopyRequestFileStatus:
		return soap_out_PointerTons1__ArrayOfTCopyRequestFileStatus(soap, tag, id, (struct ns1__ArrayOfTCopyRequestFileStatus *const*)ptr, "ns1:ArrayOfTCopyRequestFileStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfTCopyFileRequest:
		return soap_out_PointerTons1__ArrayOfTCopyFileRequest(soap, tag, id, (struct ns1__ArrayOfTCopyFileRequest *const*)ptr, "ns1:ArrayOfTCopyFileRequest");
	case SOAP_TYPE_PointerTons1__ArrayOfTPutRequestFileStatus:
		return soap_out_PointerTons1__ArrayOfTPutRequestFileStatus(soap, tag, id, (struct ns1__ArrayOfTPutRequestFileStatus *const*)ptr, "ns1:ArrayOfTPutRequestFileStatus");
	case SOAP_TYPE_PointerTons1__TOverwriteMode:
		return soap_out_PointerTons1__TOverwriteMode(soap, tag, id, (enum ns1__TOverwriteMode *const*)ptr, "ns1:TOverwriteMode");
	case SOAP_TYPE_PointerTons1__ArrayOfTPutFileRequest:
		return soap_out_PointerTons1__ArrayOfTPutFileRequest(soap, tag, id, (struct ns1__ArrayOfTPutFileRequest *const*)ptr, "ns1:ArrayOfTPutFileRequest");
	case SOAP_TYPE_PointerTons1__ArrayOfTBringOnlineRequestFileStatus:
		return soap_out_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(soap, tag, id, (struct ns1__ArrayOfTBringOnlineRequestFileStatus *const*)ptr, "ns1:ArrayOfTBringOnlineRequestFileStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfTGetRequestFileStatus:
		return soap_out_PointerTons1__ArrayOfTGetRequestFileStatus(soap, tag, id, (struct ns1__ArrayOfTGetRequestFileStatus *const*)ptr, "ns1:ArrayOfTGetRequestFileStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfTGetFileRequest:
		return soap_out_PointerTons1__ArrayOfTGetFileRequest(soap, tag, id, (struct ns1__ArrayOfTGetFileRequest *const*)ptr, "ns1:ArrayOfTGetFileRequest");
	case SOAP_TYPE_PointerTons1__ArrayOfTPermissionReturn:
		return soap_out_PointerTons1__ArrayOfTPermissionReturn(soap, tag, id, (struct ns1__ArrayOfTPermissionReturn *const*)ptr, "ns1:ArrayOfTPermissionReturn");
	case SOAP_TYPE_PointerTons1__ArrayOfTSURLPermissionReturn:
		return soap_out_PointerTons1__ArrayOfTSURLPermissionReturn(soap, tag, id, (struct ns1__ArrayOfTSURLPermissionReturn *const*)ptr, "ns1:ArrayOfTSURLPermissionReturn");
	case SOAP_TYPE_PointerTons1__ArrayOfTSURLLifetimeReturnStatus:
		return soap_out_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(soap, tag, id, (struct ns1__ArrayOfTSURLLifetimeReturnStatus *const*)ptr, "ns1:ArrayOfTSURLLifetimeReturnStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfTSURLReturnStatus:
		return soap_out_PointerTons1__ArrayOfTSURLReturnStatus(soap, tag, id, (struct ns1__ArrayOfTSURLReturnStatus *const*)ptr, "ns1:ArrayOfTSURLReturnStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfAnyURI:
		return soap_out_PointerTons1__ArrayOfAnyURI(soap, tag, id, (struct ns1__ArrayOfAnyURI *const*)ptr, "ns1:ArrayOfAnyURI");
	case SOAP_TYPE_PointerTons1__ArrayOfTMetaDataSpace:
		return soap_out_PointerTons1__ArrayOfTMetaDataSpace(soap, tag, id, (struct ns1__ArrayOfTMetaDataSpace *const*)ptr, "ns1:ArrayOfTMetaDataSpace");
	case SOAP_TYPE_PointerTons1__TTransferParameters:
		return soap_out_PointerTons1__TTransferParameters(soap, tag, id, (struct ns1__TTransferParameters *const*)ptr, "ns1:TTransferParameters");
	case SOAP_TYPE_PointerTons1__ArrayOfUnsignedLong:
		return soap_out_PointerTons1__ArrayOfUnsignedLong(soap, tag, id, (struct ns1__ArrayOfUnsignedLong *const*)ptr, "ns1:ArrayOfUnsignedLong");
	case SOAP_TYPE_PointerTons1__TSupportedTransferProtocol:
		return soap_out_PointerTons1__TSupportedTransferProtocol(soap, tag, id, (struct ns1__TSupportedTransferProtocol *const*)ptr, "ns1:TSupportedTransferProtocol");
	case SOAP_TYPE_PointerTons1__TRequestTokenReturn:
		return soap_out_PointerTons1__TRequestTokenReturn(soap, tag, id, (struct ns1__TRequestTokenReturn *const*)ptr, "ns1:TRequestTokenReturn");
	case SOAP_TYPE_PointerTons1__TPermissionReturn:
		return soap_out_PointerTons1__TPermissionReturn(soap, tag, id, (struct ns1__TPermissionReturn *const*)ptr, "ns1:TPermissionReturn");
	case SOAP_TYPE_PointerTons1__ArrayOfTGroupPermission:
		return soap_out_PointerTons1__ArrayOfTGroupPermission(soap, tag, id, (struct ns1__ArrayOfTGroupPermission *const*)ptr, "ns1:ArrayOfTGroupPermission");
	case SOAP_TYPE_PointerTons1__ArrayOfTUserPermission:
		return soap_out_PointerTons1__ArrayOfTUserPermission(soap, tag, id, (struct ns1__ArrayOfTUserPermission *const*)ptr, "ns1:ArrayOfTUserPermission");
	case SOAP_TYPE_PointerTons1__TSURLPermissionReturn:
		return soap_out_PointerTons1__TSURLPermissionReturn(soap, tag, id, (struct ns1__TSURLPermissionReturn *const*)ptr, "ns1:TSURLPermissionReturn");
	case SOAP_TYPE_PointerTons1__TRequestSummary:
		return soap_out_PointerTons1__TRequestSummary(soap, tag, id, (struct ns1__TRequestSummary *const*)ptr, "ns1:TRequestSummary");
	case SOAP_TYPE_PointerTons1__TRequestType:
		return soap_out_PointerTons1__TRequestType(soap, tag, id, (enum ns1__TRequestType *const*)ptr, "ns1:TRequestType");
	case SOAP_TYPE_PointerTons1__TCopyRequestFileStatus:
		return soap_out_PointerTons1__TCopyRequestFileStatus(soap, tag, id, (struct ns1__TCopyRequestFileStatus *const*)ptr, "ns1:TCopyRequestFileStatus");
	case SOAP_TYPE_PointerTons1__TPutRequestFileStatus:
		return soap_out_PointerTons1__TPutRequestFileStatus(soap, tag, id, (struct ns1__TPutRequestFileStatus *const*)ptr, "ns1:TPutRequestFileStatus");
	case SOAP_TYPE_PointerTons1__TBringOnlineRequestFileStatus:
		return soap_out_PointerTons1__TBringOnlineRequestFileStatus(soap, tag, id, (struct ns1__TBringOnlineRequestFileStatus *const*)ptr, "ns1:TBringOnlineRequestFileStatus");
	case SOAP_TYPE_PointerTons1__TGetRequestFileStatus:
		return soap_out_PointerTons1__TGetRequestFileStatus(soap, tag, id, (struct ns1__TGetRequestFileStatus *const*)ptr, "ns1:TGetRequestFileStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfTExtraInfo:
		return soap_out_PointerTons1__ArrayOfTExtraInfo(soap, tag, id, (struct ns1__ArrayOfTExtraInfo *const*)ptr, "ns1:ArrayOfTExtraInfo");
	case SOAP_TYPE_PointerTons1__TCopyFileRequest:
		return soap_out_PointerTons1__TCopyFileRequest(soap, tag, id, (struct ns1__TCopyFileRequest *const*)ptr, "ns1:TCopyFileRequest");
	case SOAP_TYPE_PointerTons1__TPutFileRequest:
		return soap_out_PointerTons1__TPutFileRequest(soap, tag, id, (struct ns1__TPutFileRequest *const*)ptr, "ns1:TPutFileRequest");
	case SOAP_TYPE_PointerTons1__TGetFileRequest:
		return soap_out_PointerTons1__TGetFileRequest(soap, tag, id, (struct ns1__TGetFileRequest *const*)ptr, "ns1:TGetFileRequest");
	case SOAP_TYPE_PointerTons1__TDirOption:
		return soap_out_PointerTons1__TDirOption(soap, tag, id, (struct ns1__TDirOption *const*)ptr, "ns1:TDirOption");
	case SOAP_TYPE_PointerTons1__TConnectionType:
		return soap_out_PointerTons1__TConnectionType(soap, tag, id, (enum ns1__TConnectionType *const*)ptr, "ns1:TConnectionType");
	case SOAP_TYPE_PointerTons1__TAccessPattern:
		return soap_out_PointerTons1__TAccessPattern(soap, tag, id, (enum ns1__TAccessPattern *const*)ptr, "ns1:TAccessPattern");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (char **const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTons1__TExtraInfo:
		return soap_out_PointerTons1__TExtraInfo(soap, tag, id, (struct ns1__TExtraInfo *const*)ptr, "ns1:TExtraInfo");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons1__TMetaDataSpace:
		return soap_out_PointerTons1__TMetaDataSpace(soap, tag, id, (struct ns1__TMetaDataSpace *const*)ptr, "ns1:TMetaDataSpace");
	case SOAP_TYPE_PointerTons1__TMetaDataPathDetail:
		return soap_out_PointerTons1__TMetaDataPathDetail(soap, tag, id, (struct ns1__TMetaDataPathDetail *const*)ptr, "ns1:TMetaDataPathDetail");
	case SOAP_TYPE_PointerTons1__ArrayOfTMetaDataPathDetail:
		return soap_out_PointerTons1__ArrayOfTMetaDataPathDetail(soap, tag, id, (struct ns1__ArrayOfTMetaDataPathDetail *const*)ptr, "ns1:ArrayOfTMetaDataPathDetail");
	case SOAP_TYPE_PointerTons1__TPermissionMode:
		return soap_out_PointerTons1__TPermissionMode(soap, tag, id, (enum ns1__TPermissionMode *const*)ptr, "ns1:TPermissionMode");
	case SOAP_TYPE_PointerTons1__TFileType:
		return soap_out_PointerTons1__TFileType(soap, tag, id, (enum ns1__TFileType *const*)ptr, "ns1:TFileType");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_out_PointerTons1__ArrayOfString(soap, tag, id, (struct ns1__ArrayOfString *const*)ptr, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons1__TFileLocality:
		return soap_out_PointerTons1__TFileLocality(soap, tag, id, (enum ns1__TFileLocality *const*)ptr, "ns1:TFileLocality");
	case SOAP_TYPE_PointerTons1__TRetentionPolicyInfo:
		return soap_out_PointerTons1__TRetentionPolicyInfo(soap, tag, id, (struct ns1__TRetentionPolicyInfo *const*)ptr, "ns1:TRetentionPolicyInfo");
	case SOAP_TYPE_PointerTons1__TFileStorageType:
		return soap_out_PointerTons1__TFileStorageType(soap, tag, id, (enum ns1__TFileStorageType *const*)ptr, "ns1:TFileStorageType");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__TSURLLifetimeReturnStatus:
		return soap_out_PointerTons1__TSURLLifetimeReturnStatus(soap, tag, id, (struct ns1__TSURLLifetimeReturnStatus *const*)ptr, "ns1:TSURLLifetimeReturnStatus");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons1__TSURLReturnStatus:
		return soap_out_PointerTons1__TSURLReturnStatus(soap, tag, id, (struct ns1__TSURLReturnStatus *const*)ptr, "ns1:TSURLReturnStatus");
	case SOAP_TYPE_PointerTons1__TReturnStatus:
		return soap_out_PointerTons1__TReturnStatus(soap, tag, id, (struct ns1__TReturnStatus *const*)ptr, "ns1:TReturnStatus");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTounsignedLONG64:
		return soap_out_PointerTounsignedLONG64(soap, tag, id, (ULONG64 *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTons1__TGroupPermission:
		return soap_out_PointerTons1__TGroupPermission(soap, tag, id, (struct ns1__TGroupPermission *const*)ptr, "ns1:TGroupPermission");
	case SOAP_TYPE_PointerTons1__TUserPermission:
		return soap_out_PointerTons1__TUserPermission(soap, tag, id, (struct ns1__TUserPermission *const*)ptr, "ns1:TUserPermission");
	case SOAP_TYPE_PointerTons1__TAccessLatency:
		return soap_out_PointerTons1__TAccessLatency(soap, tag, id, (enum ns1__TAccessLatency *const*)ptr, "ns1:TAccessLatency");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:anyURI");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__srmPing:
		soap_serialize_ns1__srmPing(soap, (const struct ns1__srmPing *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPingResponse_:
		soap_serialize_ns1__srmPingResponse_(soap, (const struct ns1__srmPingResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetTransferProtocols:
		soap_serialize_ns1__srmGetTransferProtocols(soap, (const struct ns1__srmGetTransferProtocols *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetTransferProtocolsResponse_:
		soap_serialize_ns1__srmGetTransferProtocolsResponse_(soap, (const struct ns1__srmGetTransferProtocolsResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetRequestTokens:
		soap_serialize_ns1__srmGetRequestTokens(soap, (const struct ns1__srmGetRequestTokens *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetRequestTokensResponse_:
		soap_serialize_ns1__srmGetRequestTokensResponse_(soap, (const struct ns1__srmGetRequestTokensResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmExtendFileLifeTime:
		soap_serialize_ns1__srmExtendFileLifeTime(soap, (const struct ns1__srmExtendFileLifeTime *)ptr);
		break;
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse_:
		soap_serialize_ns1__srmExtendFileLifeTimeResponse_(soap, (const struct ns1__srmExtendFileLifeTimeResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetRequestSummary:
		soap_serialize_ns1__srmGetRequestSummary(soap, (const struct ns1__srmGetRequestSummary *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetRequestSummaryResponse_:
		soap_serialize_ns1__srmGetRequestSummaryResponse_(soap, (const struct ns1__srmGetRequestSummaryResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmResumeRequest:
		soap_serialize_ns1__srmResumeRequest(soap, (const struct ns1__srmResumeRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmResumeRequestResponse_:
		soap_serialize_ns1__srmResumeRequestResponse_(soap, (const struct ns1__srmResumeRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmSuspendRequest:
		soap_serialize_ns1__srmSuspendRequest(soap, (const struct ns1__srmSuspendRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmSuspendRequestResponse_:
		soap_serialize_ns1__srmSuspendRequestResponse_(soap, (const struct ns1__srmSuspendRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmAbortFiles:
		soap_serialize_ns1__srmAbortFiles(soap, (const struct ns1__srmAbortFiles *)ptr);
		break;
	case SOAP_TYPE_ns1__srmAbortFilesResponse_:
		soap_serialize_ns1__srmAbortFilesResponse_(soap, (const struct ns1__srmAbortFilesResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmAbortRequest:
		soap_serialize_ns1__srmAbortRequest(soap, (const struct ns1__srmAbortRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmAbortRequestResponse_:
		soap_serialize_ns1__srmAbortRequestResponse_(soap, (const struct ns1__srmAbortRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPutDone:
		soap_serialize_ns1__srmPutDone(soap, (const struct ns1__srmPutDone *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPutDoneResponse_:
		soap_serialize_ns1__srmPutDoneResponse_(soap, (const struct ns1__srmPutDoneResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmReleaseFiles:
		soap_serialize_ns1__srmReleaseFiles(soap, (const struct ns1__srmReleaseFiles *)ptr);
		break;
	case SOAP_TYPE_ns1__srmReleaseFilesResponse_:
		soap_serialize_ns1__srmReleaseFilesResponse_(soap, (const struct ns1__srmReleaseFilesResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfCopyRequest:
		soap_serialize_ns1__srmStatusOfCopyRequest(soap, (const struct ns1__srmStatusOfCopyRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse_:
		soap_serialize_ns1__srmStatusOfCopyRequestResponse_(soap, (const struct ns1__srmStatusOfCopyRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmCopy:
		soap_serialize_ns1__srmCopy(soap, (const struct ns1__srmCopy *)ptr);
		break;
	case SOAP_TYPE_ns1__srmCopyResponse_:
		soap_serialize_ns1__srmCopyResponse_(soap, (const struct ns1__srmCopyResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfPutRequest:
		soap_serialize_ns1__srmStatusOfPutRequest(soap, (const struct ns1__srmStatusOfPutRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfPutRequestResponse_:
		soap_serialize_ns1__srmStatusOfPutRequestResponse_(soap, (const struct ns1__srmStatusOfPutRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPrepareToPut:
		soap_serialize_ns1__srmPrepareToPut(soap, (const struct ns1__srmPrepareToPut *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPrepareToPutResponse_:
		soap_serialize_ns1__srmPrepareToPutResponse_(soap, (const struct ns1__srmPrepareToPutResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfBringOnlineRequest:
		soap_serialize_ns1__srmStatusOfBringOnlineRequest(soap, (const struct ns1__srmStatusOfBringOnlineRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse_:
		soap_serialize_ns1__srmStatusOfBringOnlineRequestResponse_(soap, (const struct ns1__srmStatusOfBringOnlineRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmBringOnline:
		soap_serialize_ns1__srmBringOnline(soap, (const struct ns1__srmBringOnline *)ptr);
		break;
	case SOAP_TYPE_ns1__srmBringOnlineResponse_:
		soap_serialize_ns1__srmBringOnlineResponse_(soap, (const struct ns1__srmBringOnlineResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfGetRequest:
		soap_serialize_ns1__srmStatusOfGetRequest(soap, (const struct ns1__srmStatusOfGetRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfGetRequestResponse_:
		soap_serialize_ns1__srmStatusOfGetRequestResponse_(soap, (const struct ns1__srmStatusOfGetRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPrepareToGet:
		soap_serialize_ns1__srmPrepareToGet(soap, (const struct ns1__srmPrepareToGet *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPrepareToGetResponse_:
		soap_serialize_ns1__srmPrepareToGetResponse_(soap, (const struct ns1__srmPrepareToGetResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmMv:
		soap_serialize_ns1__srmMv(soap, (const struct ns1__srmMv *)ptr);
		break;
	case SOAP_TYPE_ns1__srmMvResponse_:
		soap_serialize_ns1__srmMvResponse_(soap, (const struct ns1__srmMvResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfLsRequest:
		soap_serialize_ns1__srmStatusOfLsRequest(soap, (const struct ns1__srmStatusOfLsRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfLsRequestResponse_:
		soap_serialize_ns1__srmStatusOfLsRequestResponse_(soap, (const struct ns1__srmStatusOfLsRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmLs:
		soap_serialize_ns1__srmLs(soap, (const struct ns1__srmLs *)ptr);
		break;
	case SOAP_TYPE_ns1__srmLsResponse_:
		soap_serialize_ns1__srmLsResponse_(soap, (const struct ns1__srmLsResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmRm:
		soap_serialize_ns1__srmRm(soap, (const struct ns1__srmRm *)ptr);
		break;
	case SOAP_TYPE_ns1__srmRmResponse_:
		soap_serialize_ns1__srmRmResponse_(soap, (const struct ns1__srmRmResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmRmdir:
		soap_serialize_ns1__srmRmdir(soap, (const struct ns1__srmRmdir *)ptr);
		break;
	case SOAP_TYPE_ns1__srmRmdirResponse_:
		soap_serialize_ns1__srmRmdirResponse_(soap, (const struct ns1__srmRmdirResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmMkdir:
		soap_serialize_ns1__srmMkdir(soap, (const struct ns1__srmMkdir *)ptr);
		break;
	case SOAP_TYPE_ns1__srmMkdirResponse_:
		soap_serialize_ns1__srmMkdirResponse_(soap, (const struct ns1__srmMkdirResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetPermission:
		soap_serialize_ns1__srmGetPermission(soap, (const struct ns1__srmGetPermission *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetPermissionResponse_:
		soap_serialize_ns1__srmGetPermissionResponse_(soap, (const struct ns1__srmGetPermissionResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmCheckPermission:
		soap_serialize_ns1__srmCheckPermission(soap, (const struct ns1__srmCheckPermission *)ptr);
		break;
	case SOAP_TYPE_ns1__srmCheckPermissionResponse_:
		soap_serialize_ns1__srmCheckPermissionResponse_(soap, (const struct ns1__srmCheckPermissionResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmSetPermission:
		soap_serialize_ns1__srmSetPermission(soap, (const struct ns1__srmSetPermission *)ptr);
		break;
	case SOAP_TYPE_ns1__srmSetPermissionResponse_:
		soap_serialize_ns1__srmSetPermissionResponse_(soap, (const struct ns1__srmSetPermissionResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetSpaceTokens:
		soap_serialize_ns1__srmGetSpaceTokens(soap, (const struct ns1__srmGetSpaceTokens *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetSpaceTokensResponse_:
		soap_serialize_ns1__srmGetSpaceTokensResponse_(soap, (const struct ns1__srmGetSpaceTokensResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPurgeFromSpace:
		soap_serialize_ns1__srmPurgeFromSpace(soap, (const struct ns1__srmPurgeFromSpace *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPurgeFromSpaceResponse_:
		soap_serialize_ns1__srmPurgeFromSpaceResponse_(soap, (const struct ns1__srmPurgeFromSpaceResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpace:
		soap_serialize_ns1__srmExtendFileLifeTimeInSpace(soap, (const struct ns1__srmExtendFileLifeTimeInSpace *)ptr);
		break;
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse_:
		soap_serialize_ns1__srmExtendFileLifeTimeInSpaceResponse_(soap, (const struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequest:
		soap_serialize_ns1__srmStatusOfChangeSpaceForFilesRequest(soap, (const struct ns1__srmStatusOfChangeSpaceForFilesRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_:
		soap_serialize_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, (const struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmChangeSpaceForFiles:
		soap_serialize_ns1__srmChangeSpaceForFiles(soap, (const struct ns1__srmChangeSpaceForFiles *)ptr);
		break;
	case SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse_:
		soap_serialize_ns1__srmChangeSpaceForFilesResponse_(soap, (const struct ns1__srmChangeSpaceForFilesResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetSpaceMetaData:
		soap_serialize_ns1__srmGetSpaceMetaData(soap, (const struct ns1__srmGetSpaceMetaData *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse_:
		soap_serialize_ns1__srmGetSpaceMetaDataResponse_(soap, (const struct ns1__srmGetSpaceMetaDataResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequest:
		soap_serialize_ns1__srmStatusOfUpdateSpaceRequest(soap, (const struct ns1__srmStatusOfUpdateSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse_:
		soap_serialize_ns1__srmStatusOfUpdateSpaceRequestResponse_(soap, (const struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmUpdateSpace:
		soap_serialize_ns1__srmUpdateSpace(soap, (const struct ns1__srmUpdateSpace *)ptr);
		break;
	case SOAP_TYPE_ns1__srmUpdateSpaceResponse_:
		soap_serialize_ns1__srmUpdateSpaceResponse_(soap, (const struct ns1__srmUpdateSpaceResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmReleaseSpace:
		soap_serialize_ns1__srmReleaseSpace(soap, (const struct ns1__srmReleaseSpace *)ptr);
		break;
	case SOAP_TYPE_ns1__srmReleaseSpaceResponse_:
		soap_serialize_ns1__srmReleaseSpaceResponse_(soap, (const struct ns1__srmReleaseSpaceResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequest:
		soap_serialize_ns1__srmStatusOfReserveSpaceRequest(soap, (const struct ns1__srmStatusOfReserveSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse_:
		soap_serialize_ns1__srmStatusOfReserveSpaceRequestResponse_(soap, (const struct ns1__srmStatusOfReserveSpaceRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmReserveSpace:
		soap_serialize_ns1__srmReserveSpace(soap, (const struct ns1__srmReserveSpace *)ptr);
		break;
	case SOAP_TYPE_ns1__srmReserveSpaceResponse_:
		soap_serialize_ns1__srmReserveSpaceResponse_(soap, (const struct ns1__srmReserveSpaceResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPingResponse:
		soap_serialize_ns1__srmPingResponse(soap, (const struct ns1__srmPingResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPingRequest:
		soap_serialize_ns1__srmPingRequest(soap, (const struct ns1__srmPingRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetTransferProtocolsResponse:
		soap_serialize_ns1__srmGetTransferProtocolsResponse(soap, (const struct ns1__srmGetTransferProtocolsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetTransferProtocolsRequest:
		soap_serialize_ns1__srmGetTransferProtocolsRequest(soap, (const struct ns1__srmGetTransferProtocolsRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetRequestTokensResponse:
		soap_serialize_ns1__srmGetRequestTokensResponse(soap, (const struct ns1__srmGetRequestTokensResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetRequestTokensRequest:
		soap_serialize_ns1__srmGetRequestTokensRequest(soap, (const struct ns1__srmGetRequestTokensRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse:
		soap_serialize_ns1__srmExtendFileLifeTimeResponse(soap, (const struct ns1__srmExtendFileLifeTimeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeRequest:
		soap_serialize_ns1__srmExtendFileLifeTimeRequest(soap, (const struct ns1__srmExtendFileLifeTimeRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetRequestSummaryResponse:
		soap_serialize_ns1__srmGetRequestSummaryResponse(soap, (const struct ns1__srmGetRequestSummaryResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetRequestSummaryRequest:
		soap_serialize_ns1__srmGetRequestSummaryRequest(soap, (const struct ns1__srmGetRequestSummaryRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmResumeRequestResponse:
		soap_serialize_ns1__srmResumeRequestResponse(soap, (const struct ns1__srmResumeRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmResumeRequestRequest:
		soap_serialize_ns1__srmResumeRequestRequest(soap, (const struct ns1__srmResumeRequestRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmSuspendRequestResponse:
		soap_serialize_ns1__srmSuspendRequestResponse(soap, (const struct ns1__srmSuspendRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmSuspendRequestRequest:
		soap_serialize_ns1__srmSuspendRequestRequest(soap, (const struct ns1__srmSuspendRequestRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmAbortFilesResponse:
		soap_serialize_ns1__srmAbortFilesResponse(soap, (const struct ns1__srmAbortFilesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmAbortFilesRequest:
		soap_serialize_ns1__srmAbortFilesRequest(soap, (const struct ns1__srmAbortFilesRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmAbortRequestResponse:
		soap_serialize_ns1__srmAbortRequestResponse(soap, (const struct ns1__srmAbortRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmAbortRequestRequest:
		soap_serialize_ns1__srmAbortRequestRequest(soap, (const struct ns1__srmAbortRequestRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPutDoneResponse:
		soap_serialize_ns1__srmPutDoneResponse(soap, (const struct ns1__srmPutDoneResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPutDoneRequest:
		soap_serialize_ns1__srmPutDoneRequest(soap, (const struct ns1__srmPutDoneRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmReleaseFilesResponse:
		soap_serialize_ns1__srmReleaseFilesResponse(soap, (const struct ns1__srmReleaseFilesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmReleaseFilesRequest:
		soap_serialize_ns1__srmReleaseFilesRequest(soap, (const struct ns1__srmReleaseFilesRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse:
		soap_serialize_ns1__srmStatusOfCopyRequestResponse(soap, (const struct ns1__srmStatusOfCopyRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfCopyRequestRequest:
		soap_serialize_ns1__srmStatusOfCopyRequestRequest(soap, (const struct ns1__srmStatusOfCopyRequestRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmCopyResponse:
		soap_serialize_ns1__srmCopyResponse(soap, (const struct ns1__srmCopyResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmCopyRequest:
		soap_serialize_ns1__srmCopyRequest(soap, (const struct ns1__srmCopyRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfPutRequestResponse:
		soap_serialize_ns1__srmStatusOfPutRequestResponse(soap, (const struct ns1__srmStatusOfPutRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfPutRequestRequest:
		soap_serialize_ns1__srmStatusOfPutRequestRequest(soap, (const struct ns1__srmStatusOfPutRequestRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPrepareToPutResponse:
		soap_serialize_ns1__srmPrepareToPutResponse(soap, (const struct ns1__srmPrepareToPutResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPrepareToPutRequest:
		soap_serialize_ns1__srmPrepareToPutRequest(soap, (const struct ns1__srmPrepareToPutRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse:
		soap_serialize_ns1__srmStatusOfBringOnlineRequestResponse(soap, (const struct ns1__srmStatusOfBringOnlineRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestRequest:
		soap_serialize_ns1__srmStatusOfBringOnlineRequestRequest(soap, (const struct ns1__srmStatusOfBringOnlineRequestRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmBringOnlineResponse:
		soap_serialize_ns1__srmBringOnlineResponse(soap, (const struct ns1__srmBringOnlineResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmBringOnlineRequest:
		soap_serialize_ns1__srmBringOnlineRequest(soap, (const struct ns1__srmBringOnlineRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfGetRequestResponse:
		soap_serialize_ns1__srmStatusOfGetRequestResponse(soap, (const struct ns1__srmStatusOfGetRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfGetRequestRequest:
		soap_serialize_ns1__srmStatusOfGetRequestRequest(soap, (const struct ns1__srmStatusOfGetRequestRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPrepareToGetResponse:
		soap_serialize_ns1__srmPrepareToGetResponse(soap, (const struct ns1__srmPrepareToGetResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPrepareToGetRequest:
		soap_serialize_ns1__srmPrepareToGetRequest(soap, (const struct ns1__srmPrepareToGetRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmMvResponse:
		soap_serialize_ns1__srmMvResponse(soap, (const struct ns1__srmMvResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmMvRequest:
		soap_serialize_ns1__srmMvRequest(soap, (const struct ns1__srmMvRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfLsRequestResponse:
		soap_serialize_ns1__srmStatusOfLsRequestResponse(soap, (const struct ns1__srmStatusOfLsRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfLsRequestRequest:
		soap_serialize_ns1__srmStatusOfLsRequestRequest(soap, (const struct ns1__srmStatusOfLsRequestRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmLsResponse:
		soap_serialize_ns1__srmLsResponse(soap, (const struct ns1__srmLsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmLsRequest:
		soap_serialize_ns1__srmLsRequest(soap, (const struct ns1__srmLsRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmRmResponse:
		soap_serialize_ns1__srmRmResponse(soap, (const struct ns1__srmRmResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmRmRequest:
		soap_serialize_ns1__srmRmRequest(soap, (const struct ns1__srmRmRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmRmdirResponse:
		soap_serialize_ns1__srmRmdirResponse(soap, (const struct ns1__srmRmdirResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmRmdirRequest:
		soap_serialize_ns1__srmRmdirRequest(soap, (const struct ns1__srmRmdirRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmMkdirResponse:
		soap_serialize_ns1__srmMkdirResponse(soap, (const struct ns1__srmMkdirResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmMkdirRequest:
		soap_serialize_ns1__srmMkdirRequest(soap, (const struct ns1__srmMkdirRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetPermissionResponse:
		soap_serialize_ns1__srmGetPermissionResponse(soap, (const struct ns1__srmGetPermissionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetPermissionRequest:
		soap_serialize_ns1__srmGetPermissionRequest(soap, (const struct ns1__srmGetPermissionRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmCheckPermissionResponse:
		soap_serialize_ns1__srmCheckPermissionResponse(soap, (const struct ns1__srmCheckPermissionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmCheckPermissionRequest:
		soap_serialize_ns1__srmCheckPermissionRequest(soap, (const struct ns1__srmCheckPermissionRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmSetPermissionResponse:
		soap_serialize_ns1__srmSetPermissionResponse(soap, (const struct ns1__srmSetPermissionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmSetPermissionRequest:
		soap_serialize_ns1__srmSetPermissionRequest(soap, (const struct ns1__srmSetPermissionRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetSpaceTokensResponse:
		soap_serialize_ns1__srmGetSpaceTokensResponse(soap, (const struct ns1__srmGetSpaceTokensResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetSpaceTokensRequest:
		soap_serialize_ns1__srmGetSpaceTokensRequest(soap, (const struct ns1__srmGetSpaceTokensRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPurgeFromSpaceResponse:
		soap_serialize_ns1__srmPurgeFromSpaceResponse(soap, (const struct ns1__srmPurgeFromSpaceResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmPurgeFromSpaceRequest:
		soap_serialize_ns1__srmPurgeFromSpaceRequest(soap, (const struct ns1__srmPurgeFromSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse:
		soap_serialize_ns1__srmExtendFileLifeTimeInSpaceResponse(soap, (const struct ns1__srmExtendFileLifeTimeInSpaceResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceRequest:
		soap_serialize_ns1__srmExtendFileLifeTimeInSpaceRequest(soap, (const struct ns1__srmExtendFileLifeTimeInSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse:
		soap_serialize_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, (const struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestRequest:
		soap_serialize_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, (const struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse:
		soap_serialize_ns1__srmChangeSpaceForFilesResponse(soap, (const struct ns1__srmChangeSpaceForFilesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmChangeSpaceForFilesRequest:
		soap_serialize_ns1__srmChangeSpaceForFilesRequest(soap, (const struct ns1__srmChangeSpaceForFilesRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse:
		soap_serialize_ns1__srmGetSpaceMetaDataResponse(soap, (const struct ns1__srmGetSpaceMetaDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmGetSpaceMetaDataRequest:
		soap_serialize_ns1__srmGetSpaceMetaDataRequest(soap, (const struct ns1__srmGetSpaceMetaDataRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse:
		soap_serialize_ns1__srmStatusOfUpdateSpaceRequestResponse(soap, (const struct ns1__srmStatusOfUpdateSpaceRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestRequest:
		soap_serialize_ns1__srmStatusOfUpdateSpaceRequestRequest(soap, (const struct ns1__srmStatusOfUpdateSpaceRequestRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmUpdateSpaceResponse:
		soap_serialize_ns1__srmUpdateSpaceResponse(soap, (const struct ns1__srmUpdateSpaceResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmUpdateSpaceRequest:
		soap_serialize_ns1__srmUpdateSpaceRequest(soap, (const struct ns1__srmUpdateSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmReleaseSpaceResponse:
		soap_serialize_ns1__srmReleaseSpaceResponse(soap, (const struct ns1__srmReleaseSpaceResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmReleaseSpaceRequest:
		soap_serialize_ns1__srmReleaseSpaceRequest(soap, (const struct ns1__srmReleaseSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse:
		soap_serialize_ns1__srmStatusOfReserveSpaceRequestResponse(soap, (const struct ns1__srmStatusOfReserveSpaceRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestRequest:
		soap_serialize_ns1__srmStatusOfReserveSpaceRequestRequest(soap, (const struct ns1__srmStatusOfReserveSpaceRequestRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__srmReserveSpaceResponse:
		soap_serialize_ns1__srmReserveSpaceResponse(soap, (const struct ns1__srmReserveSpaceResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__srmReserveSpaceRequest:
		soap_serialize_ns1__srmReserveSpaceRequest(soap, (const struct ns1__srmReserveSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTSupportedTransferProtocol:
		soap_serialize_ns1__ArrayOfTSupportedTransferProtocol(soap, (const struct ns1__ArrayOfTSupportedTransferProtocol *)ptr);
		break;
	case SOAP_TYPE_ns1__TSupportedTransferProtocol:
		soap_serialize_ns1__TSupportedTransferProtocol(soap, (const struct ns1__TSupportedTransferProtocol *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTRequestTokenReturn:
		soap_serialize_ns1__ArrayOfTRequestTokenReturn(soap, (const struct ns1__ArrayOfTRequestTokenReturn *)ptr);
		break;
	case SOAP_TYPE_ns1__TRequestTokenReturn:
		soap_serialize_ns1__TRequestTokenReturn(soap, (const struct ns1__TRequestTokenReturn *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTPermissionReturn:
		soap_serialize_ns1__ArrayOfTPermissionReturn(soap, (const struct ns1__ArrayOfTPermissionReturn *)ptr);
		break;
	case SOAP_TYPE_ns1__TPermissionReturn:
		soap_serialize_ns1__TPermissionReturn(soap, (const struct ns1__TPermissionReturn *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTSURLPermissionReturn:
		soap_serialize_ns1__ArrayOfTSURLPermissionReturn(soap, (const struct ns1__ArrayOfTSURLPermissionReturn *)ptr);
		break;
	case SOAP_TYPE_ns1__TSURLPermissionReturn:
		soap_serialize_ns1__TSURLPermissionReturn(soap, (const struct ns1__TSURLPermissionReturn *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTRequestSummary:
		soap_serialize_ns1__ArrayOfTRequestSummary(soap, (const struct ns1__ArrayOfTRequestSummary *)ptr);
		break;
	case SOAP_TYPE_ns1__TRequestSummary:
		soap_serialize_ns1__TRequestSummary(soap, (const struct ns1__TRequestSummary *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTCopyRequestFileStatus:
		soap_serialize_ns1__ArrayOfTCopyRequestFileStatus(soap, (const struct ns1__ArrayOfTCopyRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__TCopyRequestFileStatus:
		soap_serialize_ns1__TCopyRequestFileStatus(soap, (const struct ns1__TCopyRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTPutRequestFileStatus:
		soap_serialize_ns1__ArrayOfTPutRequestFileStatus(soap, (const struct ns1__ArrayOfTPutRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__TPutRequestFileStatus:
		soap_serialize_ns1__TPutRequestFileStatus(soap, (const struct ns1__TPutRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTBringOnlineRequestFileStatus:
		soap_serialize_ns1__ArrayOfTBringOnlineRequestFileStatus(soap, (const struct ns1__ArrayOfTBringOnlineRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__TBringOnlineRequestFileStatus:
		soap_serialize_ns1__TBringOnlineRequestFileStatus(soap, (const struct ns1__TBringOnlineRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTGetRequestFileStatus:
		soap_serialize_ns1__ArrayOfTGetRequestFileStatus(soap, (const struct ns1__ArrayOfTGetRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__TGetRequestFileStatus:
		soap_serialize_ns1__TGetRequestFileStatus(soap, (const struct ns1__TGetRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTCopyFileRequest:
		soap_serialize_ns1__ArrayOfTCopyFileRequest(soap, (const struct ns1__ArrayOfTCopyFileRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__TCopyFileRequest:
		soap_serialize_ns1__TCopyFileRequest(soap, (const struct ns1__TCopyFileRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTPutFileRequest:
		soap_serialize_ns1__ArrayOfTPutFileRequest(soap, (const struct ns1__ArrayOfTPutFileRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__TPutFileRequest:
		soap_serialize_ns1__TPutFileRequest(soap, (const struct ns1__TPutFileRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTGetFileRequest:
		soap_serialize_ns1__ArrayOfTGetFileRequest(soap, (const struct ns1__ArrayOfTGetFileRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__TGetFileRequest:
		soap_serialize_ns1__TGetFileRequest(soap, (const struct ns1__TGetFileRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__TTransferParameters:
		soap_serialize_ns1__TTransferParameters(soap, (const struct ns1__TTransferParameters *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfAnyURI:
		soap_serialize_ns1__ArrayOfAnyURI(soap, (const struct ns1__ArrayOfAnyURI *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTExtraInfo:
		soap_serialize_ns1__ArrayOfTExtraInfo(soap, (const struct ns1__ArrayOfTExtraInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__TExtraInfo:
		soap_serialize_ns1__TExtraInfo(soap, (const struct ns1__TExtraInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__TDirOption:
		soap_serialize_ns1__TDirOption(soap, (const struct ns1__TDirOption *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTMetaDataSpace:
		soap_serialize_ns1__ArrayOfTMetaDataSpace(soap, (const struct ns1__ArrayOfTMetaDataSpace *)ptr);
		break;
	case SOAP_TYPE_ns1__TMetaDataSpace:
		soap_serialize_ns1__TMetaDataSpace(soap, (const struct ns1__TMetaDataSpace *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTMetaDataPathDetail:
		soap_serialize_ns1__ArrayOfTMetaDataPathDetail(soap, (const struct ns1__ArrayOfTMetaDataPathDetail *)ptr);
		break;
	case SOAP_TYPE_ns1__TMetaDataPathDetail:
		soap_serialize_ns1__TMetaDataPathDetail(soap, (const struct ns1__TMetaDataPathDetail *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTSURLLifetimeReturnStatus:
		soap_serialize_ns1__ArrayOfTSURLLifetimeReturnStatus(soap, (const struct ns1__ArrayOfTSURLLifetimeReturnStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__TSURLLifetimeReturnStatus:
		soap_serialize_ns1__TSURLLifetimeReturnStatus(soap, (const struct ns1__TSURLLifetimeReturnStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTSURLReturnStatus:
		soap_serialize_ns1__ArrayOfTSURLReturnStatus(soap, (const struct ns1__ArrayOfTSURLReturnStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__TSURLReturnStatus:
		soap_serialize_ns1__TSURLReturnStatus(soap, (const struct ns1__TSURLReturnStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__TReturnStatus:
		soap_serialize_ns1__TReturnStatus(soap, (const struct ns1__TReturnStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		soap_serialize_ns1__ArrayOfString(soap, (const struct ns1__ArrayOfString *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfUnsignedLong:
		soap_serialize_ns1__ArrayOfUnsignedLong(soap, (const struct ns1__ArrayOfUnsignedLong *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTGroupPermission:
		soap_serialize_ns1__ArrayOfTGroupPermission(soap, (const struct ns1__ArrayOfTGroupPermission *)ptr);
		break;
	case SOAP_TYPE_ns1__TGroupPermission:
		soap_serialize_ns1__TGroupPermission(soap, (const struct ns1__TGroupPermission *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTUserPermission:
		soap_serialize_ns1__ArrayOfTUserPermission(soap, (const struct ns1__ArrayOfTUserPermission *)ptr);
		break;
	case SOAP_TYPE_ns1__TUserPermission:
		soap_serialize_ns1__TUserPermission(soap, (const struct ns1__TUserPermission *)ptr);
		break;
	case SOAP_TYPE_ns1__TRetentionPolicyInfo:
		soap_serialize_ns1__TRetentionPolicyInfo(soap, (const struct ns1__TRetentionPolicyInfo *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPingResponse_:
		soap_serialize_PointerTons1__srmPingResponse_(soap, (struct ns1__srmPingResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPingRequest:
		soap_serialize_PointerTons1__srmPingRequest(soap, (struct ns1__srmPingRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPingResponse:
		soap_serialize_PointerTons1__srmPingResponse(soap, (struct ns1__srmPingResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetTransferProtocolsResponse_:
		soap_serialize_PointerTons1__srmGetTransferProtocolsResponse_(soap, (struct ns1__srmGetTransferProtocolsResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetTransferProtocolsRequest:
		soap_serialize_PointerTons1__srmGetTransferProtocolsRequest(soap, (struct ns1__srmGetTransferProtocolsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetTransferProtocolsResponse:
		soap_serialize_PointerTons1__srmGetTransferProtocolsResponse(soap, (struct ns1__srmGetTransferProtocolsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetRequestTokensResponse_:
		soap_serialize_PointerTons1__srmGetRequestTokensResponse_(soap, (struct ns1__srmGetRequestTokensResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetRequestTokensRequest:
		soap_serialize_PointerTons1__srmGetRequestTokensRequest(soap, (struct ns1__srmGetRequestTokensRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetRequestTokensResponse:
		soap_serialize_PointerTons1__srmGetRequestTokensResponse(soap, (struct ns1__srmGetRequestTokensResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeResponse_:
		soap_serialize_PointerTons1__srmExtendFileLifeTimeResponse_(soap, (struct ns1__srmExtendFileLifeTimeResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeRequest:
		soap_serialize_PointerTons1__srmExtendFileLifeTimeRequest(soap, (struct ns1__srmExtendFileLifeTimeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeResponse:
		soap_serialize_PointerTons1__srmExtendFileLifeTimeResponse(soap, (struct ns1__srmExtendFileLifeTimeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetRequestSummaryResponse_:
		soap_serialize_PointerTons1__srmGetRequestSummaryResponse_(soap, (struct ns1__srmGetRequestSummaryResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetRequestSummaryRequest:
		soap_serialize_PointerTons1__srmGetRequestSummaryRequest(soap, (struct ns1__srmGetRequestSummaryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetRequestSummaryResponse:
		soap_serialize_PointerTons1__srmGetRequestSummaryResponse(soap, (struct ns1__srmGetRequestSummaryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmResumeRequestResponse_:
		soap_serialize_PointerTons1__srmResumeRequestResponse_(soap, (struct ns1__srmResumeRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmResumeRequestRequest:
		soap_serialize_PointerTons1__srmResumeRequestRequest(soap, (struct ns1__srmResumeRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmResumeRequestResponse:
		soap_serialize_PointerTons1__srmResumeRequestResponse(soap, (struct ns1__srmResumeRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmSuspendRequestResponse_:
		soap_serialize_PointerTons1__srmSuspendRequestResponse_(soap, (struct ns1__srmSuspendRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmSuspendRequestRequest:
		soap_serialize_PointerTons1__srmSuspendRequestRequest(soap, (struct ns1__srmSuspendRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmSuspendRequestResponse:
		soap_serialize_PointerTons1__srmSuspendRequestResponse(soap, (struct ns1__srmSuspendRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmAbortFilesResponse_:
		soap_serialize_PointerTons1__srmAbortFilesResponse_(soap, (struct ns1__srmAbortFilesResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmAbortFilesRequest:
		soap_serialize_PointerTons1__srmAbortFilesRequest(soap, (struct ns1__srmAbortFilesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmAbortFilesResponse:
		soap_serialize_PointerTons1__srmAbortFilesResponse(soap, (struct ns1__srmAbortFilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmAbortRequestResponse_:
		soap_serialize_PointerTons1__srmAbortRequestResponse_(soap, (struct ns1__srmAbortRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmAbortRequestRequest:
		soap_serialize_PointerTons1__srmAbortRequestRequest(soap, (struct ns1__srmAbortRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmAbortRequestResponse:
		soap_serialize_PointerTons1__srmAbortRequestResponse(soap, (struct ns1__srmAbortRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPutDoneResponse_:
		soap_serialize_PointerTons1__srmPutDoneResponse_(soap, (struct ns1__srmPutDoneResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPutDoneRequest:
		soap_serialize_PointerTons1__srmPutDoneRequest(soap, (struct ns1__srmPutDoneRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPutDoneResponse:
		soap_serialize_PointerTons1__srmPutDoneResponse(soap, (struct ns1__srmPutDoneResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmReleaseFilesResponse_:
		soap_serialize_PointerTons1__srmReleaseFilesResponse_(soap, (struct ns1__srmReleaseFilesResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmReleaseFilesRequest:
		soap_serialize_PointerTons1__srmReleaseFilesRequest(soap, (struct ns1__srmReleaseFilesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmReleaseFilesResponse:
		soap_serialize_PointerTons1__srmReleaseFilesResponse(soap, (struct ns1__srmReleaseFilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfCopyRequestResponse_:
		soap_serialize_PointerTons1__srmStatusOfCopyRequestResponse_(soap, (struct ns1__srmStatusOfCopyRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfCopyRequestRequest:
		soap_serialize_PointerTons1__srmStatusOfCopyRequestRequest(soap, (struct ns1__srmStatusOfCopyRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfCopyRequestResponse:
		soap_serialize_PointerTons1__srmStatusOfCopyRequestResponse(soap, (struct ns1__srmStatusOfCopyRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmCopyResponse_:
		soap_serialize_PointerTons1__srmCopyResponse_(soap, (struct ns1__srmCopyResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmCopyRequest:
		soap_serialize_PointerTons1__srmCopyRequest(soap, (struct ns1__srmCopyRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmCopyResponse:
		soap_serialize_PointerTons1__srmCopyResponse(soap, (struct ns1__srmCopyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfPutRequestResponse_:
		soap_serialize_PointerTons1__srmStatusOfPutRequestResponse_(soap, (struct ns1__srmStatusOfPutRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfPutRequestRequest:
		soap_serialize_PointerTons1__srmStatusOfPutRequestRequest(soap, (struct ns1__srmStatusOfPutRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfPutRequestResponse:
		soap_serialize_PointerTons1__srmStatusOfPutRequestResponse(soap, (struct ns1__srmStatusOfPutRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPrepareToPutResponse_:
		soap_serialize_PointerTons1__srmPrepareToPutResponse_(soap, (struct ns1__srmPrepareToPutResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPrepareToPutRequest:
		soap_serialize_PointerTons1__srmPrepareToPutRequest(soap, (struct ns1__srmPrepareToPutRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPrepareToPutResponse:
		soap_serialize_PointerTons1__srmPrepareToPutResponse(soap, (struct ns1__srmPrepareToPutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfBringOnlineRequestResponse_:
		soap_serialize_PointerTons1__srmStatusOfBringOnlineRequestResponse_(soap, (struct ns1__srmStatusOfBringOnlineRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfBringOnlineRequestRequest:
		soap_serialize_PointerTons1__srmStatusOfBringOnlineRequestRequest(soap, (struct ns1__srmStatusOfBringOnlineRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfBringOnlineRequestResponse:
		soap_serialize_PointerTons1__srmStatusOfBringOnlineRequestResponse(soap, (struct ns1__srmStatusOfBringOnlineRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmBringOnlineResponse_:
		soap_serialize_PointerTons1__srmBringOnlineResponse_(soap, (struct ns1__srmBringOnlineResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmBringOnlineRequest:
		soap_serialize_PointerTons1__srmBringOnlineRequest(soap, (struct ns1__srmBringOnlineRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmBringOnlineResponse:
		soap_serialize_PointerTons1__srmBringOnlineResponse(soap, (struct ns1__srmBringOnlineResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfGetRequestResponse_:
		soap_serialize_PointerTons1__srmStatusOfGetRequestResponse_(soap, (struct ns1__srmStatusOfGetRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfGetRequestRequest:
		soap_serialize_PointerTons1__srmStatusOfGetRequestRequest(soap, (struct ns1__srmStatusOfGetRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfGetRequestResponse:
		soap_serialize_PointerTons1__srmStatusOfGetRequestResponse(soap, (struct ns1__srmStatusOfGetRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPrepareToGetResponse_:
		soap_serialize_PointerTons1__srmPrepareToGetResponse_(soap, (struct ns1__srmPrepareToGetResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPrepareToGetRequest:
		soap_serialize_PointerTons1__srmPrepareToGetRequest(soap, (struct ns1__srmPrepareToGetRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPrepareToGetResponse:
		soap_serialize_PointerTons1__srmPrepareToGetResponse(soap, (struct ns1__srmPrepareToGetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmMvResponse_:
		soap_serialize_PointerTons1__srmMvResponse_(soap, (struct ns1__srmMvResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmMvRequest:
		soap_serialize_PointerTons1__srmMvRequest(soap, (struct ns1__srmMvRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmMvResponse:
		soap_serialize_PointerTons1__srmMvResponse(soap, (struct ns1__srmMvResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfLsRequestResponse_:
		soap_serialize_PointerTons1__srmStatusOfLsRequestResponse_(soap, (struct ns1__srmStatusOfLsRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfLsRequestRequest:
		soap_serialize_PointerTons1__srmStatusOfLsRequestRequest(soap, (struct ns1__srmStatusOfLsRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfLsRequestResponse:
		soap_serialize_PointerTons1__srmStatusOfLsRequestResponse(soap, (struct ns1__srmStatusOfLsRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmLsResponse_:
		soap_serialize_PointerTons1__srmLsResponse_(soap, (struct ns1__srmLsResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmLsRequest:
		soap_serialize_PointerTons1__srmLsRequest(soap, (struct ns1__srmLsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmLsResponse:
		soap_serialize_PointerTons1__srmLsResponse(soap, (struct ns1__srmLsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmRmResponse_:
		soap_serialize_PointerTons1__srmRmResponse_(soap, (struct ns1__srmRmResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmRmRequest:
		soap_serialize_PointerTons1__srmRmRequest(soap, (struct ns1__srmRmRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmRmResponse:
		soap_serialize_PointerTons1__srmRmResponse(soap, (struct ns1__srmRmResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmRmdirResponse_:
		soap_serialize_PointerTons1__srmRmdirResponse_(soap, (struct ns1__srmRmdirResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmRmdirRequest:
		soap_serialize_PointerTons1__srmRmdirRequest(soap, (struct ns1__srmRmdirRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmRmdirResponse:
		soap_serialize_PointerTons1__srmRmdirResponse(soap, (struct ns1__srmRmdirResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmMkdirResponse_:
		soap_serialize_PointerTons1__srmMkdirResponse_(soap, (struct ns1__srmMkdirResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmMkdirRequest:
		soap_serialize_PointerTons1__srmMkdirRequest(soap, (struct ns1__srmMkdirRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmMkdirResponse:
		soap_serialize_PointerTons1__srmMkdirResponse(soap, (struct ns1__srmMkdirResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetPermissionResponse_:
		soap_serialize_PointerTons1__srmGetPermissionResponse_(soap, (struct ns1__srmGetPermissionResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetPermissionRequest:
		soap_serialize_PointerTons1__srmGetPermissionRequest(soap, (struct ns1__srmGetPermissionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetPermissionResponse:
		soap_serialize_PointerTons1__srmGetPermissionResponse(soap, (struct ns1__srmGetPermissionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmCheckPermissionResponse_:
		soap_serialize_PointerTons1__srmCheckPermissionResponse_(soap, (struct ns1__srmCheckPermissionResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmCheckPermissionRequest:
		soap_serialize_PointerTons1__srmCheckPermissionRequest(soap, (struct ns1__srmCheckPermissionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmCheckPermissionResponse:
		soap_serialize_PointerTons1__srmCheckPermissionResponse(soap, (struct ns1__srmCheckPermissionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmSetPermissionResponse_:
		soap_serialize_PointerTons1__srmSetPermissionResponse_(soap, (struct ns1__srmSetPermissionResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmSetPermissionRequest:
		soap_serialize_PointerTons1__srmSetPermissionRequest(soap, (struct ns1__srmSetPermissionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmSetPermissionResponse:
		soap_serialize_PointerTons1__srmSetPermissionResponse(soap, (struct ns1__srmSetPermissionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetSpaceTokensResponse_:
		soap_serialize_PointerTons1__srmGetSpaceTokensResponse_(soap, (struct ns1__srmGetSpaceTokensResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetSpaceTokensRequest:
		soap_serialize_PointerTons1__srmGetSpaceTokensRequest(soap, (struct ns1__srmGetSpaceTokensRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetSpaceTokensResponse:
		soap_serialize_PointerTons1__srmGetSpaceTokensResponse(soap, (struct ns1__srmGetSpaceTokensResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPurgeFromSpaceResponse_:
		soap_serialize_PointerTons1__srmPurgeFromSpaceResponse_(soap, (struct ns1__srmPurgeFromSpaceResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPurgeFromSpaceRequest:
		soap_serialize_PointerTons1__srmPurgeFromSpaceRequest(soap, (struct ns1__srmPurgeFromSpaceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmPurgeFromSpaceResponse:
		soap_serialize_PointerTons1__srmPurgeFromSpaceResponse(soap, (struct ns1__srmPurgeFromSpaceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_:
		soap_serialize_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_(soap, (struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeInSpaceRequest:
		soap_serialize_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(soap, (struct ns1__srmExtendFileLifeTimeInSpaceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeInSpaceResponse:
		soap_serialize_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(soap, (struct ns1__srmExtendFileLifeTimeInSpaceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_:
		soap_serialize_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, (struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest:
		soap_serialize_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, (struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse:
		soap_serialize_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, (struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmChangeSpaceForFilesResponse_:
		soap_serialize_PointerTons1__srmChangeSpaceForFilesResponse_(soap, (struct ns1__srmChangeSpaceForFilesResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmChangeSpaceForFilesRequest:
		soap_serialize_PointerTons1__srmChangeSpaceForFilesRequest(soap, (struct ns1__srmChangeSpaceForFilesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmChangeSpaceForFilesResponse:
		soap_serialize_PointerTons1__srmChangeSpaceForFilesResponse(soap, (struct ns1__srmChangeSpaceForFilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetSpaceMetaDataResponse_:
		soap_serialize_PointerTons1__srmGetSpaceMetaDataResponse_(soap, (struct ns1__srmGetSpaceMetaDataResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetSpaceMetaDataRequest:
		soap_serialize_PointerTons1__srmGetSpaceMetaDataRequest(soap, (struct ns1__srmGetSpaceMetaDataRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmGetSpaceMetaDataResponse:
		soap_serialize_PointerTons1__srmGetSpaceMetaDataResponse(soap, (struct ns1__srmGetSpaceMetaDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_:
		soap_serialize_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_(soap, (struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfUpdateSpaceRequestRequest:
		soap_serialize_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(soap, (struct ns1__srmStatusOfUpdateSpaceRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfUpdateSpaceRequestResponse:
		soap_serialize_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(soap, (struct ns1__srmStatusOfUpdateSpaceRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmUpdateSpaceResponse_:
		soap_serialize_PointerTons1__srmUpdateSpaceResponse_(soap, (struct ns1__srmUpdateSpaceResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmUpdateSpaceRequest:
		soap_serialize_PointerTons1__srmUpdateSpaceRequest(soap, (struct ns1__srmUpdateSpaceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmUpdateSpaceResponse:
		soap_serialize_PointerTons1__srmUpdateSpaceResponse(soap, (struct ns1__srmUpdateSpaceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmReleaseSpaceResponse_:
		soap_serialize_PointerTons1__srmReleaseSpaceResponse_(soap, (struct ns1__srmReleaseSpaceResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmReleaseSpaceRequest:
		soap_serialize_PointerTons1__srmReleaseSpaceRequest(soap, (struct ns1__srmReleaseSpaceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmReleaseSpaceResponse:
		soap_serialize_PointerTons1__srmReleaseSpaceResponse(soap, (struct ns1__srmReleaseSpaceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfReserveSpaceRequestResponse_:
		soap_serialize_PointerTons1__srmStatusOfReserveSpaceRequestResponse_(soap, (struct ns1__srmStatusOfReserveSpaceRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfReserveSpaceRequestRequest:
		soap_serialize_PointerTons1__srmStatusOfReserveSpaceRequestRequest(soap, (struct ns1__srmStatusOfReserveSpaceRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmStatusOfReserveSpaceRequestResponse:
		soap_serialize_PointerTons1__srmStatusOfReserveSpaceRequestResponse(soap, (struct ns1__srmStatusOfReserveSpaceRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmReserveSpaceResponse_:
		soap_serialize_PointerTons1__srmReserveSpaceResponse_(soap, (struct ns1__srmReserveSpaceResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmReserveSpaceRequest:
		soap_serialize_PointerTons1__srmReserveSpaceRequest(soap, (struct ns1__srmReserveSpaceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__srmReserveSpaceResponse:
		soap_serialize_PointerTons1__srmReserveSpaceResponse(soap, (struct ns1__srmReserveSpaceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTSupportedTransferProtocol:
		soap_serialize_PointerTons1__ArrayOfTSupportedTransferProtocol(soap, (struct ns1__ArrayOfTSupportedTransferProtocol *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTRequestTokenReturn:
		soap_serialize_PointerTons1__ArrayOfTRequestTokenReturn(soap, (struct ns1__ArrayOfTRequestTokenReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTRequestSummary:
		soap_serialize_PointerTons1__ArrayOfTRequestSummary(soap, (struct ns1__ArrayOfTRequestSummary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTCopyRequestFileStatus:
		soap_serialize_PointerTons1__ArrayOfTCopyRequestFileStatus(soap, (struct ns1__ArrayOfTCopyRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTCopyFileRequest:
		soap_serialize_PointerTons1__ArrayOfTCopyFileRequest(soap, (struct ns1__ArrayOfTCopyFileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTPutRequestFileStatus:
		soap_serialize_PointerTons1__ArrayOfTPutRequestFileStatus(soap, (struct ns1__ArrayOfTPutRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TOverwriteMode:
		soap_serialize_PointerTons1__TOverwriteMode(soap, (enum ns1__TOverwriteMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTPutFileRequest:
		soap_serialize_PointerTons1__ArrayOfTPutFileRequest(soap, (struct ns1__ArrayOfTPutFileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTBringOnlineRequestFileStatus:
		soap_serialize_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(soap, (struct ns1__ArrayOfTBringOnlineRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTGetRequestFileStatus:
		soap_serialize_PointerTons1__ArrayOfTGetRequestFileStatus(soap, (struct ns1__ArrayOfTGetRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTGetFileRequest:
		soap_serialize_PointerTons1__ArrayOfTGetFileRequest(soap, (struct ns1__ArrayOfTGetFileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTPermissionReturn:
		soap_serialize_PointerTons1__ArrayOfTPermissionReturn(soap, (struct ns1__ArrayOfTPermissionReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTSURLPermissionReturn:
		soap_serialize_PointerTons1__ArrayOfTSURLPermissionReturn(soap, (struct ns1__ArrayOfTSURLPermissionReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTSURLLifetimeReturnStatus:
		soap_serialize_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(soap, (struct ns1__ArrayOfTSURLLifetimeReturnStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTSURLReturnStatus:
		soap_serialize_PointerTons1__ArrayOfTSURLReturnStatus(soap, (struct ns1__ArrayOfTSURLReturnStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfAnyURI:
		soap_serialize_PointerTons1__ArrayOfAnyURI(soap, (struct ns1__ArrayOfAnyURI *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTMetaDataSpace:
		soap_serialize_PointerTons1__ArrayOfTMetaDataSpace(soap, (struct ns1__ArrayOfTMetaDataSpace *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TTransferParameters:
		soap_serialize_PointerTons1__TTransferParameters(soap, (struct ns1__TTransferParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfUnsignedLong:
		soap_serialize_PointerTons1__ArrayOfUnsignedLong(soap, (struct ns1__ArrayOfUnsignedLong *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TSupportedTransferProtocol:
		soap_serialize_PointerTons1__TSupportedTransferProtocol(soap, (struct ns1__TSupportedTransferProtocol *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TRequestTokenReturn:
		soap_serialize_PointerTons1__TRequestTokenReturn(soap, (struct ns1__TRequestTokenReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TPermissionReturn:
		soap_serialize_PointerTons1__TPermissionReturn(soap, (struct ns1__TPermissionReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTGroupPermission:
		soap_serialize_PointerTons1__ArrayOfTGroupPermission(soap, (struct ns1__ArrayOfTGroupPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTUserPermission:
		soap_serialize_PointerTons1__ArrayOfTUserPermission(soap, (struct ns1__ArrayOfTUserPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TSURLPermissionReturn:
		soap_serialize_PointerTons1__TSURLPermissionReturn(soap, (struct ns1__TSURLPermissionReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TRequestSummary:
		soap_serialize_PointerTons1__TRequestSummary(soap, (struct ns1__TRequestSummary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TRequestType:
		soap_serialize_PointerTons1__TRequestType(soap, (enum ns1__TRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TCopyRequestFileStatus:
		soap_serialize_PointerTons1__TCopyRequestFileStatus(soap, (struct ns1__TCopyRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TPutRequestFileStatus:
		soap_serialize_PointerTons1__TPutRequestFileStatus(soap, (struct ns1__TPutRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TBringOnlineRequestFileStatus:
		soap_serialize_PointerTons1__TBringOnlineRequestFileStatus(soap, (struct ns1__TBringOnlineRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TGetRequestFileStatus:
		soap_serialize_PointerTons1__TGetRequestFileStatus(soap, (struct ns1__TGetRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTExtraInfo:
		soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, (struct ns1__ArrayOfTExtraInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TCopyFileRequest:
		soap_serialize_PointerTons1__TCopyFileRequest(soap, (struct ns1__TCopyFileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TPutFileRequest:
		soap_serialize_PointerTons1__TPutFileRequest(soap, (struct ns1__TPutFileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TGetFileRequest:
		soap_serialize_PointerTons1__TGetFileRequest(soap, (struct ns1__TGetFileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TDirOption:
		soap_serialize_PointerTons1__TDirOption(soap, (struct ns1__TDirOption *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TConnectionType:
		soap_serialize_PointerTons1__TConnectionType(soap, (enum ns1__TConnectionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TAccessPattern:
		soap_serialize_PointerTons1__TAccessPattern(soap, (enum ns1__TAccessPattern *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TExtraInfo:
		soap_serialize_PointerTons1__TExtraInfo(soap, (struct ns1__TExtraInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TMetaDataSpace:
		soap_serialize_PointerTons1__TMetaDataSpace(soap, (struct ns1__TMetaDataSpace *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TMetaDataPathDetail:
		soap_serialize_PointerTons1__TMetaDataPathDetail(soap, (struct ns1__TMetaDataPathDetail *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTMetaDataPathDetail:
		soap_serialize_PointerTons1__ArrayOfTMetaDataPathDetail(soap, (struct ns1__ArrayOfTMetaDataPathDetail *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TPermissionMode:
		soap_serialize_PointerTons1__TPermissionMode(soap, (enum ns1__TPermissionMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TFileType:
		soap_serialize_PointerTons1__TFileType(soap, (enum ns1__TFileType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		soap_serialize_PointerTons1__ArrayOfString(soap, (struct ns1__ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TFileLocality:
		soap_serialize_PointerTons1__TFileLocality(soap, (enum ns1__TFileLocality *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TRetentionPolicyInfo:
		soap_serialize_PointerTons1__TRetentionPolicyInfo(soap, (struct ns1__TRetentionPolicyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TFileStorageType:
		soap_serialize_PointerTons1__TFileStorageType(soap, (enum ns1__TFileStorageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TSURLLifetimeReturnStatus:
		soap_serialize_PointerTons1__TSURLLifetimeReturnStatus(soap, (struct ns1__TSURLLifetimeReturnStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TSURLReturnStatus:
		soap_serialize_PointerTons1__TSURLReturnStatus(soap, (struct ns1__TSURLReturnStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TReturnStatus:
		soap_serialize_PointerTons1__TReturnStatus(soap, (struct ns1__TReturnStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedLONG64:
		soap_serialize_PointerTounsignedLONG64(soap, (ULONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TGroupPermission:
		soap_serialize_PointerTons1__TGroupPermission(soap, (struct ns1__TGroupPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TUserPermission:
		soap_serialize_PointerTons1__TUserPermission(soap, (struct ns1__TUserPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TAccessLatency:
		soap_serialize_PointerTons1__TAccessLatency(soap, (enum ns1__TAccessLatency *const*)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
  p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TStatusCode(struct soap *soap, enum ns1__TStatusCode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TStatusCode
	*a = SOAP_DEFAULT_ns1__TStatusCode;
#else
	*a = (enum ns1__TStatusCode)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TStatusCode[] =
{	{ (long)ns1__TStatusCode__SRM_USCORESUCCESS, "SRM_SUCCESS" },
	{ (long)ns1__TStatusCode__SRM_USCOREFAILURE, "SRM_FAILURE" },
	{ (long)ns1__TStatusCode__SRM_USCOREAUTHENTICATION_USCOREFAILURE, "SRM_AUTHENTICATION_FAILURE" },
	{ (long)ns1__TStatusCode__SRM_USCOREAUTHORIZATION_USCOREFAILURE, "SRM_AUTHORIZATION_FAILURE" },
	{ (long)ns1__TStatusCode__SRM_USCOREINVALID_USCOREREQUEST, "SRM_INVALID_REQUEST" },
	{ (long)ns1__TStatusCode__SRM_USCOREINVALID_USCOREPATH, "SRM_INVALID_PATH" },
	{ (long)ns1__TStatusCode__SRM_USCOREFILE_USCORELIFETIME_USCOREEXPIRED, "SRM_FILE_LIFETIME_EXPIRED" },
	{ (long)ns1__TStatusCode__SRM_USCORESPACE_USCORELIFETIME_USCOREEXPIRED, "SRM_SPACE_LIFETIME_EXPIRED" },
	{ (long)ns1__TStatusCode__SRM_USCOREEXCEED_USCOREALLOCATION, "SRM_EXCEED_ALLOCATION" },
	{ (long)ns1__TStatusCode__SRM_USCORENO_USCOREUSER_USCORESPACE, "SRM_NO_USER_SPACE" },
	{ (long)ns1__TStatusCode__SRM_USCORENO_USCOREFREE_USCORESPACE, "SRM_NO_FREE_SPACE" },
	{ (long)ns1__TStatusCode__SRM_USCOREDUPLICATION_USCOREERROR, "SRM_DUPLICATION_ERROR" },
	{ (long)ns1__TStatusCode__SRM_USCORENON_USCOREEMPTY_USCOREDIRECTORY, "SRM_NON_EMPTY_DIRECTORY" },
	{ (long)ns1__TStatusCode__SRM_USCORETOO_USCOREMANY_USCORERESULTS, "SRM_TOO_MANY_RESULTS" },
	{ (long)ns1__TStatusCode__SRM_USCOREINTERNAL_USCOREERROR, "SRM_INTERNAL_ERROR" },
	{ (long)ns1__TStatusCode__SRM_USCOREFATAL_USCOREINTERNAL_USCOREERROR, "SRM_FATAL_INTERNAL_ERROR" },
	{ (long)ns1__TStatusCode__SRM_USCORENOT_USCORESUPPORTED, "SRM_NOT_SUPPORTED" },
	{ (long)ns1__TStatusCode__SRM_USCOREREQUEST_USCOREQUEUED, "SRM_REQUEST_QUEUED" },
	{ (long)ns1__TStatusCode__SRM_USCOREREQUEST_USCOREINPROGRESS, "SRM_REQUEST_INPROGRESS" },
	{ (long)ns1__TStatusCode__SRM_USCOREREQUEST_USCORESUSPENDED, "SRM_REQUEST_SUSPENDED" },
	{ (long)ns1__TStatusCode__SRM_USCOREABORTED, "SRM_ABORTED" },
	{ (long)ns1__TStatusCode__SRM_USCORERELEASED, "SRM_RELEASED" },
	{ (long)ns1__TStatusCode__SRM_USCOREFILE_USCOREPINNED, "SRM_FILE_PINNED" },
	{ (long)ns1__TStatusCode__SRM_USCOREFILE_USCOREIN_USCORECACHE, "SRM_FILE_IN_CACHE" },
	{ (long)ns1__TStatusCode__SRM_USCORESPACE_USCOREAVAILABLE, "SRM_SPACE_AVAILABLE" },
	{ (long)ns1__TStatusCode__SRM_USCORELOWER_USCORESPACE_USCOREGRANTED, "SRM_LOWER_SPACE_GRANTED" },
	{ (long)ns1__TStatusCode__SRM_USCOREDONE, "SRM_DONE" },
	{ (long)ns1__TStatusCode__SRM_USCOREPARTIAL_USCORESUCCESS, "SRM_PARTIAL_SUCCESS" },
	{ (long)ns1__TStatusCode__SRM_USCOREREQUEST_USCORETIMED_USCOREOUT, "SRM_REQUEST_TIMED_OUT" },
	{ (long)ns1__TStatusCode__SRM_USCORELAST_USCORECOPY, "SRM_LAST_COPY" },
	{ (long)ns1__TStatusCode__SRM_USCOREFILE_USCOREBUSY, "SRM_FILE_BUSY" },
	{ (long)ns1__TStatusCode__SRM_USCOREFILE_USCORELOST, "SRM_FILE_LOST" },
	{ (long)ns1__TStatusCode__SRM_USCOREFILE_USCOREUNAVAILABLE, "SRM_FILE_UNAVAILABLE" },
	{ (long)ns1__TStatusCode__SRM_USCORECUSTOM_USCORESTATUS, "SRM_CUSTOM_STATUS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TStatusCode2s(struct soap *soap, enum ns1__TStatusCode n)
{	const char *s = soap_code_str(soap_codes_ns1__TStatusCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TStatusCode(struct soap *soap, const char *tag, int id, const enum ns1__TStatusCode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TStatusCode), type) || soap_send(soap, soap_ns1__TStatusCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TStatusCode(struct soap *soap, const char *s, enum ns1__TStatusCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TStatusCode, s);
	if (map)
		*a = (enum ns1__TStatusCode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 33)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TStatusCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TStatusCode * SOAP_FMAC4 soap_in_ns1__TStatusCode(struct soap *soap, const char *tag, enum ns1__TStatusCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TStatusCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TStatusCode, sizeof(enum ns1__TStatusCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TStatusCode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TStatusCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TStatusCode, 0, sizeof(enum ns1__TStatusCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TStatusCode(struct soap *soap, const enum ns1__TStatusCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TStatusCode);
	if (soap_out_ns1__TStatusCode(soap, tag?tag:"ns1:TStatusCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TStatusCode * SOAP_FMAC4 soap_get_ns1__TStatusCode(struct soap *soap, enum ns1__TStatusCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TStatusCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TConnectionType(struct soap *soap, enum ns1__TConnectionType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TConnectionType
	*a = SOAP_DEFAULT_ns1__TConnectionType;
#else
	*a = (enum ns1__TConnectionType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TConnectionType[] =
{	{ (long)ns1__TConnectionType__WAN, "WAN" },
	{ (long)ns1__TConnectionType__LAN, "LAN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TConnectionType2s(struct soap *soap, enum ns1__TConnectionType n)
{	const char *s = soap_code_str(soap_codes_ns1__TConnectionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TConnectionType(struct soap *soap, const char *tag, int id, const enum ns1__TConnectionType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TConnectionType), type) || soap_send(soap, soap_ns1__TConnectionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TConnectionType(struct soap *soap, const char *s, enum ns1__TConnectionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TConnectionType, s);
	if (map)
		*a = (enum ns1__TConnectionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TConnectionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TConnectionType * SOAP_FMAC4 soap_in_ns1__TConnectionType(struct soap *soap, const char *tag, enum ns1__TConnectionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TConnectionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TConnectionType, sizeof(enum ns1__TConnectionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TConnectionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TConnectionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TConnectionType, 0, sizeof(enum ns1__TConnectionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TConnectionType(struct soap *soap, const enum ns1__TConnectionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TConnectionType);
	if (soap_out_ns1__TConnectionType(soap, tag?tag:"ns1:TConnectionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TConnectionType * SOAP_FMAC4 soap_get_ns1__TConnectionType(struct soap *soap, enum ns1__TConnectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TConnectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TAccessPattern(struct soap *soap, enum ns1__TAccessPattern *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TAccessPattern
	*a = SOAP_DEFAULT_ns1__TAccessPattern;
#else
	*a = (enum ns1__TAccessPattern)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TAccessPattern[] =
{	{ (long)ns1__TAccessPattern__TRANSFER_USCOREMODE, "TRANSFER_MODE" },
	{ (long)ns1__TAccessPattern__PROCESSING_USCOREMODE, "PROCESSING_MODE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TAccessPattern2s(struct soap *soap, enum ns1__TAccessPattern n)
{	const char *s = soap_code_str(soap_codes_ns1__TAccessPattern, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TAccessPattern(struct soap *soap, const char *tag, int id, const enum ns1__TAccessPattern *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TAccessPattern), type) || soap_send(soap, soap_ns1__TAccessPattern2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TAccessPattern(struct soap *soap, const char *s, enum ns1__TAccessPattern *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TAccessPattern, s);
	if (map)
		*a = (enum ns1__TAccessPattern)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TAccessPattern)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TAccessPattern * SOAP_FMAC4 soap_in_ns1__TAccessPattern(struct soap *soap, const char *tag, enum ns1__TAccessPattern *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TAccessPattern *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TAccessPattern, sizeof(enum ns1__TAccessPattern), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TAccessPattern(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TAccessPattern *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TAccessPattern, 0, sizeof(enum ns1__TAccessPattern), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TAccessPattern(struct soap *soap, const enum ns1__TAccessPattern *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TAccessPattern);
	if (soap_out_ns1__TAccessPattern(soap, tag?tag:"ns1:TAccessPattern", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TAccessPattern * SOAP_FMAC4 soap_get_ns1__TAccessPattern(struct soap *soap, enum ns1__TAccessPattern *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TAccessPattern(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TFileLocality(struct soap *soap, enum ns1__TFileLocality *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TFileLocality
	*a = SOAP_DEFAULT_ns1__TFileLocality;
#else
	*a = (enum ns1__TFileLocality)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TFileLocality[] =
{	{ (long)ns1__TFileLocality__ONLINE, "ONLINE" },
	{ (long)ns1__TFileLocality__NEARLINE, "NEARLINE" },
	{ (long)ns1__TFileLocality__ONLINE_USCOREAND_USCORENEARLINE, "ONLINE_AND_NEARLINE" },
	{ (long)ns1__TFileLocality__LOST, "LOST" },
	{ (long)ns1__TFileLocality__NONE, "NONE" },
	{ (long)ns1__TFileLocality__UNAVAILABLE, "UNAVAILABLE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TFileLocality2s(struct soap *soap, enum ns1__TFileLocality n)
{	const char *s = soap_code_str(soap_codes_ns1__TFileLocality, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TFileLocality(struct soap *soap, const char *tag, int id, const enum ns1__TFileLocality *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TFileLocality), type) || soap_send(soap, soap_ns1__TFileLocality2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TFileLocality(struct soap *soap, const char *s, enum ns1__TFileLocality *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TFileLocality, s);
	if (map)
		*a = (enum ns1__TFileLocality)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TFileLocality)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TFileLocality * SOAP_FMAC4 soap_in_ns1__TFileLocality(struct soap *soap, const char *tag, enum ns1__TFileLocality *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TFileLocality *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TFileLocality, sizeof(enum ns1__TFileLocality), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TFileLocality(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TFileLocality *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TFileLocality, 0, sizeof(enum ns1__TFileLocality), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TFileLocality(struct soap *soap, const enum ns1__TFileLocality *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TFileLocality);
	if (soap_out_ns1__TFileLocality(soap, tag?tag:"ns1:TFileLocality", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TFileLocality * SOAP_FMAC4 soap_get_ns1__TFileLocality(struct soap *soap, enum ns1__TFileLocality *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TFileLocality(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TOverwriteMode(struct soap *soap, enum ns1__TOverwriteMode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TOverwriteMode
	*a = SOAP_DEFAULT_ns1__TOverwriteMode;
#else
	*a = (enum ns1__TOverwriteMode)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TOverwriteMode[] =
{	{ (long)ns1__TOverwriteMode__NEVER, "NEVER" },
	{ (long)ns1__TOverwriteMode__ALWAYS, "ALWAYS" },
	{ (long)ns1__TOverwriteMode__WHEN_USCOREFILES_USCOREARE_USCOREDIFFERENT, "WHEN_FILES_ARE_DIFFERENT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TOverwriteMode2s(struct soap *soap, enum ns1__TOverwriteMode n)
{	const char *s = soap_code_str(soap_codes_ns1__TOverwriteMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TOverwriteMode(struct soap *soap, const char *tag, int id, const enum ns1__TOverwriteMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TOverwriteMode), type) || soap_send(soap, soap_ns1__TOverwriteMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TOverwriteMode(struct soap *soap, const char *s, enum ns1__TOverwriteMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TOverwriteMode, s);
	if (map)
		*a = (enum ns1__TOverwriteMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TOverwriteMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TOverwriteMode * SOAP_FMAC4 soap_in_ns1__TOverwriteMode(struct soap *soap, const char *tag, enum ns1__TOverwriteMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TOverwriteMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TOverwriteMode, sizeof(enum ns1__TOverwriteMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TOverwriteMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TOverwriteMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TOverwriteMode, 0, sizeof(enum ns1__TOverwriteMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TOverwriteMode(struct soap *soap, const enum ns1__TOverwriteMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TOverwriteMode);
	if (soap_out_ns1__TOverwriteMode(soap, tag?tag:"ns1:TOverwriteMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TOverwriteMode * SOAP_FMAC4 soap_get_ns1__TOverwriteMode(struct soap *soap, enum ns1__TOverwriteMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TOverwriteMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TRequestType(struct soap *soap, enum ns1__TRequestType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TRequestType
	*a = SOAP_DEFAULT_ns1__TRequestType;
#else
	*a = (enum ns1__TRequestType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TRequestType[] =
{	{ (long)ns1__TRequestType__PREPARE_USCORETO_USCOREGET, "PREPARE_TO_GET" },
	{ (long)ns1__TRequestType__PREPARE_USCORETO_USCOREPUT, "PREPARE_TO_PUT" },
	{ (long)ns1__TRequestType__COPY, "COPY" },
	{ (long)ns1__TRequestType__BRING_USCOREONLINE, "BRING_ONLINE" },
	{ (long)ns1__TRequestType__RESERVE_USCORESPACE, "RESERVE_SPACE" },
	{ (long)ns1__TRequestType__UPDATE_USCORESPACE, "UPDATE_SPACE" },
	{ (long)ns1__TRequestType__CHANGE_USCORESPACE_USCOREFOR_USCOREFILES, "CHANGE_SPACE_FOR_FILES" },
	{ (long)ns1__TRequestType__LS, "LS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TRequestType2s(struct soap *soap, enum ns1__TRequestType n)
{	const char *s = soap_code_str(soap_codes_ns1__TRequestType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TRequestType(struct soap *soap, const char *tag, int id, const enum ns1__TRequestType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TRequestType), type) || soap_send(soap, soap_ns1__TRequestType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TRequestType(struct soap *soap, const char *s, enum ns1__TRequestType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TRequestType, s);
	if (map)
		*a = (enum ns1__TRequestType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TRequestType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TRequestType * SOAP_FMAC4 soap_in_ns1__TRequestType(struct soap *soap, const char *tag, enum ns1__TRequestType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TRequestType, sizeof(enum ns1__TRequestType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TRequestType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TRequestType, 0, sizeof(enum ns1__TRequestType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TRequestType(struct soap *soap, const enum ns1__TRequestType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TRequestType);
	if (soap_out_ns1__TRequestType(soap, tag?tag:"ns1:TRequestType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TRequestType * SOAP_FMAC4 soap_get_ns1__TRequestType(struct soap *soap, enum ns1__TRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TPermissionType(struct soap *soap, enum ns1__TPermissionType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TPermissionType
	*a = SOAP_DEFAULT_ns1__TPermissionType;
#else
	*a = (enum ns1__TPermissionType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TPermissionType[] =
{	{ (long)ns1__TPermissionType__ADD, "ADD" },
	{ (long)ns1__TPermissionType__REMOVE, "REMOVE" },
	{ (long)ns1__TPermissionType__CHANGE, "CHANGE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TPermissionType2s(struct soap *soap, enum ns1__TPermissionType n)
{	const char *s = soap_code_str(soap_codes_ns1__TPermissionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TPermissionType(struct soap *soap, const char *tag, int id, const enum ns1__TPermissionType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TPermissionType), type) || soap_send(soap, soap_ns1__TPermissionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TPermissionType(struct soap *soap, const char *s, enum ns1__TPermissionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TPermissionType, s);
	if (map)
		*a = (enum ns1__TPermissionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TPermissionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TPermissionType * SOAP_FMAC4 soap_in_ns1__TPermissionType(struct soap *soap, const char *tag, enum ns1__TPermissionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TPermissionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TPermissionType, sizeof(enum ns1__TPermissionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TPermissionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TPermissionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TPermissionType, 0, sizeof(enum ns1__TPermissionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TPermissionType(struct soap *soap, const enum ns1__TPermissionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TPermissionType);
	if (soap_out_ns1__TPermissionType(soap, tag?tag:"ns1:TPermissionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TPermissionType * SOAP_FMAC4 soap_get_ns1__TPermissionType(struct soap *soap, enum ns1__TPermissionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TPermissionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TPermissionMode(struct soap *soap, enum ns1__TPermissionMode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TPermissionMode
	*a = SOAP_DEFAULT_ns1__TPermissionMode;
#else
	*a = (enum ns1__TPermissionMode)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TPermissionMode[] =
{	{ (long)ns1__TPermissionMode__NONE, "NONE" },
	{ (long)ns1__TPermissionMode__X, "X" },
	{ (long)ns1__TPermissionMode__W, "W" },
	{ (long)ns1__TPermissionMode__WX, "WX" },
	{ (long)ns1__TPermissionMode__R, "R" },
	{ (long)ns1__TPermissionMode__RX, "RX" },
	{ (long)ns1__TPermissionMode__RW, "RW" },
	{ (long)ns1__TPermissionMode__RWX, "RWX" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TPermissionMode2s(struct soap *soap, enum ns1__TPermissionMode n)
{	const char *s = soap_code_str(soap_codes_ns1__TPermissionMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TPermissionMode(struct soap *soap, const char *tag, int id, const enum ns1__TPermissionMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TPermissionMode), type) || soap_send(soap, soap_ns1__TPermissionMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TPermissionMode(struct soap *soap, const char *s, enum ns1__TPermissionMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TPermissionMode, s);
	if (map)
		*a = (enum ns1__TPermissionMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TPermissionMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TPermissionMode * SOAP_FMAC4 soap_in_ns1__TPermissionMode(struct soap *soap, const char *tag, enum ns1__TPermissionMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TPermissionMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TPermissionMode, sizeof(enum ns1__TPermissionMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TPermissionMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TPermissionMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TPermissionMode, 0, sizeof(enum ns1__TPermissionMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TPermissionMode(struct soap *soap, const enum ns1__TPermissionMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TPermissionMode);
	if (soap_out_ns1__TPermissionMode(soap, tag?tag:"ns1:TPermissionMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TPermissionMode * SOAP_FMAC4 soap_get_ns1__TPermissionMode(struct soap *soap, enum ns1__TPermissionMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TPermissionMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TAccessLatency(struct soap *soap, enum ns1__TAccessLatency *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TAccessLatency
	*a = SOAP_DEFAULT_ns1__TAccessLatency;
#else
	*a = (enum ns1__TAccessLatency)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TAccessLatency[] =
{	{ (long)ns1__TAccessLatency__ONLINE, "ONLINE" },
	{ (long)ns1__TAccessLatency__NEARLINE, "NEARLINE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TAccessLatency2s(struct soap *soap, enum ns1__TAccessLatency n)
{	const char *s = soap_code_str(soap_codes_ns1__TAccessLatency, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TAccessLatency(struct soap *soap, const char *tag, int id, const enum ns1__TAccessLatency *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TAccessLatency), type) || soap_send(soap, soap_ns1__TAccessLatency2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TAccessLatency(struct soap *soap, const char *s, enum ns1__TAccessLatency *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TAccessLatency, s);
	if (map)
		*a = (enum ns1__TAccessLatency)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TAccessLatency)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TAccessLatency * SOAP_FMAC4 soap_in_ns1__TAccessLatency(struct soap *soap, const char *tag, enum ns1__TAccessLatency *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TAccessLatency *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TAccessLatency, sizeof(enum ns1__TAccessLatency), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TAccessLatency(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TAccessLatency *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TAccessLatency, 0, sizeof(enum ns1__TAccessLatency), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TAccessLatency(struct soap *soap, const enum ns1__TAccessLatency *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TAccessLatency);
	if (soap_out_ns1__TAccessLatency(soap, tag?tag:"ns1:TAccessLatency", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TAccessLatency * SOAP_FMAC4 soap_get_ns1__TAccessLatency(struct soap *soap, enum ns1__TAccessLatency *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TAccessLatency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TRetentionPolicy(struct soap *soap, enum ns1__TRetentionPolicy *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TRetentionPolicy
	*a = SOAP_DEFAULT_ns1__TRetentionPolicy;
#else
	*a = (enum ns1__TRetentionPolicy)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TRetentionPolicy[] =
{	{ (long)ns1__TRetentionPolicy__REPLICA, "REPLICA" },
	{ (long)ns1__TRetentionPolicy__OUTPUT, "OUTPUT" },
	{ (long)ns1__TRetentionPolicy__CUSTODIAL, "CUSTODIAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TRetentionPolicy2s(struct soap *soap, enum ns1__TRetentionPolicy n)
{	const char *s = soap_code_str(soap_codes_ns1__TRetentionPolicy, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TRetentionPolicy(struct soap *soap, const char *tag, int id, const enum ns1__TRetentionPolicy *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TRetentionPolicy), type) || soap_send(soap, soap_ns1__TRetentionPolicy2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TRetentionPolicy(struct soap *soap, const char *s, enum ns1__TRetentionPolicy *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TRetentionPolicy, s);
	if (map)
		*a = (enum ns1__TRetentionPolicy)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TRetentionPolicy)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TRetentionPolicy * SOAP_FMAC4 soap_in_ns1__TRetentionPolicy(struct soap *soap, const char *tag, enum ns1__TRetentionPolicy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TRetentionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TRetentionPolicy, sizeof(enum ns1__TRetentionPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TRetentionPolicy(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TRetentionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TRetentionPolicy, 0, sizeof(enum ns1__TRetentionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TRetentionPolicy(struct soap *soap, const enum ns1__TRetentionPolicy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TRetentionPolicy);
	if (soap_out_ns1__TRetentionPolicy(soap, tag?tag:"ns1:TRetentionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TRetentionPolicy * SOAP_FMAC4 soap_get_ns1__TRetentionPolicy(struct soap *soap, enum ns1__TRetentionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TRetentionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TFileType(struct soap *soap, enum ns1__TFileType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TFileType
	*a = SOAP_DEFAULT_ns1__TFileType;
#else
	*a = (enum ns1__TFileType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TFileType[] =
{	{ (long)ns1__TFileType__FILE_, "FILE" },
	{ (long)ns1__TFileType__DIRECTORY, "DIRECTORY" },
	{ (long)ns1__TFileType__LINK, "LINK" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TFileType2s(struct soap *soap, enum ns1__TFileType n)
{	const char *s = soap_code_str(soap_codes_ns1__TFileType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TFileType(struct soap *soap, const char *tag, int id, const enum ns1__TFileType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TFileType), type) || soap_send(soap, soap_ns1__TFileType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TFileType(struct soap *soap, const char *s, enum ns1__TFileType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TFileType, s);
	if (map)
		*a = (enum ns1__TFileType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TFileType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TFileType * SOAP_FMAC4 soap_in_ns1__TFileType(struct soap *soap, const char *tag, enum ns1__TFileType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TFileType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TFileType, sizeof(enum ns1__TFileType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TFileType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TFileType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TFileType, 0, sizeof(enum ns1__TFileType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TFileType(struct soap *soap, const enum ns1__TFileType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TFileType);
	if (soap_out_ns1__TFileType(soap, tag?tag:"ns1:TFileType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TFileType * SOAP_FMAC4 soap_get_ns1__TFileType(struct soap *soap, enum ns1__TFileType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TFileType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TFileStorageType(struct soap *soap, enum ns1__TFileStorageType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TFileStorageType
	*a = SOAP_DEFAULT_ns1__TFileStorageType;
#else
	*a = (enum ns1__TFileStorageType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TFileStorageType[] =
{	{ (long)ns1__TFileStorageType__VOLATILE, "VOLATILE" },
	{ (long)ns1__TFileStorageType__DURABLE, "DURABLE" },
	{ (long)ns1__TFileStorageType__PERMANENT, "PERMANENT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TFileStorageType2s(struct soap *soap, enum ns1__TFileStorageType n)
{	const char *s = soap_code_str(soap_codes_ns1__TFileStorageType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TFileStorageType(struct soap *soap, const char *tag, int id, const enum ns1__TFileStorageType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TFileStorageType), type) || soap_send(soap, soap_ns1__TFileStorageType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TFileStorageType(struct soap *soap, const char *s, enum ns1__TFileStorageType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TFileStorageType, s);
	if (map)
		*a = (enum ns1__TFileStorageType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TFileStorageType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TFileStorageType * SOAP_FMAC4 soap_in_ns1__TFileStorageType(struct soap *soap, const char *tag, enum ns1__TFileStorageType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TFileStorageType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TFileStorageType, sizeof(enum ns1__TFileStorageType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TFileStorageType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TFileStorageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TFileStorageType, 0, sizeof(enum ns1__TFileStorageType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TFileStorageType(struct soap *soap, const enum ns1__TFileStorageType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TFileStorageType);
	if (soap_out_ns1__TFileStorageType(soap, tag?tag:"ns1:TFileStorageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TFileStorageType * SOAP_FMAC4 soap_get_ns1__TFileStorageType(struct soap *soap, enum ns1__TFileStorageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TFileStorageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPing(struct soap *soap, struct ns1__srmPing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPingRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPing(struct soap *soap, const struct ns1__srmPing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmPingRequest(soap, &a->srmPingRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPing(struct soap *soap, const char *tag, int id, const struct ns1__srmPing *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPing), type))
		return soap->error;
	if (soap_out_PointerTons1__srmPingRequest(soap, "srmPingRequest", -1, &a->srmPingRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPing * SOAP_FMAC4 soap_in_ns1__srmPing(struct soap *soap, const char *tag, struct ns1__srmPing *a, const char *type)
{
	size_t soap_flag_srmPingRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPing *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPing, sizeof(struct ns1__srmPing), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPing(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPingRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmPingRequest(soap, "srmPingRequest", &a->srmPingRequest, "ns1:srmPingRequest"))
				{	soap_flag_srmPingRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPing *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPing, 0, sizeof(struct ns1__srmPing), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPing(struct soap *soap, const struct ns1__srmPing *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPing);
	if (soap_out_ns1__srmPing(soap, tag?tag:"ns1:srmPing", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPing * SOAP_FMAC4 soap_get_ns1__srmPing(struct soap *soap, struct ns1__srmPing *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPingResponse_(struct soap *soap, struct ns1__srmPingResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPingResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPingResponse_(struct soap *soap, const struct ns1__srmPingResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmPingResponse(soap, &a->srmPingResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPingResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmPingResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPingResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmPingResponse(soap, "srmPingResponse", -1, &a->srmPingResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPingResponse_ * SOAP_FMAC4 soap_in_ns1__srmPingResponse_(struct soap *soap, const char *tag, struct ns1__srmPingResponse_ *a, const char *type)
{
	size_t soap_flag_srmPingResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPingResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPingResponse_, sizeof(struct ns1__srmPingResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPingResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPingResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmPingResponse(soap, "srmPingResponse", &a->srmPingResponse, "ns1:srmPingResponse"))
				{	soap_flag_srmPingResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPingResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPingResponse_, 0, sizeof(struct ns1__srmPingResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPingResponse_(struct soap *soap, const struct ns1__srmPingResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPingResponse_);
	if (soap_out_ns1__srmPingResponse_(soap, tag?tag:"ns1:srmPingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPingResponse_ * SOAP_FMAC4 soap_get_ns1__srmPingResponse_(struct soap *soap, struct ns1__srmPingResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPingResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetTransferProtocols(struct soap *soap, struct ns1__srmGetTransferProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetTransferProtocolsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetTransferProtocols(struct soap *soap, const struct ns1__srmGetTransferProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmGetTransferProtocolsRequest(soap, &a->srmGetTransferProtocolsRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetTransferProtocols(struct soap *soap, const char *tag, int id, const struct ns1__srmGetTransferProtocols *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetTransferProtocols), type))
		return soap->error;
	if (soap_out_PointerTons1__srmGetTransferProtocolsRequest(soap, "srmGetTransferProtocolsRequest", -1, &a->srmGetTransferProtocolsRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocols * SOAP_FMAC4 soap_in_ns1__srmGetTransferProtocols(struct soap *soap, const char *tag, struct ns1__srmGetTransferProtocols *a, const char *type)
{
	size_t soap_flag_srmGetTransferProtocolsRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetTransferProtocols *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetTransferProtocols, sizeof(struct ns1__srmGetTransferProtocols), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetTransferProtocols(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetTransferProtocolsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmGetTransferProtocolsRequest(soap, "srmGetTransferProtocolsRequest", &a->srmGetTransferProtocolsRequest, "ns1:srmGetTransferProtocolsRequest"))
				{	soap_flag_srmGetTransferProtocolsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetTransferProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetTransferProtocols, 0, sizeof(struct ns1__srmGetTransferProtocols), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetTransferProtocols(struct soap *soap, const struct ns1__srmGetTransferProtocols *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetTransferProtocols);
	if (soap_out_ns1__srmGetTransferProtocols(soap, tag?tag:"ns1:srmGetTransferProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocols * SOAP_FMAC4 soap_get_ns1__srmGetTransferProtocols(struct soap *soap, struct ns1__srmGetTransferProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetTransferProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetTransferProtocolsResponse_(struct soap *soap, struct ns1__srmGetTransferProtocolsResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetTransferProtocolsResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetTransferProtocolsResponse_(struct soap *soap, const struct ns1__srmGetTransferProtocolsResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmGetTransferProtocolsResponse(soap, &a->srmGetTransferProtocolsResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetTransferProtocolsResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmGetTransferProtocolsResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmGetTransferProtocolsResponse(soap, "srmGetTransferProtocolsResponse", -1, &a->srmGetTransferProtocolsResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocolsResponse_ * SOAP_FMAC4 soap_in_ns1__srmGetTransferProtocolsResponse_(struct soap *soap, const char *tag, struct ns1__srmGetTransferProtocolsResponse_ *a, const char *type)
{
	size_t soap_flag_srmGetTransferProtocolsResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetTransferProtocolsResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse_, sizeof(struct ns1__srmGetTransferProtocolsResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetTransferProtocolsResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetTransferProtocolsResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmGetTransferProtocolsResponse(soap, "srmGetTransferProtocolsResponse", &a->srmGetTransferProtocolsResponse, "ns1:srmGetTransferProtocolsResponse"))
				{	soap_flag_srmGetTransferProtocolsResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetTransferProtocolsResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse_, 0, sizeof(struct ns1__srmGetTransferProtocolsResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetTransferProtocolsResponse_(struct soap *soap, const struct ns1__srmGetTransferProtocolsResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse_);
	if (soap_out_ns1__srmGetTransferProtocolsResponse_(soap, tag?tag:"ns1:srmGetTransferProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocolsResponse_ * SOAP_FMAC4 soap_get_ns1__srmGetTransferProtocolsResponse_(struct soap *soap, struct ns1__srmGetTransferProtocolsResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetTransferProtocolsResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetRequestTokens(struct soap *soap, struct ns1__srmGetRequestTokens *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetRequestTokensRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetRequestTokens(struct soap *soap, const struct ns1__srmGetRequestTokens *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmGetRequestTokensRequest(soap, &a->srmGetRequestTokensRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetRequestTokens(struct soap *soap, const char *tag, int id, const struct ns1__srmGetRequestTokens *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetRequestTokens), type))
		return soap->error;
	if (soap_out_PointerTons1__srmGetRequestTokensRequest(soap, "srmGetRequestTokensRequest", -1, &a->srmGetRequestTokensRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokens * SOAP_FMAC4 soap_in_ns1__srmGetRequestTokens(struct soap *soap, const char *tag, struct ns1__srmGetRequestTokens *a, const char *type)
{
	size_t soap_flag_srmGetRequestTokensRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetRequestTokens *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetRequestTokens, sizeof(struct ns1__srmGetRequestTokens), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetRequestTokens(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetRequestTokensRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmGetRequestTokensRequest(soap, "srmGetRequestTokensRequest", &a->srmGetRequestTokensRequest, "ns1:srmGetRequestTokensRequest"))
				{	soap_flag_srmGetRequestTokensRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestTokens *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetRequestTokens, 0, sizeof(struct ns1__srmGetRequestTokens), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetRequestTokens(struct soap *soap, const struct ns1__srmGetRequestTokens *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetRequestTokens);
	if (soap_out_ns1__srmGetRequestTokens(soap, tag?tag:"ns1:srmGetRequestTokens", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokens * SOAP_FMAC4 soap_get_ns1__srmGetRequestTokens(struct soap *soap, struct ns1__srmGetRequestTokens *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetRequestTokens(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetRequestTokensResponse_(struct soap *soap, struct ns1__srmGetRequestTokensResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetRequestTokensResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetRequestTokensResponse_(struct soap *soap, const struct ns1__srmGetRequestTokensResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmGetRequestTokensResponse(soap, &a->srmGetRequestTokensResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetRequestTokensResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmGetRequestTokensResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetRequestTokensResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmGetRequestTokensResponse(soap, "srmGetRequestTokensResponse", -1, &a->srmGetRequestTokensResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokensResponse_ * SOAP_FMAC4 soap_in_ns1__srmGetRequestTokensResponse_(struct soap *soap, const char *tag, struct ns1__srmGetRequestTokensResponse_ *a, const char *type)
{
	size_t soap_flag_srmGetRequestTokensResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetRequestTokensResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetRequestTokensResponse_, sizeof(struct ns1__srmGetRequestTokensResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetRequestTokensResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetRequestTokensResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmGetRequestTokensResponse(soap, "srmGetRequestTokensResponse", &a->srmGetRequestTokensResponse, "ns1:srmGetRequestTokensResponse"))
				{	soap_flag_srmGetRequestTokensResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestTokensResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetRequestTokensResponse_, 0, sizeof(struct ns1__srmGetRequestTokensResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetRequestTokensResponse_(struct soap *soap, const struct ns1__srmGetRequestTokensResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetRequestTokensResponse_);
	if (soap_out_ns1__srmGetRequestTokensResponse_(soap, tag?tag:"ns1:srmGetRequestTokensResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokensResponse_ * SOAP_FMAC4 soap_get_ns1__srmGetRequestTokensResponse_(struct soap *soap, struct ns1__srmGetRequestTokensResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetRequestTokensResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmExtendFileLifeTime(struct soap *soap, struct ns1__srmExtendFileLifeTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmExtendFileLifeTimeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmExtendFileLifeTime(struct soap *soap, const struct ns1__srmExtendFileLifeTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmExtendFileLifeTimeRequest(soap, &a->srmExtendFileLifeTimeRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmExtendFileLifeTime(struct soap *soap, const char *tag, int id, const struct ns1__srmExtendFileLifeTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmExtendFileLifeTime), type))
		return soap->error;
	if (soap_out_PointerTons1__srmExtendFileLifeTimeRequest(soap, "srmExtendFileLifeTimeRequest", -1, &a->srmExtendFileLifeTimeRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTime * SOAP_FMAC4 soap_in_ns1__srmExtendFileLifeTime(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTime *a, const char *type)
{
	size_t soap_flag_srmExtendFileLifeTimeRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmExtendFileLifeTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmExtendFileLifeTime, sizeof(struct ns1__srmExtendFileLifeTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmExtendFileLifeTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmExtendFileLifeTimeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmExtendFileLifeTimeRequest(soap, "srmExtendFileLifeTimeRequest", &a->srmExtendFileLifeTimeRequest, "ns1:srmExtendFileLifeTimeRequest"))
				{	soap_flag_srmExtendFileLifeTimeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmExtendFileLifeTime, 0, sizeof(struct ns1__srmExtendFileLifeTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmExtendFileLifeTime(struct soap *soap, const struct ns1__srmExtendFileLifeTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmExtendFileLifeTime);
	if (soap_out_ns1__srmExtendFileLifeTime(soap, tag?tag:"ns1:srmExtendFileLifeTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTime * SOAP_FMAC4 soap_get_ns1__srmExtendFileLifeTime(struct soap *soap, struct ns1__srmExtendFileLifeTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmExtendFileLifeTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmExtendFileLifeTimeResponse_(struct soap *soap, struct ns1__srmExtendFileLifeTimeResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmExtendFileLifeTimeResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmExtendFileLifeTimeResponse_(struct soap *soap, const struct ns1__srmExtendFileLifeTimeResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmExtendFileLifeTimeResponse(soap, &a->srmExtendFileLifeTimeResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmExtendFileLifeTimeResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmExtendFileLifeTimeResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmExtendFileLifeTimeResponse(soap, "srmExtendFileLifeTimeResponse", -1, &a->srmExtendFileLifeTimeResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeResponse_ * SOAP_FMAC4 soap_in_ns1__srmExtendFileLifeTimeResponse_(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeResponse_ *a, const char *type)
{
	size_t soap_flag_srmExtendFileLifeTimeResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmExtendFileLifeTimeResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse_, sizeof(struct ns1__srmExtendFileLifeTimeResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmExtendFileLifeTimeResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmExtendFileLifeTimeResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmExtendFileLifeTimeResponse(soap, "srmExtendFileLifeTimeResponse", &a->srmExtendFileLifeTimeResponse, "ns1:srmExtendFileLifeTimeResponse"))
				{	soap_flag_srmExtendFileLifeTimeResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse_, 0, sizeof(struct ns1__srmExtendFileLifeTimeResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmExtendFileLifeTimeResponse_(struct soap *soap, const struct ns1__srmExtendFileLifeTimeResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse_);
	if (soap_out_ns1__srmExtendFileLifeTimeResponse_(soap, tag?tag:"ns1:srmExtendFileLifeTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeResponse_ * SOAP_FMAC4 soap_get_ns1__srmExtendFileLifeTimeResponse_(struct soap *soap, struct ns1__srmExtendFileLifeTimeResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmExtendFileLifeTimeResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetRequestSummary(struct soap *soap, struct ns1__srmGetRequestSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetRequestSummaryRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetRequestSummary(struct soap *soap, const struct ns1__srmGetRequestSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmGetRequestSummaryRequest(soap, &a->srmGetRequestSummaryRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetRequestSummary(struct soap *soap, const char *tag, int id, const struct ns1__srmGetRequestSummary *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetRequestSummary), type))
		return soap->error;
	if (soap_out_PointerTons1__srmGetRequestSummaryRequest(soap, "srmGetRequestSummaryRequest", -1, &a->srmGetRequestSummaryRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummary * SOAP_FMAC4 soap_in_ns1__srmGetRequestSummary(struct soap *soap, const char *tag, struct ns1__srmGetRequestSummary *a, const char *type)
{
	size_t soap_flag_srmGetRequestSummaryRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetRequestSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetRequestSummary, sizeof(struct ns1__srmGetRequestSummary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetRequestSummary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetRequestSummaryRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmGetRequestSummaryRequest(soap, "srmGetRequestSummaryRequest", &a->srmGetRequestSummaryRequest, "ns1:srmGetRequestSummaryRequest"))
				{	soap_flag_srmGetRequestSummaryRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetRequestSummary, 0, sizeof(struct ns1__srmGetRequestSummary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetRequestSummary(struct soap *soap, const struct ns1__srmGetRequestSummary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetRequestSummary);
	if (soap_out_ns1__srmGetRequestSummary(soap, tag?tag:"ns1:srmGetRequestSummary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummary * SOAP_FMAC4 soap_get_ns1__srmGetRequestSummary(struct soap *soap, struct ns1__srmGetRequestSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetRequestSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetRequestSummaryResponse_(struct soap *soap, struct ns1__srmGetRequestSummaryResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetRequestSummaryResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetRequestSummaryResponse_(struct soap *soap, const struct ns1__srmGetRequestSummaryResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmGetRequestSummaryResponse(soap, &a->srmGetRequestSummaryResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetRequestSummaryResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmGetRequestSummaryResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetRequestSummaryResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmGetRequestSummaryResponse(soap, "srmGetRequestSummaryResponse", -1, &a->srmGetRequestSummaryResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummaryResponse_ * SOAP_FMAC4 soap_in_ns1__srmGetRequestSummaryResponse_(struct soap *soap, const char *tag, struct ns1__srmGetRequestSummaryResponse_ *a, const char *type)
{
	size_t soap_flag_srmGetRequestSummaryResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetRequestSummaryResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetRequestSummaryResponse_, sizeof(struct ns1__srmGetRequestSummaryResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetRequestSummaryResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetRequestSummaryResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmGetRequestSummaryResponse(soap, "srmGetRequestSummaryResponse", &a->srmGetRequestSummaryResponse, "ns1:srmGetRequestSummaryResponse"))
				{	soap_flag_srmGetRequestSummaryResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestSummaryResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetRequestSummaryResponse_, 0, sizeof(struct ns1__srmGetRequestSummaryResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetRequestSummaryResponse_(struct soap *soap, const struct ns1__srmGetRequestSummaryResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetRequestSummaryResponse_);
	if (soap_out_ns1__srmGetRequestSummaryResponse_(soap, tag?tag:"ns1:srmGetRequestSummaryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummaryResponse_ * SOAP_FMAC4 soap_get_ns1__srmGetRequestSummaryResponse_(struct soap *soap, struct ns1__srmGetRequestSummaryResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetRequestSummaryResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmResumeRequest(struct soap *soap, struct ns1__srmResumeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmResumeRequestRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmResumeRequest(struct soap *soap, const struct ns1__srmResumeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmResumeRequestRequest(soap, &a->srmResumeRequestRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmResumeRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmResumeRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmResumeRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__srmResumeRequestRequest(soap, "srmResumeRequestRequest", -1, &a->srmResumeRequestRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmResumeRequest * SOAP_FMAC4 soap_in_ns1__srmResumeRequest(struct soap *soap, const char *tag, struct ns1__srmResumeRequest *a, const char *type)
{
	size_t soap_flag_srmResumeRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmResumeRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmResumeRequest, sizeof(struct ns1__srmResumeRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmResumeRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmResumeRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmResumeRequestRequest(soap, "srmResumeRequestRequest", &a->srmResumeRequestRequest, "ns1:srmResumeRequestRequest"))
				{	soap_flag_srmResumeRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmResumeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmResumeRequest, 0, sizeof(struct ns1__srmResumeRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmResumeRequest(struct soap *soap, const struct ns1__srmResumeRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmResumeRequest);
	if (soap_out_ns1__srmResumeRequest(soap, tag?tag:"ns1:srmResumeRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmResumeRequest * SOAP_FMAC4 soap_get_ns1__srmResumeRequest(struct soap *soap, struct ns1__srmResumeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmResumeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmResumeRequestResponse_(struct soap *soap, struct ns1__srmResumeRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmResumeRequestResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmResumeRequestResponse_(struct soap *soap, const struct ns1__srmResumeRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmResumeRequestResponse(soap, &a->srmResumeRequestResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmResumeRequestResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmResumeRequestResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmResumeRequestResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmResumeRequestResponse(soap, "srmResumeRequestResponse", -1, &a->srmResumeRequestResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmResumeRequestResponse_ * SOAP_FMAC4 soap_in_ns1__srmResumeRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmResumeRequestResponse_ *a, const char *type)
{
	size_t soap_flag_srmResumeRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmResumeRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmResumeRequestResponse_, sizeof(struct ns1__srmResumeRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmResumeRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmResumeRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmResumeRequestResponse(soap, "srmResumeRequestResponse", &a->srmResumeRequestResponse, "ns1:srmResumeRequestResponse"))
				{	soap_flag_srmResumeRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmResumeRequestResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmResumeRequestResponse_, 0, sizeof(struct ns1__srmResumeRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmResumeRequestResponse_(struct soap *soap, const struct ns1__srmResumeRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmResumeRequestResponse_);
	if (soap_out_ns1__srmResumeRequestResponse_(soap, tag?tag:"ns1:srmResumeRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmResumeRequestResponse_ * SOAP_FMAC4 soap_get_ns1__srmResumeRequestResponse_(struct soap *soap, struct ns1__srmResumeRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmResumeRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmSuspendRequest(struct soap *soap, struct ns1__srmSuspendRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmSuspendRequestRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmSuspendRequest(struct soap *soap, const struct ns1__srmSuspendRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmSuspendRequestRequest(soap, &a->srmSuspendRequestRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmSuspendRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmSuspendRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmSuspendRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__srmSuspendRequestRequest(soap, "srmSuspendRequestRequest", -1, &a->srmSuspendRequestRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmSuspendRequest * SOAP_FMAC4 soap_in_ns1__srmSuspendRequest(struct soap *soap, const char *tag, struct ns1__srmSuspendRequest *a, const char *type)
{
	size_t soap_flag_srmSuspendRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmSuspendRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmSuspendRequest, sizeof(struct ns1__srmSuspendRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmSuspendRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmSuspendRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmSuspendRequestRequest(soap, "srmSuspendRequestRequest", &a->srmSuspendRequestRequest, "ns1:srmSuspendRequestRequest"))
				{	soap_flag_srmSuspendRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSuspendRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmSuspendRequest, 0, sizeof(struct ns1__srmSuspendRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmSuspendRequest(struct soap *soap, const struct ns1__srmSuspendRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmSuspendRequest);
	if (soap_out_ns1__srmSuspendRequest(soap, tag?tag:"ns1:srmSuspendRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSuspendRequest * SOAP_FMAC4 soap_get_ns1__srmSuspendRequest(struct soap *soap, struct ns1__srmSuspendRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmSuspendRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmSuspendRequestResponse_(struct soap *soap, struct ns1__srmSuspendRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmSuspendRequestResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmSuspendRequestResponse_(struct soap *soap, const struct ns1__srmSuspendRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmSuspendRequestResponse(soap, &a->srmSuspendRequestResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmSuspendRequestResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmSuspendRequestResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmSuspendRequestResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmSuspendRequestResponse(soap, "srmSuspendRequestResponse", -1, &a->srmSuspendRequestResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmSuspendRequestResponse_ * SOAP_FMAC4 soap_in_ns1__srmSuspendRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmSuspendRequestResponse_ *a, const char *type)
{
	size_t soap_flag_srmSuspendRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmSuspendRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmSuspendRequestResponse_, sizeof(struct ns1__srmSuspendRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmSuspendRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmSuspendRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmSuspendRequestResponse(soap, "srmSuspendRequestResponse", &a->srmSuspendRequestResponse, "ns1:srmSuspendRequestResponse"))
				{	soap_flag_srmSuspendRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSuspendRequestResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmSuspendRequestResponse_, 0, sizeof(struct ns1__srmSuspendRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmSuspendRequestResponse_(struct soap *soap, const struct ns1__srmSuspendRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmSuspendRequestResponse_);
	if (soap_out_ns1__srmSuspendRequestResponse_(soap, tag?tag:"ns1:srmSuspendRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSuspendRequestResponse_ * SOAP_FMAC4 soap_get_ns1__srmSuspendRequestResponse_(struct soap *soap, struct ns1__srmSuspendRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmSuspendRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmAbortFiles(struct soap *soap, struct ns1__srmAbortFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmAbortFilesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmAbortFiles(struct soap *soap, const struct ns1__srmAbortFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmAbortFilesRequest(soap, &a->srmAbortFilesRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmAbortFiles(struct soap *soap, const char *tag, int id, const struct ns1__srmAbortFiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmAbortFiles), type))
		return soap->error;
	if (soap_out_PointerTons1__srmAbortFilesRequest(soap, "srmAbortFilesRequest", -1, &a->srmAbortFilesRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmAbortFiles * SOAP_FMAC4 soap_in_ns1__srmAbortFiles(struct soap *soap, const char *tag, struct ns1__srmAbortFiles *a, const char *type)
{
	size_t soap_flag_srmAbortFilesRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmAbortFiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmAbortFiles, sizeof(struct ns1__srmAbortFiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmAbortFiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmAbortFilesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmAbortFilesRequest(soap, "srmAbortFilesRequest", &a->srmAbortFilesRequest, "ns1:srmAbortFilesRequest"))
				{	soap_flag_srmAbortFilesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortFiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmAbortFiles, 0, sizeof(struct ns1__srmAbortFiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmAbortFiles(struct soap *soap, const struct ns1__srmAbortFiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmAbortFiles);
	if (soap_out_ns1__srmAbortFiles(soap, tag?tag:"ns1:srmAbortFiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortFiles * SOAP_FMAC4 soap_get_ns1__srmAbortFiles(struct soap *soap, struct ns1__srmAbortFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmAbortFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmAbortFilesResponse_(struct soap *soap, struct ns1__srmAbortFilesResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmAbortFilesResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmAbortFilesResponse_(struct soap *soap, const struct ns1__srmAbortFilesResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmAbortFilesResponse(soap, &a->srmAbortFilesResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmAbortFilesResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmAbortFilesResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmAbortFilesResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmAbortFilesResponse(soap, "srmAbortFilesResponse", -1, &a->srmAbortFilesResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmAbortFilesResponse_ * SOAP_FMAC4 soap_in_ns1__srmAbortFilesResponse_(struct soap *soap, const char *tag, struct ns1__srmAbortFilesResponse_ *a, const char *type)
{
	size_t soap_flag_srmAbortFilesResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmAbortFilesResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmAbortFilesResponse_, sizeof(struct ns1__srmAbortFilesResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmAbortFilesResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmAbortFilesResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmAbortFilesResponse(soap, "srmAbortFilesResponse", &a->srmAbortFilesResponse, "ns1:srmAbortFilesResponse"))
				{	soap_flag_srmAbortFilesResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortFilesResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmAbortFilesResponse_, 0, sizeof(struct ns1__srmAbortFilesResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmAbortFilesResponse_(struct soap *soap, const struct ns1__srmAbortFilesResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmAbortFilesResponse_);
	if (soap_out_ns1__srmAbortFilesResponse_(soap, tag?tag:"ns1:srmAbortFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortFilesResponse_ * SOAP_FMAC4 soap_get_ns1__srmAbortFilesResponse_(struct soap *soap, struct ns1__srmAbortFilesResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmAbortFilesResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmAbortRequest(struct soap *soap, struct ns1__srmAbortRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmAbortRequestRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmAbortRequest(struct soap *soap, const struct ns1__srmAbortRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmAbortRequestRequest(soap, &a->srmAbortRequestRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmAbortRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmAbortRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmAbortRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__srmAbortRequestRequest(soap, "srmAbortRequestRequest", -1, &a->srmAbortRequestRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmAbortRequest * SOAP_FMAC4 soap_in_ns1__srmAbortRequest(struct soap *soap, const char *tag, struct ns1__srmAbortRequest *a, const char *type)
{
	size_t soap_flag_srmAbortRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmAbortRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmAbortRequest, sizeof(struct ns1__srmAbortRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmAbortRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmAbortRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmAbortRequestRequest(soap, "srmAbortRequestRequest", &a->srmAbortRequestRequest, "ns1:srmAbortRequestRequest"))
				{	soap_flag_srmAbortRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmAbortRequest, 0, sizeof(struct ns1__srmAbortRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmAbortRequest(struct soap *soap, const struct ns1__srmAbortRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmAbortRequest);
	if (soap_out_ns1__srmAbortRequest(soap, tag?tag:"ns1:srmAbortRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortRequest * SOAP_FMAC4 soap_get_ns1__srmAbortRequest(struct soap *soap, struct ns1__srmAbortRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmAbortRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmAbortRequestResponse_(struct soap *soap, struct ns1__srmAbortRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmAbortRequestResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmAbortRequestResponse_(struct soap *soap, const struct ns1__srmAbortRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmAbortRequestResponse(soap, &a->srmAbortRequestResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmAbortRequestResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmAbortRequestResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmAbortRequestResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmAbortRequestResponse(soap, "srmAbortRequestResponse", -1, &a->srmAbortRequestResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmAbortRequestResponse_ * SOAP_FMAC4 soap_in_ns1__srmAbortRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmAbortRequestResponse_ *a, const char *type)
{
	size_t soap_flag_srmAbortRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmAbortRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmAbortRequestResponse_, sizeof(struct ns1__srmAbortRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmAbortRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmAbortRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmAbortRequestResponse(soap, "srmAbortRequestResponse", &a->srmAbortRequestResponse, "ns1:srmAbortRequestResponse"))
				{	soap_flag_srmAbortRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortRequestResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmAbortRequestResponse_, 0, sizeof(struct ns1__srmAbortRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmAbortRequestResponse_(struct soap *soap, const struct ns1__srmAbortRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmAbortRequestResponse_);
	if (soap_out_ns1__srmAbortRequestResponse_(soap, tag?tag:"ns1:srmAbortRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortRequestResponse_ * SOAP_FMAC4 soap_get_ns1__srmAbortRequestResponse_(struct soap *soap, struct ns1__srmAbortRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmAbortRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPutDone(struct soap *soap, struct ns1__srmPutDone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPutDoneRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPutDone(struct soap *soap, const struct ns1__srmPutDone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmPutDoneRequest(soap, &a->srmPutDoneRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPutDone(struct soap *soap, const char *tag, int id, const struct ns1__srmPutDone *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPutDone), type))
		return soap->error;
	if (soap_out_PointerTons1__srmPutDoneRequest(soap, "srmPutDoneRequest", -1, &a->srmPutDoneRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPutDone * SOAP_FMAC4 soap_in_ns1__srmPutDone(struct soap *soap, const char *tag, struct ns1__srmPutDone *a, const char *type)
{
	size_t soap_flag_srmPutDoneRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPutDone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPutDone, sizeof(struct ns1__srmPutDone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPutDone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPutDoneRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmPutDoneRequest(soap, "srmPutDoneRequest", &a->srmPutDoneRequest, "ns1:srmPutDoneRequest"))
				{	soap_flag_srmPutDoneRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPutDone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPutDone, 0, sizeof(struct ns1__srmPutDone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPutDone(struct soap *soap, const struct ns1__srmPutDone *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPutDone);
	if (soap_out_ns1__srmPutDone(soap, tag?tag:"ns1:srmPutDone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPutDone * SOAP_FMAC4 soap_get_ns1__srmPutDone(struct soap *soap, struct ns1__srmPutDone *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPutDone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPutDoneResponse_(struct soap *soap, struct ns1__srmPutDoneResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPutDoneResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPutDoneResponse_(struct soap *soap, const struct ns1__srmPutDoneResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmPutDoneResponse(soap, &a->srmPutDoneResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPutDoneResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmPutDoneResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPutDoneResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmPutDoneResponse(soap, "srmPutDoneResponse", -1, &a->srmPutDoneResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPutDoneResponse_ * SOAP_FMAC4 soap_in_ns1__srmPutDoneResponse_(struct soap *soap, const char *tag, struct ns1__srmPutDoneResponse_ *a, const char *type)
{
	size_t soap_flag_srmPutDoneResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPutDoneResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPutDoneResponse_, sizeof(struct ns1__srmPutDoneResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPutDoneResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPutDoneResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmPutDoneResponse(soap, "srmPutDoneResponse", &a->srmPutDoneResponse, "ns1:srmPutDoneResponse"))
				{	soap_flag_srmPutDoneResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPutDoneResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPutDoneResponse_, 0, sizeof(struct ns1__srmPutDoneResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPutDoneResponse_(struct soap *soap, const struct ns1__srmPutDoneResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPutDoneResponse_);
	if (soap_out_ns1__srmPutDoneResponse_(soap, tag?tag:"ns1:srmPutDoneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPutDoneResponse_ * SOAP_FMAC4 soap_get_ns1__srmPutDoneResponse_(struct soap *soap, struct ns1__srmPutDoneResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPutDoneResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmReleaseFiles(struct soap *soap, struct ns1__srmReleaseFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmReleaseFilesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmReleaseFiles(struct soap *soap, const struct ns1__srmReleaseFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmReleaseFilesRequest(soap, &a->srmReleaseFilesRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmReleaseFiles(struct soap *soap, const char *tag, int id, const struct ns1__srmReleaseFiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmReleaseFiles), type))
		return soap->error;
	if (soap_out_PointerTons1__srmReleaseFilesRequest(soap, "srmReleaseFilesRequest", -1, &a->srmReleaseFilesRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmReleaseFiles * SOAP_FMAC4 soap_in_ns1__srmReleaseFiles(struct soap *soap, const char *tag, struct ns1__srmReleaseFiles *a, const char *type)
{
	size_t soap_flag_srmReleaseFilesRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmReleaseFiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmReleaseFiles, sizeof(struct ns1__srmReleaseFiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmReleaseFiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmReleaseFilesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmReleaseFilesRequest(soap, "srmReleaseFilesRequest", &a->srmReleaseFilesRequest, "ns1:srmReleaseFilesRequest"))
				{	soap_flag_srmReleaseFilesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseFiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmReleaseFiles, 0, sizeof(struct ns1__srmReleaseFiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmReleaseFiles(struct soap *soap, const struct ns1__srmReleaseFiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmReleaseFiles);
	if (soap_out_ns1__srmReleaseFiles(soap, tag?tag:"ns1:srmReleaseFiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseFiles * SOAP_FMAC4 soap_get_ns1__srmReleaseFiles(struct soap *soap, struct ns1__srmReleaseFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmReleaseFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmReleaseFilesResponse_(struct soap *soap, struct ns1__srmReleaseFilesResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmReleaseFilesResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmReleaseFilesResponse_(struct soap *soap, const struct ns1__srmReleaseFilesResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmReleaseFilesResponse(soap, &a->srmReleaseFilesResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmReleaseFilesResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmReleaseFilesResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmReleaseFilesResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmReleaseFilesResponse(soap, "srmReleaseFilesResponse", -1, &a->srmReleaseFilesResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmReleaseFilesResponse_ * SOAP_FMAC4 soap_in_ns1__srmReleaseFilesResponse_(struct soap *soap, const char *tag, struct ns1__srmReleaseFilesResponse_ *a, const char *type)
{
	size_t soap_flag_srmReleaseFilesResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmReleaseFilesResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmReleaseFilesResponse_, sizeof(struct ns1__srmReleaseFilesResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmReleaseFilesResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmReleaseFilesResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmReleaseFilesResponse(soap, "srmReleaseFilesResponse", &a->srmReleaseFilesResponse, "ns1:srmReleaseFilesResponse"))
				{	soap_flag_srmReleaseFilesResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseFilesResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmReleaseFilesResponse_, 0, sizeof(struct ns1__srmReleaseFilesResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmReleaseFilesResponse_(struct soap *soap, const struct ns1__srmReleaseFilesResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmReleaseFilesResponse_);
	if (soap_out_ns1__srmReleaseFilesResponse_(soap, tag?tag:"ns1:srmReleaseFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseFilesResponse_ * SOAP_FMAC4 soap_get_ns1__srmReleaseFilesResponse_(struct soap *soap, struct ns1__srmReleaseFilesResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmReleaseFilesResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfCopyRequest(struct soap *soap, struct ns1__srmStatusOfCopyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfCopyRequestRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfCopyRequest(struct soap *soap, const struct ns1__srmStatusOfCopyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfCopyRequestRequest(soap, &a->srmStatusOfCopyRequestRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfCopyRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfCopyRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfCopyRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfCopyRequestRequest(soap, "srmStatusOfCopyRequestRequest", -1, &a->srmStatusOfCopyRequestRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfCopyRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfCopyRequest *a, const char *type)
{
	size_t soap_flag_srmStatusOfCopyRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfCopyRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfCopyRequest, sizeof(struct ns1__srmStatusOfCopyRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfCopyRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfCopyRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfCopyRequestRequest(soap, "srmStatusOfCopyRequestRequest", &a->srmStatusOfCopyRequestRequest, "ns1:srmStatusOfCopyRequestRequest"))
				{	soap_flag_srmStatusOfCopyRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfCopyRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfCopyRequest, 0, sizeof(struct ns1__srmStatusOfCopyRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfCopyRequest(struct soap *soap, const struct ns1__srmStatusOfCopyRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfCopyRequest);
	if (soap_out_ns1__srmStatusOfCopyRequest(soap, tag?tag:"ns1:srmStatusOfCopyRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfCopyRequest(struct soap *soap, struct ns1__srmStatusOfCopyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfCopyRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfCopyRequestResponse_(struct soap *soap, struct ns1__srmStatusOfCopyRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfCopyRequestResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfCopyRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfCopyRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfCopyRequestResponse(soap, &a->srmStatusOfCopyRequestResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfCopyRequestResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfCopyRequestResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfCopyRequestResponse(soap, "srmStatusOfCopyRequestResponse", -1, &a->srmStatusOfCopyRequestResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequestResponse_ * SOAP_FMAC4 soap_in_ns1__srmStatusOfCopyRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfCopyRequestResponse_ *a, const char *type)
{
	size_t soap_flag_srmStatusOfCopyRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfCopyRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse_, sizeof(struct ns1__srmStatusOfCopyRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfCopyRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfCopyRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfCopyRequestResponse(soap, "srmStatusOfCopyRequestResponse", &a->srmStatusOfCopyRequestResponse, "ns1:srmStatusOfCopyRequestResponse"))
				{	soap_flag_srmStatusOfCopyRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfCopyRequestResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse_, 0, sizeof(struct ns1__srmStatusOfCopyRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfCopyRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfCopyRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse_);
	if (soap_out_ns1__srmStatusOfCopyRequestResponse_(soap, tag?tag:"ns1:srmStatusOfCopyRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequestResponse_ * SOAP_FMAC4 soap_get_ns1__srmStatusOfCopyRequestResponse_(struct soap *soap, struct ns1__srmStatusOfCopyRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfCopyRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmCopy(struct soap *soap, struct ns1__srmCopy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmCopyRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmCopy(struct soap *soap, const struct ns1__srmCopy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmCopyRequest(soap, &a->srmCopyRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmCopy(struct soap *soap, const char *tag, int id, const struct ns1__srmCopy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmCopy), type))
		return soap->error;
	if (soap_out_PointerTons1__srmCopyRequest(soap, "srmCopyRequest", -1, &a->srmCopyRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmCopy * SOAP_FMAC4 soap_in_ns1__srmCopy(struct soap *soap, const char *tag, struct ns1__srmCopy *a, const char *type)
{
	size_t soap_flag_srmCopyRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmCopy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmCopy, sizeof(struct ns1__srmCopy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmCopy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmCopyRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmCopyRequest(soap, "srmCopyRequest", &a->srmCopyRequest, "ns1:srmCopyRequest"))
				{	soap_flag_srmCopyRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCopy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmCopy, 0, sizeof(struct ns1__srmCopy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmCopy(struct soap *soap, const struct ns1__srmCopy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmCopy);
	if (soap_out_ns1__srmCopy(soap, tag?tag:"ns1:srmCopy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCopy * SOAP_FMAC4 soap_get_ns1__srmCopy(struct soap *soap, struct ns1__srmCopy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmCopy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmCopyResponse_(struct soap *soap, struct ns1__srmCopyResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmCopyResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmCopyResponse_(struct soap *soap, const struct ns1__srmCopyResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmCopyResponse(soap, &a->srmCopyResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmCopyResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmCopyResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmCopyResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmCopyResponse(soap, "srmCopyResponse", -1, &a->srmCopyResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmCopyResponse_ * SOAP_FMAC4 soap_in_ns1__srmCopyResponse_(struct soap *soap, const char *tag, struct ns1__srmCopyResponse_ *a, const char *type)
{
	size_t soap_flag_srmCopyResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmCopyResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmCopyResponse_, sizeof(struct ns1__srmCopyResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmCopyResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmCopyResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmCopyResponse(soap, "srmCopyResponse", &a->srmCopyResponse, "ns1:srmCopyResponse"))
				{	soap_flag_srmCopyResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCopyResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmCopyResponse_, 0, sizeof(struct ns1__srmCopyResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmCopyResponse_(struct soap *soap, const struct ns1__srmCopyResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmCopyResponse_);
	if (soap_out_ns1__srmCopyResponse_(soap, tag?tag:"ns1:srmCopyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCopyResponse_ * SOAP_FMAC4 soap_get_ns1__srmCopyResponse_(struct soap *soap, struct ns1__srmCopyResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmCopyResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfPutRequest(struct soap *soap, struct ns1__srmStatusOfPutRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfPutRequestRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfPutRequest(struct soap *soap, const struct ns1__srmStatusOfPutRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfPutRequestRequest(soap, &a->srmStatusOfPutRequestRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfPutRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfPutRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfPutRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfPutRequestRequest(soap, "srmStatusOfPutRequestRequest", -1, &a->srmStatusOfPutRequestRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfPutRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfPutRequest *a, const char *type)
{
	size_t soap_flag_srmStatusOfPutRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfPutRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfPutRequest, sizeof(struct ns1__srmStatusOfPutRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfPutRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfPutRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfPutRequestRequest(soap, "srmStatusOfPutRequestRequest", &a->srmStatusOfPutRequestRequest, "ns1:srmStatusOfPutRequestRequest"))
				{	soap_flag_srmStatusOfPutRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfPutRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfPutRequest, 0, sizeof(struct ns1__srmStatusOfPutRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfPutRequest(struct soap *soap, const struct ns1__srmStatusOfPutRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfPutRequest);
	if (soap_out_ns1__srmStatusOfPutRequest(soap, tag?tag:"ns1:srmStatusOfPutRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfPutRequest(struct soap *soap, struct ns1__srmStatusOfPutRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfPutRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfPutRequestResponse_(struct soap *soap, struct ns1__srmStatusOfPutRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfPutRequestResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfPutRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfPutRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfPutRequestResponse(soap, &a->srmStatusOfPutRequestResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfPutRequestResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfPutRequestResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfPutRequestResponse(soap, "srmStatusOfPutRequestResponse", -1, &a->srmStatusOfPutRequestResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequestResponse_ * SOAP_FMAC4 soap_in_ns1__srmStatusOfPutRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfPutRequestResponse_ *a, const char *type)
{
	size_t soap_flag_srmStatusOfPutRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfPutRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse_, sizeof(struct ns1__srmStatusOfPutRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfPutRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfPutRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfPutRequestResponse(soap, "srmStatusOfPutRequestResponse", &a->srmStatusOfPutRequestResponse, "ns1:srmStatusOfPutRequestResponse"))
				{	soap_flag_srmStatusOfPutRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfPutRequestResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse_, 0, sizeof(struct ns1__srmStatusOfPutRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfPutRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfPutRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse_);
	if (soap_out_ns1__srmStatusOfPutRequestResponse_(soap, tag?tag:"ns1:srmStatusOfPutRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequestResponse_ * SOAP_FMAC4 soap_get_ns1__srmStatusOfPutRequestResponse_(struct soap *soap, struct ns1__srmStatusOfPutRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfPutRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPrepareToPut(struct soap *soap, struct ns1__srmPrepareToPut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPrepareToPutRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPrepareToPut(struct soap *soap, const struct ns1__srmPrepareToPut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmPrepareToPutRequest(soap, &a->srmPrepareToPutRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPrepareToPut(struct soap *soap, const char *tag, int id, const struct ns1__srmPrepareToPut *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPrepareToPut), type))
		return soap->error;
	if (soap_out_PointerTons1__srmPrepareToPutRequest(soap, "srmPrepareToPutRequest", -1, &a->srmPrepareToPutRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPrepareToPut * SOAP_FMAC4 soap_in_ns1__srmPrepareToPut(struct soap *soap, const char *tag, struct ns1__srmPrepareToPut *a, const char *type)
{
	size_t soap_flag_srmPrepareToPutRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPrepareToPut *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPrepareToPut, sizeof(struct ns1__srmPrepareToPut), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPrepareToPut(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPrepareToPutRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmPrepareToPutRequest(soap, "srmPrepareToPutRequest", &a->srmPrepareToPutRequest, "ns1:srmPrepareToPutRequest"))
				{	soap_flag_srmPrepareToPutRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToPut *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPrepareToPut, 0, sizeof(struct ns1__srmPrepareToPut), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPrepareToPut(struct soap *soap, const struct ns1__srmPrepareToPut *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPrepareToPut);
	if (soap_out_ns1__srmPrepareToPut(soap, tag?tag:"ns1:srmPrepareToPut", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToPut * SOAP_FMAC4 soap_get_ns1__srmPrepareToPut(struct soap *soap, struct ns1__srmPrepareToPut *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPrepareToPut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPrepareToPutResponse_(struct soap *soap, struct ns1__srmPrepareToPutResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPrepareToPutResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPrepareToPutResponse_(struct soap *soap, const struct ns1__srmPrepareToPutResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmPrepareToPutResponse(soap, &a->srmPrepareToPutResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPrepareToPutResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmPrepareToPutResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPrepareToPutResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmPrepareToPutResponse(soap, "srmPrepareToPutResponse", -1, &a->srmPrepareToPutResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPrepareToPutResponse_ * SOAP_FMAC4 soap_in_ns1__srmPrepareToPutResponse_(struct soap *soap, const char *tag, struct ns1__srmPrepareToPutResponse_ *a, const char *type)
{
	size_t soap_flag_srmPrepareToPutResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPrepareToPutResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPrepareToPutResponse_, sizeof(struct ns1__srmPrepareToPutResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPrepareToPutResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPrepareToPutResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmPrepareToPutResponse(soap, "srmPrepareToPutResponse", &a->srmPrepareToPutResponse, "ns1:srmPrepareToPutResponse"))
				{	soap_flag_srmPrepareToPutResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToPutResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPrepareToPutResponse_, 0, sizeof(struct ns1__srmPrepareToPutResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPrepareToPutResponse_(struct soap *soap, const struct ns1__srmPrepareToPutResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPrepareToPutResponse_);
	if (soap_out_ns1__srmPrepareToPutResponse_(soap, tag?tag:"ns1:srmPrepareToPutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToPutResponse_ * SOAP_FMAC4 soap_get_ns1__srmPrepareToPutResponse_(struct soap *soap, struct ns1__srmPrepareToPutResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPrepareToPutResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfBringOnlineRequest(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfBringOnlineRequestRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfBringOnlineRequest(struct soap *soap, const struct ns1__srmStatusOfBringOnlineRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfBringOnlineRequestRequest(soap, &a->srmStatusOfBringOnlineRequestRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfBringOnlineRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfBringOnlineRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfBringOnlineRequestRequest(soap, "srmStatusOfBringOnlineRequestRequest", -1, &a->srmStatusOfBringOnlineRequestRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfBringOnlineRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfBringOnlineRequest *a, const char *type)
{
	size_t soap_flag_srmStatusOfBringOnlineRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfBringOnlineRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequest, sizeof(struct ns1__srmStatusOfBringOnlineRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfBringOnlineRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfBringOnlineRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfBringOnlineRequestRequest(soap, "srmStatusOfBringOnlineRequestRequest", &a->srmStatusOfBringOnlineRequestRequest, "ns1:srmStatusOfBringOnlineRequestRequest"))
				{	soap_flag_srmStatusOfBringOnlineRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfBringOnlineRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequest, 0, sizeof(struct ns1__srmStatusOfBringOnlineRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfBringOnlineRequest(struct soap *soap, const struct ns1__srmStatusOfBringOnlineRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequest);
	if (soap_out_ns1__srmStatusOfBringOnlineRequest(soap, tag?tag:"ns1:srmStatusOfBringOnlineRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfBringOnlineRequest(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfBringOnlineRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfBringOnlineRequestResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfBringOnlineRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfBringOnlineRequestResponse(soap, &a->srmStatusOfBringOnlineRequestResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfBringOnlineRequestResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfBringOnlineRequestResponse(soap, "srmStatusOfBringOnlineRequestResponse", -1, &a->srmStatusOfBringOnlineRequestResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequestResponse_ * SOAP_FMAC4 soap_in_ns1__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfBringOnlineRequestResponse_ *a, const char *type)
{
	size_t soap_flag_srmStatusOfBringOnlineRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfBringOnlineRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse_, sizeof(struct ns1__srmStatusOfBringOnlineRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfBringOnlineRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfBringOnlineRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfBringOnlineRequestResponse(soap, "srmStatusOfBringOnlineRequestResponse", &a->srmStatusOfBringOnlineRequestResponse, "ns1:srmStatusOfBringOnlineRequestResponse"))
				{	soap_flag_srmStatusOfBringOnlineRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfBringOnlineRequestResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse_, 0, sizeof(struct ns1__srmStatusOfBringOnlineRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfBringOnlineRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse_);
	if (soap_out_ns1__srmStatusOfBringOnlineRequestResponse_(soap, tag?tag:"ns1:srmStatusOfBringOnlineRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequestResponse_ * SOAP_FMAC4 soap_get_ns1__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfBringOnlineRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmBringOnline(struct soap *soap, struct ns1__srmBringOnline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmBringOnlineRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmBringOnline(struct soap *soap, const struct ns1__srmBringOnline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmBringOnlineRequest(soap, &a->srmBringOnlineRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmBringOnline(struct soap *soap, const char *tag, int id, const struct ns1__srmBringOnline *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmBringOnline), type))
		return soap->error;
	if (soap_out_PointerTons1__srmBringOnlineRequest(soap, "srmBringOnlineRequest", -1, &a->srmBringOnlineRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmBringOnline * SOAP_FMAC4 soap_in_ns1__srmBringOnline(struct soap *soap, const char *tag, struct ns1__srmBringOnline *a, const char *type)
{
	size_t soap_flag_srmBringOnlineRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmBringOnline *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmBringOnline, sizeof(struct ns1__srmBringOnline), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmBringOnline(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmBringOnlineRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmBringOnlineRequest(soap, "srmBringOnlineRequest", &a->srmBringOnlineRequest, "ns1:srmBringOnlineRequest"))
				{	soap_flag_srmBringOnlineRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmBringOnline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmBringOnline, 0, sizeof(struct ns1__srmBringOnline), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmBringOnline(struct soap *soap, const struct ns1__srmBringOnline *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmBringOnline);
	if (soap_out_ns1__srmBringOnline(soap, tag?tag:"ns1:srmBringOnline", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmBringOnline * SOAP_FMAC4 soap_get_ns1__srmBringOnline(struct soap *soap, struct ns1__srmBringOnline *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmBringOnline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmBringOnlineResponse_(struct soap *soap, struct ns1__srmBringOnlineResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmBringOnlineResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmBringOnlineResponse_(struct soap *soap, const struct ns1__srmBringOnlineResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmBringOnlineResponse(soap, &a->srmBringOnlineResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmBringOnlineResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmBringOnlineResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmBringOnlineResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmBringOnlineResponse(soap, "srmBringOnlineResponse", -1, &a->srmBringOnlineResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmBringOnlineResponse_ * SOAP_FMAC4 soap_in_ns1__srmBringOnlineResponse_(struct soap *soap, const char *tag, struct ns1__srmBringOnlineResponse_ *a, const char *type)
{
	size_t soap_flag_srmBringOnlineResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmBringOnlineResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmBringOnlineResponse_, sizeof(struct ns1__srmBringOnlineResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmBringOnlineResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmBringOnlineResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmBringOnlineResponse(soap, "srmBringOnlineResponse", &a->srmBringOnlineResponse, "ns1:srmBringOnlineResponse"))
				{	soap_flag_srmBringOnlineResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmBringOnlineResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmBringOnlineResponse_, 0, sizeof(struct ns1__srmBringOnlineResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmBringOnlineResponse_(struct soap *soap, const struct ns1__srmBringOnlineResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmBringOnlineResponse_);
	if (soap_out_ns1__srmBringOnlineResponse_(soap, tag?tag:"ns1:srmBringOnlineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmBringOnlineResponse_ * SOAP_FMAC4 soap_get_ns1__srmBringOnlineResponse_(struct soap *soap, struct ns1__srmBringOnlineResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmBringOnlineResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfGetRequest(struct soap *soap, struct ns1__srmStatusOfGetRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfGetRequestRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfGetRequest(struct soap *soap, const struct ns1__srmStatusOfGetRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfGetRequestRequest(soap, &a->srmStatusOfGetRequestRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfGetRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfGetRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfGetRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfGetRequestRequest(soap, "srmStatusOfGetRequestRequest", -1, &a->srmStatusOfGetRequestRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfGetRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfGetRequest *a, const char *type)
{
	size_t soap_flag_srmStatusOfGetRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfGetRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfGetRequest, sizeof(struct ns1__srmStatusOfGetRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfGetRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfGetRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfGetRequestRequest(soap, "srmStatusOfGetRequestRequest", &a->srmStatusOfGetRequestRequest, "ns1:srmStatusOfGetRequestRequest"))
				{	soap_flag_srmStatusOfGetRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfGetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfGetRequest, 0, sizeof(struct ns1__srmStatusOfGetRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfGetRequest(struct soap *soap, const struct ns1__srmStatusOfGetRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfGetRequest);
	if (soap_out_ns1__srmStatusOfGetRequest(soap, tag?tag:"ns1:srmStatusOfGetRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfGetRequest(struct soap *soap, struct ns1__srmStatusOfGetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfGetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfGetRequestResponse_(struct soap *soap, struct ns1__srmStatusOfGetRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfGetRequestResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfGetRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfGetRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfGetRequestResponse(soap, &a->srmStatusOfGetRequestResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfGetRequestResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfGetRequestResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfGetRequestResponse(soap, "srmStatusOfGetRequestResponse", -1, &a->srmStatusOfGetRequestResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequestResponse_ * SOAP_FMAC4 soap_in_ns1__srmStatusOfGetRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfGetRequestResponse_ *a, const char *type)
{
	size_t soap_flag_srmStatusOfGetRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfGetRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse_, sizeof(struct ns1__srmStatusOfGetRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfGetRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfGetRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfGetRequestResponse(soap, "srmStatusOfGetRequestResponse", &a->srmStatusOfGetRequestResponse, "ns1:srmStatusOfGetRequestResponse"))
				{	soap_flag_srmStatusOfGetRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfGetRequestResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse_, 0, sizeof(struct ns1__srmStatusOfGetRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfGetRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfGetRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse_);
	if (soap_out_ns1__srmStatusOfGetRequestResponse_(soap, tag?tag:"ns1:srmStatusOfGetRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequestResponse_ * SOAP_FMAC4 soap_get_ns1__srmStatusOfGetRequestResponse_(struct soap *soap, struct ns1__srmStatusOfGetRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfGetRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPrepareToGet(struct soap *soap, struct ns1__srmPrepareToGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPrepareToGetRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPrepareToGet(struct soap *soap, const struct ns1__srmPrepareToGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmPrepareToGetRequest(soap, &a->srmPrepareToGetRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPrepareToGet(struct soap *soap, const char *tag, int id, const struct ns1__srmPrepareToGet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPrepareToGet), type))
		return soap->error;
	if (soap_out_PointerTons1__srmPrepareToGetRequest(soap, "srmPrepareToGetRequest", -1, &a->srmPrepareToGetRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPrepareToGet * SOAP_FMAC4 soap_in_ns1__srmPrepareToGet(struct soap *soap, const char *tag, struct ns1__srmPrepareToGet *a, const char *type)
{
	size_t soap_flag_srmPrepareToGetRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPrepareToGet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPrepareToGet, sizeof(struct ns1__srmPrepareToGet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPrepareToGet(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPrepareToGetRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmPrepareToGetRequest(soap, "srmPrepareToGetRequest", &a->srmPrepareToGetRequest, "ns1:srmPrepareToGetRequest"))
				{	soap_flag_srmPrepareToGetRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPrepareToGet, 0, sizeof(struct ns1__srmPrepareToGet), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPrepareToGet(struct soap *soap, const struct ns1__srmPrepareToGet *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPrepareToGet);
	if (soap_out_ns1__srmPrepareToGet(soap, tag?tag:"ns1:srmPrepareToGet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToGet * SOAP_FMAC4 soap_get_ns1__srmPrepareToGet(struct soap *soap, struct ns1__srmPrepareToGet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPrepareToGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPrepareToGetResponse_(struct soap *soap, struct ns1__srmPrepareToGetResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPrepareToGetResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPrepareToGetResponse_(struct soap *soap, const struct ns1__srmPrepareToGetResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmPrepareToGetResponse(soap, &a->srmPrepareToGetResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPrepareToGetResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmPrepareToGetResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPrepareToGetResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmPrepareToGetResponse(soap, "srmPrepareToGetResponse", -1, &a->srmPrepareToGetResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPrepareToGetResponse_ * SOAP_FMAC4 soap_in_ns1__srmPrepareToGetResponse_(struct soap *soap, const char *tag, struct ns1__srmPrepareToGetResponse_ *a, const char *type)
{
	size_t soap_flag_srmPrepareToGetResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPrepareToGetResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPrepareToGetResponse_, sizeof(struct ns1__srmPrepareToGetResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPrepareToGetResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPrepareToGetResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmPrepareToGetResponse(soap, "srmPrepareToGetResponse", &a->srmPrepareToGetResponse, "ns1:srmPrepareToGetResponse"))
				{	soap_flag_srmPrepareToGetResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToGetResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPrepareToGetResponse_, 0, sizeof(struct ns1__srmPrepareToGetResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPrepareToGetResponse_(struct soap *soap, const struct ns1__srmPrepareToGetResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPrepareToGetResponse_);
	if (soap_out_ns1__srmPrepareToGetResponse_(soap, tag?tag:"ns1:srmPrepareToGetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToGetResponse_ * SOAP_FMAC4 soap_get_ns1__srmPrepareToGetResponse_(struct soap *soap, struct ns1__srmPrepareToGetResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPrepareToGetResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmMv(struct soap *soap, struct ns1__srmMv *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmMvRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmMv(struct soap *soap, const struct ns1__srmMv *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmMvRequest(soap, &a->srmMvRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmMv(struct soap *soap, const char *tag, int id, const struct ns1__srmMv *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmMv), type))
		return soap->error;
	if (soap_out_PointerTons1__srmMvRequest(soap, "srmMvRequest", -1, &a->srmMvRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmMv * SOAP_FMAC4 soap_in_ns1__srmMv(struct soap *soap, const char *tag, struct ns1__srmMv *a, const char *type)
{
	size_t soap_flag_srmMvRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmMv *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmMv, sizeof(struct ns1__srmMv), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmMv(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmMvRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmMvRequest(soap, "srmMvRequest", &a->srmMvRequest, "ns1:srmMvRequest"))
				{	soap_flag_srmMvRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMv *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmMv, 0, sizeof(struct ns1__srmMv), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmMv(struct soap *soap, const struct ns1__srmMv *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmMv);
	if (soap_out_ns1__srmMv(soap, tag?tag:"ns1:srmMv", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMv * SOAP_FMAC4 soap_get_ns1__srmMv(struct soap *soap, struct ns1__srmMv *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmMv(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmMvResponse_(struct soap *soap, struct ns1__srmMvResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmMvResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmMvResponse_(struct soap *soap, const struct ns1__srmMvResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmMvResponse(soap, &a->srmMvResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmMvResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmMvResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmMvResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmMvResponse(soap, "srmMvResponse", -1, &a->srmMvResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmMvResponse_ * SOAP_FMAC4 soap_in_ns1__srmMvResponse_(struct soap *soap, const char *tag, struct ns1__srmMvResponse_ *a, const char *type)
{
	size_t soap_flag_srmMvResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmMvResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmMvResponse_, sizeof(struct ns1__srmMvResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmMvResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmMvResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmMvResponse(soap, "srmMvResponse", &a->srmMvResponse, "ns1:srmMvResponse"))
				{	soap_flag_srmMvResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMvResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmMvResponse_, 0, sizeof(struct ns1__srmMvResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmMvResponse_(struct soap *soap, const struct ns1__srmMvResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmMvResponse_);
	if (soap_out_ns1__srmMvResponse_(soap, tag?tag:"ns1:srmMvResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMvResponse_ * SOAP_FMAC4 soap_get_ns1__srmMvResponse_(struct soap *soap, struct ns1__srmMvResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmMvResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfLsRequest(struct soap *soap, struct ns1__srmStatusOfLsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfLsRequestRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfLsRequest(struct soap *soap, const struct ns1__srmStatusOfLsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfLsRequestRequest(soap, &a->srmStatusOfLsRequestRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfLsRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfLsRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfLsRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfLsRequestRequest(soap, "srmStatusOfLsRequestRequest", -1, &a->srmStatusOfLsRequestRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfLsRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfLsRequest *a, const char *type)
{
	size_t soap_flag_srmStatusOfLsRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfLsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfLsRequest, sizeof(struct ns1__srmStatusOfLsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfLsRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfLsRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfLsRequestRequest(soap, "srmStatusOfLsRequestRequest", &a->srmStatusOfLsRequestRequest, "ns1:srmStatusOfLsRequestRequest"))
				{	soap_flag_srmStatusOfLsRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfLsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfLsRequest, 0, sizeof(struct ns1__srmStatusOfLsRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfLsRequest(struct soap *soap, const struct ns1__srmStatusOfLsRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfLsRequest);
	if (soap_out_ns1__srmStatusOfLsRequest(soap, tag?tag:"ns1:srmStatusOfLsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfLsRequest(struct soap *soap, struct ns1__srmStatusOfLsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfLsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfLsRequestResponse_(struct soap *soap, struct ns1__srmStatusOfLsRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfLsRequestResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfLsRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfLsRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfLsRequestResponse(soap, &a->srmStatusOfLsRequestResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfLsRequestResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfLsRequestResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfLsRequestResponse(soap, "srmStatusOfLsRequestResponse", -1, &a->srmStatusOfLsRequestResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequestResponse_ * SOAP_FMAC4 soap_in_ns1__srmStatusOfLsRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfLsRequestResponse_ *a, const char *type)
{
	size_t soap_flag_srmStatusOfLsRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfLsRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse_, sizeof(struct ns1__srmStatusOfLsRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfLsRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfLsRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfLsRequestResponse(soap, "srmStatusOfLsRequestResponse", &a->srmStatusOfLsRequestResponse, "ns1:srmStatusOfLsRequestResponse"))
				{	soap_flag_srmStatusOfLsRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfLsRequestResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse_, 0, sizeof(struct ns1__srmStatusOfLsRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfLsRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfLsRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse_);
	if (soap_out_ns1__srmStatusOfLsRequestResponse_(soap, tag?tag:"ns1:srmStatusOfLsRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequestResponse_ * SOAP_FMAC4 soap_get_ns1__srmStatusOfLsRequestResponse_(struct soap *soap, struct ns1__srmStatusOfLsRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfLsRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmLs(struct soap *soap, struct ns1__srmLs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmLsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmLs(struct soap *soap, const struct ns1__srmLs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmLsRequest(soap, &a->srmLsRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmLs(struct soap *soap, const char *tag, int id, const struct ns1__srmLs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmLs), type))
		return soap->error;
	if (soap_out_PointerTons1__srmLsRequest(soap, "srmLsRequest", -1, &a->srmLsRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmLs * SOAP_FMAC4 soap_in_ns1__srmLs(struct soap *soap, const char *tag, struct ns1__srmLs *a, const char *type)
{
	size_t soap_flag_srmLsRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmLs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmLs, sizeof(struct ns1__srmLs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmLs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmLsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmLsRequest(soap, "srmLsRequest", &a->srmLsRequest, "ns1:srmLsRequest"))
				{	soap_flag_srmLsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmLs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmLs, 0, sizeof(struct ns1__srmLs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmLs(struct soap *soap, const struct ns1__srmLs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmLs);
	if (soap_out_ns1__srmLs(soap, tag?tag:"ns1:srmLs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmLs * SOAP_FMAC4 soap_get_ns1__srmLs(struct soap *soap, struct ns1__srmLs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmLs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmLsResponse_(struct soap *soap, struct ns1__srmLsResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmLsResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmLsResponse_(struct soap *soap, const struct ns1__srmLsResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmLsResponse(soap, &a->srmLsResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmLsResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmLsResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmLsResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmLsResponse(soap, "srmLsResponse", -1, &a->srmLsResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmLsResponse_ * SOAP_FMAC4 soap_in_ns1__srmLsResponse_(struct soap *soap, const char *tag, struct ns1__srmLsResponse_ *a, const char *type)
{
	size_t soap_flag_srmLsResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmLsResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmLsResponse_, sizeof(struct ns1__srmLsResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmLsResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmLsResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmLsResponse(soap, "srmLsResponse", &a->srmLsResponse, "ns1:srmLsResponse"))
				{	soap_flag_srmLsResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmLsResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmLsResponse_, 0, sizeof(struct ns1__srmLsResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmLsResponse_(struct soap *soap, const struct ns1__srmLsResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmLsResponse_);
	if (soap_out_ns1__srmLsResponse_(soap, tag?tag:"ns1:srmLsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmLsResponse_ * SOAP_FMAC4 soap_get_ns1__srmLsResponse_(struct soap *soap, struct ns1__srmLsResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmLsResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmRm(struct soap *soap, struct ns1__srmRm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmRmRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmRm(struct soap *soap, const struct ns1__srmRm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmRmRequest(soap, &a->srmRmRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmRm(struct soap *soap, const char *tag, int id, const struct ns1__srmRm *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmRm), type))
		return soap->error;
	if (soap_out_PointerTons1__srmRmRequest(soap, "srmRmRequest", -1, &a->srmRmRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmRm * SOAP_FMAC4 soap_in_ns1__srmRm(struct soap *soap, const char *tag, struct ns1__srmRm *a, const char *type)
{
	size_t soap_flag_srmRmRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmRm *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmRm, sizeof(struct ns1__srmRm), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmRm(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmRmRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmRmRequest(soap, "srmRmRequest", &a->srmRmRequest, "ns1:srmRmRequest"))
				{	soap_flag_srmRmRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmRm, 0, sizeof(struct ns1__srmRm), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmRm(struct soap *soap, const struct ns1__srmRm *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmRm);
	if (soap_out_ns1__srmRm(soap, tag?tag:"ns1:srmRm", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRm * SOAP_FMAC4 soap_get_ns1__srmRm(struct soap *soap, struct ns1__srmRm *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmRm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmRmResponse_(struct soap *soap, struct ns1__srmRmResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmRmResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmRmResponse_(struct soap *soap, const struct ns1__srmRmResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmRmResponse(soap, &a->srmRmResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmRmResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmRmResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmRmResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmRmResponse(soap, "srmRmResponse", -1, &a->srmRmResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmRmResponse_ * SOAP_FMAC4 soap_in_ns1__srmRmResponse_(struct soap *soap, const char *tag, struct ns1__srmRmResponse_ *a, const char *type)
{
	size_t soap_flag_srmRmResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmRmResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmRmResponse_, sizeof(struct ns1__srmRmResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmRmResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmRmResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmRmResponse(soap, "srmRmResponse", &a->srmRmResponse, "ns1:srmRmResponse"))
				{	soap_flag_srmRmResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmRmResponse_, 0, sizeof(struct ns1__srmRmResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmRmResponse_(struct soap *soap, const struct ns1__srmRmResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmRmResponse_);
	if (soap_out_ns1__srmRmResponse_(soap, tag?tag:"ns1:srmRmResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmResponse_ * SOAP_FMAC4 soap_get_ns1__srmRmResponse_(struct soap *soap, struct ns1__srmRmResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmRmResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmRmdir(struct soap *soap, struct ns1__srmRmdir *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmRmdirRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmRmdir(struct soap *soap, const struct ns1__srmRmdir *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmRmdirRequest(soap, &a->srmRmdirRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmRmdir(struct soap *soap, const char *tag, int id, const struct ns1__srmRmdir *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmRmdir), type))
		return soap->error;
	if (soap_out_PointerTons1__srmRmdirRequest(soap, "srmRmdirRequest", -1, &a->srmRmdirRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmRmdir * SOAP_FMAC4 soap_in_ns1__srmRmdir(struct soap *soap, const char *tag, struct ns1__srmRmdir *a, const char *type)
{
	size_t soap_flag_srmRmdirRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmRmdir *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmRmdir, sizeof(struct ns1__srmRmdir), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmRmdir(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmRmdirRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmRmdirRequest(soap, "srmRmdirRequest", &a->srmRmdirRequest, "ns1:srmRmdirRequest"))
				{	soap_flag_srmRmdirRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmdir *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmRmdir, 0, sizeof(struct ns1__srmRmdir), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmRmdir(struct soap *soap, const struct ns1__srmRmdir *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmRmdir);
	if (soap_out_ns1__srmRmdir(soap, tag?tag:"ns1:srmRmdir", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmdir * SOAP_FMAC4 soap_get_ns1__srmRmdir(struct soap *soap, struct ns1__srmRmdir *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmRmdir(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmRmdirResponse_(struct soap *soap, struct ns1__srmRmdirResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmRmdirResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmRmdirResponse_(struct soap *soap, const struct ns1__srmRmdirResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmRmdirResponse(soap, &a->srmRmdirResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmRmdirResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmRmdirResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmRmdirResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmRmdirResponse(soap, "srmRmdirResponse", -1, &a->srmRmdirResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmRmdirResponse_ * SOAP_FMAC4 soap_in_ns1__srmRmdirResponse_(struct soap *soap, const char *tag, struct ns1__srmRmdirResponse_ *a, const char *type)
{
	size_t soap_flag_srmRmdirResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmRmdirResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmRmdirResponse_, sizeof(struct ns1__srmRmdirResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmRmdirResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmRmdirResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmRmdirResponse(soap, "srmRmdirResponse", &a->srmRmdirResponse, "ns1:srmRmdirResponse"))
				{	soap_flag_srmRmdirResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmdirResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmRmdirResponse_, 0, sizeof(struct ns1__srmRmdirResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmRmdirResponse_(struct soap *soap, const struct ns1__srmRmdirResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmRmdirResponse_);
	if (soap_out_ns1__srmRmdirResponse_(soap, tag?tag:"ns1:srmRmdirResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmdirResponse_ * SOAP_FMAC4 soap_get_ns1__srmRmdirResponse_(struct soap *soap, struct ns1__srmRmdirResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmRmdirResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmMkdir(struct soap *soap, struct ns1__srmMkdir *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmMkdirRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmMkdir(struct soap *soap, const struct ns1__srmMkdir *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmMkdirRequest(soap, &a->srmMkdirRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmMkdir(struct soap *soap, const char *tag, int id, const struct ns1__srmMkdir *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmMkdir), type))
		return soap->error;
	if (soap_out_PointerTons1__srmMkdirRequest(soap, "srmMkdirRequest", -1, &a->srmMkdirRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmMkdir * SOAP_FMAC4 soap_in_ns1__srmMkdir(struct soap *soap, const char *tag, struct ns1__srmMkdir *a, const char *type)
{
	size_t soap_flag_srmMkdirRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmMkdir *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmMkdir, sizeof(struct ns1__srmMkdir), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmMkdir(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmMkdirRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmMkdirRequest(soap, "srmMkdirRequest", &a->srmMkdirRequest, "ns1:srmMkdirRequest"))
				{	soap_flag_srmMkdirRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMkdir *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmMkdir, 0, sizeof(struct ns1__srmMkdir), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmMkdir(struct soap *soap, const struct ns1__srmMkdir *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmMkdir);
	if (soap_out_ns1__srmMkdir(soap, tag?tag:"ns1:srmMkdir", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMkdir * SOAP_FMAC4 soap_get_ns1__srmMkdir(struct soap *soap, struct ns1__srmMkdir *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmMkdir(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmMkdirResponse_(struct soap *soap, struct ns1__srmMkdirResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmMkdirResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmMkdirResponse_(struct soap *soap, const struct ns1__srmMkdirResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmMkdirResponse(soap, &a->srmMkdirResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmMkdirResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmMkdirResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmMkdirResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmMkdirResponse(soap, "srmMkdirResponse", -1, &a->srmMkdirResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmMkdirResponse_ * SOAP_FMAC4 soap_in_ns1__srmMkdirResponse_(struct soap *soap, const char *tag, struct ns1__srmMkdirResponse_ *a, const char *type)
{
	size_t soap_flag_srmMkdirResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmMkdirResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmMkdirResponse_, sizeof(struct ns1__srmMkdirResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmMkdirResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmMkdirResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmMkdirResponse(soap, "srmMkdirResponse", &a->srmMkdirResponse, "ns1:srmMkdirResponse"))
				{	soap_flag_srmMkdirResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMkdirResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmMkdirResponse_, 0, sizeof(struct ns1__srmMkdirResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmMkdirResponse_(struct soap *soap, const struct ns1__srmMkdirResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmMkdirResponse_);
	if (soap_out_ns1__srmMkdirResponse_(soap, tag?tag:"ns1:srmMkdirResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMkdirResponse_ * SOAP_FMAC4 soap_get_ns1__srmMkdirResponse_(struct soap *soap, struct ns1__srmMkdirResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmMkdirResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetPermission(struct soap *soap, struct ns1__srmGetPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetPermissionRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetPermission(struct soap *soap, const struct ns1__srmGetPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmGetPermissionRequest(soap, &a->srmGetPermissionRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetPermission(struct soap *soap, const char *tag, int id, const struct ns1__srmGetPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetPermission), type))
		return soap->error;
	if (soap_out_PointerTons1__srmGetPermissionRequest(soap, "srmGetPermissionRequest", -1, &a->srmGetPermissionRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetPermission * SOAP_FMAC4 soap_in_ns1__srmGetPermission(struct soap *soap, const char *tag, struct ns1__srmGetPermission *a, const char *type)
{
	size_t soap_flag_srmGetPermissionRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetPermission, sizeof(struct ns1__srmGetPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetPermissionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmGetPermissionRequest(soap, "srmGetPermissionRequest", &a->srmGetPermissionRequest, "ns1:srmGetPermissionRequest"))
				{	soap_flag_srmGetPermissionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetPermission, 0, sizeof(struct ns1__srmGetPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetPermission(struct soap *soap, const struct ns1__srmGetPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetPermission);
	if (soap_out_ns1__srmGetPermission(soap, tag?tag:"ns1:srmGetPermission", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetPermission * SOAP_FMAC4 soap_get_ns1__srmGetPermission(struct soap *soap, struct ns1__srmGetPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetPermissionResponse_(struct soap *soap, struct ns1__srmGetPermissionResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetPermissionResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetPermissionResponse_(struct soap *soap, const struct ns1__srmGetPermissionResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmGetPermissionResponse(soap, &a->srmGetPermissionResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetPermissionResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmGetPermissionResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetPermissionResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmGetPermissionResponse(soap, "srmGetPermissionResponse", -1, &a->srmGetPermissionResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetPermissionResponse_ * SOAP_FMAC4 soap_in_ns1__srmGetPermissionResponse_(struct soap *soap, const char *tag, struct ns1__srmGetPermissionResponse_ *a, const char *type)
{
	size_t soap_flag_srmGetPermissionResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetPermissionResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetPermissionResponse_, sizeof(struct ns1__srmGetPermissionResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetPermissionResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetPermissionResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmGetPermissionResponse(soap, "srmGetPermissionResponse", &a->srmGetPermissionResponse, "ns1:srmGetPermissionResponse"))
				{	soap_flag_srmGetPermissionResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetPermissionResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetPermissionResponse_, 0, sizeof(struct ns1__srmGetPermissionResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetPermissionResponse_(struct soap *soap, const struct ns1__srmGetPermissionResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetPermissionResponse_);
	if (soap_out_ns1__srmGetPermissionResponse_(soap, tag?tag:"ns1:srmGetPermissionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetPermissionResponse_ * SOAP_FMAC4 soap_get_ns1__srmGetPermissionResponse_(struct soap *soap, struct ns1__srmGetPermissionResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetPermissionResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmCheckPermission(struct soap *soap, struct ns1__srmCheckPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmCheckPermissionRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmCheckPermission(struct soap *soap, const struct ns1__srmCheckPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmCheckPermissionRequest(soap, &a->srmCheckPermissionRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmCheckPermission(struct soap *soap, const char *tag, int id, const struct ns1__srmCheckPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmCheckPermission), type))
		return soap->error;
	if (soap_out_PointerTons1__srmCheckPermissionRequest(soap, "srmCheckPermissionRequest", -1, &a->srmCheckPermissionRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmCheckPermission * SOAP_FMAC4 soap_in_ns1__srmCheckPermission(struct soap *soap, const char *tag, struct ns1__srmCheckPermission *a, const char *type)
{
	size_t soap_flag_srmCheckPermissionRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmCheckPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmCheckPermission, sizeof(struct ns1__srmCheckPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmCheckPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmCheckPermissionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmCheckPermissionRequest(soap, "srmCheckPermissionRequest", &a->srmCheckPermissionRequest, "ns1:srmCheckPermissionRequest"))
				{	soap_flag_srmCheckPermissionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCheckPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmCheckPermission, 0, sizeof(struct ns1__srmCheckPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmCheckPermission(struct soap *soap, const struct ns1__srmCheckPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmCheckPermission);
	if (soap_out_ns1__srmCheckPermission(soap, tag?tag:"ns1:srmCheckPermission", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCheckPermission * SOAP_FMAC4 soap_get_ns1__srmCheckPermission(struct soap *soap, struct ns1__srmCheckPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmCheckPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmCheckPermissionResponse_(struct soap *soap, struct ns1__srmCheckPermissionResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmCheckPermissionResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmCheckPermissionResponse_(struct soap *soap, const struct ns1__srmCheckPermissionResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmCheckPermissionResponse(soap, &a->srmCheckPermissionResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmCheckPermissionResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmCheckPermissionResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmCheckPermissionResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmCheckPermissionResponse(soap, "srmCheckPermissionResponse", -1, &a->srmCheckPermissionResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmCheckPermissionResponse_ * SOAP_FMAC4 soap_in_ns1__srmCheckPermissionResponse_(struct soap *soap, const char *tag, struct ns1__srmCheckPermissionResponse_ *a, const char *type)
{
	size_t soap_flag_srmCheckPermissionResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmCheckPermissionResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmCheckPermissionResponse_, sizeof(struct ns1__srmCheckPermissionResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmCheckPermissionResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmCheckPermissionResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmCheckPermissionResponse(soap, "srmCheckPermissionResponse", &a->srmCheckPermissionResponse, "ns1:srmCheckPermissionResponse"))
				{	soap_flag_srmCheckPermissionResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCheckPermissionResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmCheckPermissionResponse_, 0, sizeof(struct ns1__srmCheckPermissionResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmCheckPermissionResponse_(struct soap *soap, const struct ns1__srmCheckPermissionResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmCheckPermissionResponse_);
	if (soap_out_ns1__srmCheckPermissionResponse_(soap, tag?tag:"ns1:srmCheckPermissionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCheckPermissionResponse_ * SOAP_FMAC4 soap_get_ns1__srmCheckPermissionResponse_(struct soap *soap, struct ns1__srmCheckPermissionResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmCheckPermissionResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmSetPermission(struct soap *soap, struct ns1__srmSetPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmSetPermissionRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmSetPermission(struct soap *soap, const struct ns1__srmSetPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmSetPermissionRequest(soap, &a->srmSetPermissionRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmSetPermission(struct soap *soap, const char *tag, int id, const struct ns1__srmSetPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmSetPermission), type))
		return soap->error;
	if (soap_out_PointerTons1__srmSetPermissionRequest(soap, "srmSetPermissionRequest", -1, &a->srmSetPermissionRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmSetPermission * SOAP_FMAC4 soap_in_ns1__srmSetPermission(struct soap *soap, const char *tag, struct ns1__srmSetPermission *a, const char *type)
{
	size_t soap_flag_srmSetPermissionRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmSetPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmSetPermission, sizeof(struct ns1__srmSetPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmSetPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmSetPermissionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmSetPermissionRequest(soap, "srmSetPermissionRequest", &a->srmSetPermissionRequest, "ns1:srmSetPermissionRequest"))
				{	soap_flag_srmSetPermissionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSetPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmSetPermission, 0, sizeof(struct ns1__srmSetPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmSetPermission(struct soap *soap, const struct ns1__srmSetPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmSetPermission);
	if (soap_out_ns1__srmSetPermission(soap, tag?tag:"ns1:srmSetPermission", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSetPermission * SOAP_FMAC4 soap_get_ns1__srmSetPermission(struct soap *soap, struct ns1__srmSetPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmSetPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmSetPermissionResponse_(struct soap *soap, struct ns1__srmSetPermissionResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmSetPermissionResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmSetPermissionResponse_(struct soap *soap, const struct ns1__srmSetPermissionResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmSetPermissionResponse(soap, &a->srmSetPermissionResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmSetPermissionResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmSetPermissionResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmSetPermissionResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmSetPermissionResponse(soap, "srmSetPermissionResponse", -1, &a->srmSetPermissionResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmSetPermissionResponse_ * SOAP_FMAC4 soap_in_ns1__srmSetPermissionResponse_(struct soap *soap, const char *tag, struct ns1__srmSetPermissionResponse_ *a, const char *type)
{
	size_t soap_flag_srmSetPermissionResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmSetPermissionResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmSetPermissionResponse_, sizeof(struct ns1__srmSetPermissionResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmSetPermissionResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmSetPermissionResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmSetPermissionResponse(soap, "srmSetPermissionResponse", &a->srmSetPermissionResponse, "ns1:srmSetPermissionResponse"))
				{	soap_flag_srmSetPermissionResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSetPermissionResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmSetPermissionResponse_, 0, sizeof(struct ns1__srmSetPermissionResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmSetPermissionResponse_(struct soap *soap, const struct ns1__srmSetPermissionResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmSetPermissionResponse_);
	if (soap_out_ns1__srmSetPermissionResponse_(soap, tag?tag:"ns1:srmSetPermissionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSetPermissionResponse_ * SOAP_FMAC4 soap_get_ns1__srmSetPermissionResponse_(struct soap *soap, struct ns1__srmSetPermissionResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmSetPermissionResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetSpaceTokens(struct soap *soap, struct ns1__srmGetSpaceTokens *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetSpaceTokensRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetSpaceTokens(struct soap *soap, const struct ns1__srmGetSpaceTokens *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmGetSpaceTokensRequest(soap, &a->srmGetSpaceTokensRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetSpaceTokens(struct soap *soap, const char *tag, int id, const struct ns1__srmGetSpaceTokens *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetSpaceTokens), type))
		return soap->error;
	if (soap_out_PointerTons1__srmGetSpaceTokensRequest(soap, "srmGetSpaceTokensRequest", -1, &a->srmGetSpaceTokensRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokens * SOAP_FMAC4 soap_in_ns1__srmGetSpaceTokens(struct soap *soap, const char *tag, struct ns1__srmGetSpaceTokens *a, const char *type)
{
	size_t soap_flag_srmGetSpaceTokensRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetSpaceTokens *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetSpaceTokens, sizeof(struct ns1__srmGetSpaceTokens), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetSpaceTokens(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetSpaceTokensRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmGetSpaceTokensRequest(soap, "srmGetSpaceTokensRequest", &a->srmGetSpaceTokensRequest, "ns1:srmGetSpaceTokensRequest"))
				{	soap_flag_srmGetSpaceTokensRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceTokens *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetSpaceTokens, 0, sizeof(struct ns1__srmGetSpaceTokens), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetSpaceTokens(struct soap *soap, const struct ns1__srmGetSpaceTokens *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetSpaceTokens);
	if (soap_out_ns1__srmGetSpaceTokens(soap, tag?tag:"ns1:srmGetSpaceTokens", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokens * SOAP_FMAC4 soap_get_ns1__srmGetSpaceTokens(struct soap *soap, struct ns1__srmGetSpaceTokens *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetSpaceTokens(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetSpaceTokensResponse_(struct soap *soap, struct ns1__srmGetSpaceTokensResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetSpaceTokensResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetSpaceTokensResponse_(struct soap *soap, const struct ns1__srmGetSpaceTokensResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmGetSpaceTokensResponse(soap, &a->srmGetSpaceTokensResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetSpaceTokensResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmGetSpaceTokensResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetSpaceTokensResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmGetSpaceTokensResponse(soap, "srmGetSpaceTokensResponse", -1, &a->srmGetSpaceTokensResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokensResponse_ * SOAP_FMAC4 soap_in_ns1__srmGetSpaceTokensResponse_(struct soap *soap, const char *tag, struct ns1__srmGetSpaceTokensResponse_ *a, const char *type)
{
	size_t soap_flag_srmGetSpaceTokensResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetSpaceTokensResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetSpaceTokensResponse_, sizeof(struct ns1__srmGetSpaceTokensResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetSpaceTokensResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetSpaceTokensResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmGetSpaceTokensResponse(soap, "srmGetSpaceTokensResponse", &a->srmGetSpaceTokensResponse, "ns1:srmGetSpaceTokensResponse"))
				{	soap_flag_srmGetSpaceTokensResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceTokensResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetSpaceTokensResponse_, 0, sizeof(struct ns1__srmGetSpaceTokensResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetSpaceTokensResponse_(struct soap *soap, const struct ns1__srmGetSpaceTokensResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetSpaceTokensResponse_);
	if (soap_out_ns1__srmGetSpaceTokensResponse_(soap, tag?tag:"ns1:srmGetSpaceTokensResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokensResponse_ * SOAP_FMAC4 soap_get_ns1__srmGetSpaceTokensResponse_(struct soap *soap, struct ns1__srmGetSpaceTokensResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetSpaceTokensResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPurgeFromSpace(struct soap *soap, struct ns1__srmPurgeFromSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPurgeFromSpaceRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPurgeFromSpace(struct soap *soap, const struct ns1__srmPurgeFromSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmPurgeFromSpaceRequest(soap, &a->srmPurgeFromSpaceRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPurgeFromSpace(struct soap *soap, const char *tag, int id, const struct ns1__srmPurgeFromSpace *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPurgeFromSpace), type))
		return soap->error;
	if (soap_out_PointerTons1__srmPurgeFromSpaceRequest(soap, "srmPurgeFromSpaceRequest", -1, &a->srmPurgeFromSpaceRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpace * SOAP_FMAC4 soap_in_ns1__srmPurgeFromSpace(struct soap *soap, const char *tag, struct ns1__srmPurgeFromSpace *a, const char *type)
{
	size_t soap_flag_srmPurgeFromSpaceRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPurgeFromSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPurgeFromSpace, sizeof(struct ns1__srmPurgeFromSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPurgeFromSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPurgeFromSpaceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmPurgeFromSpaceRequest(soap, "srmPurgeFromSpaceRequest", &a->srmPurgeFromSpaceRequest, "ns1:srmPurgeFromSpaceRequest"))
				{	soap_flag_srmPurgeFromSpaceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPurgeFromSpace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPurgeFromSpace, 0, sizeof(struct ns1__srmPurgeFromSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPurgeFromSpace(struct soap *soap, const struct ns1__srmPurgeFromSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPurgeFromSpace);
	if (soap_out_ns1__srmPurgeFromSpace(soap, tag?tag:"ns1:srmPurgeFromSpace", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpace * SOAP_FMAC4 soap_get_ns1__srmPurgeFromSpace(struct soap *soap, struct ns1__srmPurgeFromSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPurgeFromSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPurgeFromSpaceResponse_(struct soap *soap, struct ns1__srmPurgeFromSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPurgeFromSpaceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPurgeFromSpaceResponse_(struct soap *soap, const struct ns1__srmPurgeFromSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmPurgeFromSpaceResponse(soap, &a->srmPurgeFromSpaceResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPurgeFromSpaceResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmPurgeFromSpaceResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmPurgeFromSpaceResponse(soap, "srmPurgeFromSpaceResponse", -1, &a->srmPurgeFromSpaceResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpaceResponse_ * SOAP_FMAC4 soap_in_ns1__srmPurgeFromSpaceResponse_(struct soap *soap, const char *tag, struct ns1__srmPurgeFromSpaceResponse_ *a, const char *type)
{
	size_t soap_flag_srmPurgeFromSpaceResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPurgeFromSpaceResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse_, sizeof(struct ns1__srmPurgeFromSpaceResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPurgeFromSpaceResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPurgeFromSpaceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmPurgeFromSpaceResponse(soap, "srmPurgeFromSpaceResponse", &a->srmPurgeFromSpaceResponse, "ns1:srmPurgeFromSpaceResponse"))
				{	soap_flag_srmPurgeFromSpaceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPurgeFromSpaceResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse_, 0, sizeof(struct ns1__srmPurgeFromSpaceResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPurgeFromSpaceResponse_(struct soap *soap, const struct ns1__srmPurgeFromSpaceResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse_);
	if (soap_out_ns1__srmPurgeFromSpaceResponse_(soap, tag?tag:"ns1:srmPurgeFromSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpaceResponse_ * SOAP_FMAC4 soap_get_ns1__srmPurgeFromSpaceResponse_(struct soap *soap, struct ns1__srmPurgeFromSpaceResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPurgeFromSpaceResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmExtendFileLifeTimeInSpace(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmExtendFileLifeTimeInSpaceRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmExtendFileLifeTimeInSpace(struct soap *soap, const struct ns1__srmExtendFileLifeTimeInSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(soap, &a->srmExtendFileLifeTimeInSpaceRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmExtendFileLifeTimeInSpace(struct soap *soap, const char *tag, int id, const struct ns1__srmExtendFileLifeTimeInSpace *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpace), type))
		return soap->error;
	if (soap_out_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(soap, "srmExtendFileLifeTimeInSpaceRequest", -1, &a->srmExtendFileLifeTimeInSpaceRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpace * SOAP_FMAC4 soap_in_ns1__srmExtendFileLifeTimeInSpace(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeInSpace *a, const char *type)
{
	size_t soap_flag_srmExtendFileLifeTimeInSpaceRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmExtendFileLifeTimeInSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpace, sizeof(struct ns1__srmExtendFileLifeTimeInSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmExtendFileLifeTimeInSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmExtendFileLifeTimeInSpaceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(soap, "srmExtendFileLifeTimeInSpaceRequest", &a->srmExtendFileLifeTimeInSpaceRequest, "ns1:srmExtendFileLifeTimeInSpaceRequest"))
				{	soap_flag_srmExtendFileLifeTimeInSpaceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeInSpace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpace, 0, sizeof(struct ns1__srmExtendFileLifeTimeInSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmExtendFileLifeTimeInSpace(struct soap *soap, const struct ns1__srmExtendFileLifeTimeInSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpace);
	if (soap_out_ns1__srmExtendFileLifeTimeInSpace(soap, tag?tag:"ns1:srmExtendFileLifeTimeInSpace", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpace * SOAP_FMAC4 soap_get_ns1__srmExtendFileLifeTimeInSpace(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmExtendFileLifeTimeInSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmExtendFileLifeTimeInSpaceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, const struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(soap, &a->srmExtendFileLifeTimeInSpaceResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(soap, "srmExtendFileLifeTimeInSpaceResponse", -1, &a->srmExtendFileLifeTimeInSpaceResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpaceResponse_ * SOAP_FMAC4 soap_in_ns1__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *a, const char *type)
{
	size_t soap_flag_srmExtendFileLifeTimeInSpaceResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse_, sizeof(struct ns1__srmExtendFileLifeTimeInSpaceResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmExtendFileLifeTimeInSpaceResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmExtendFileLifeTimeInSpaceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(soap, "srmExtendFileLifeTimeInSpaceResponse", &a->srmExtendFileLifeTimeInSpaceResponse, "ns1:srmExtendFileLifeTimeInSpaceResponse"))
				{	soap_flag_srmExtendFileLifeTimeInSpaceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse_, 0, sizeof(struct ns1__srmExtendFileLifeTimeInSpaceResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, const struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse_);
	if (soap_out_ns1__srmExtendFileLifeTimeInSpaceResponse_(soap, tag?tag:"ns1:srmExtendFileLifeTimeInSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpaceResponse_ * SOAP_FMAC4 soap_get_ns1__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfChangeSpaceForFilesRequest(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfChangeSpaceForFilesRequestRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfChangeSpaceForFilesRequest(struct soap *soap, const struct ns1__srmStatusOfChangeSpaceForFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, &a->srmStatusOfChangeSpaceForFilesRequestRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfChangeSpaceForFilesRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfChangeSpaceForFilesRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, "srmStatusOfChangeSpaceForFilesRequestRequest", -1, &a->srmStatusOfChangeSpaceForFilesRequestRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfChangeSpaceForFilesRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfChangeSpaceForFilesRequest *a, const char *type)
{
	size_t soap_flag_srmStatusOfChangeSpaceForFilesRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfChangeSpaceForFilesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequest, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfChangeSpaceForFilesRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfChangeSpaceForFilesRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, "srmStatusOfChangeSpaceForFilesRequestRequest", &a->srmStatusOfChangeSpaceForFilesRequestRequest, "ns1:srmStatusOfChangeSpaceForFilesRequestRequest"))
				{	soap_flag_srmStatusOfChangeSpaceForFilesRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfChangeSpaceForFilesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequest, 0, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfChangeSpaceForFilesRequest(struct soap *soap, const struct ns1__srmStatusOfChangeSpaceForFilesRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequest);
	if (soap_out_ns1__srmStatusOfChangeSpaceForFilesRequest(soap, tag?tag:"ns1:srmStatusOfChangeSpaceForFilesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfChangeSpaceForFilesRequest(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfChangeSpaceForFilesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfChangeSpaceForFilesRequestResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, &a->srmStatusOfChangeSpaceForFilesRequestResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, "srmStatusOfChangeSpaceForFilesRequestResponse", -1, &a->srmStatusOfChangeSpaceForFilesRequestResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ * SOAP_FMAC4 soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *a, const char *type)
{
	size_t soap_flag_srmStatusOfChangeSpaceForFilesRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfChangeSpaceForFilesRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, "srmStatusOfChangeSpaceForFilesRequestResponse", &a->srmStatusOfChangeSpaceForFilesRequestResponse, "ns1:srmStatusOfChangeSpaceForFilesRequestResponse"))
				{	soap_flag_srmStatusOfChangeSpaceForFilesRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_, 0, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_);
	if (soap_out_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag?tag:"ns1:srmStatusOfChangeSpaceForFilesRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ * SOAP_FMAC4 soap_get_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmChangeSpaceForFiles(struct soap *soap, struct ns1__srmChangeSpaceForFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmChangeSpaceForFilesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmChangeSpaceForFiles(struct soap *soap, const struct ns1__srmChangeSpaceForFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmChangeSpaceForFilesRequest(soap, &a->srmChangeSpaceForFilesRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmChangeSpaceForFiles(struct soap *soap, const char *tag, int id, const struct ns1__srmChangeSpaceForFiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmChangeSpaceForFiles), type))
		return soap->error;
	if (soap_out_PointerTons1__srmChangeSpaceForFilesRequest(soap, "srmChangeSpaceForFilesRequest", -1, &a->srmChangeSpaceForFilesRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFiles * SOAP_FMAC4 soap_in_ns1__srmChangeSpaceForFiles(struct soap *soap, const char *tag, struct ns1__srmChangeSpaceForFiles *a, const char *type)
{
	size_t soap_flag_srmChangeSpaceForFilesRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmChangeSpaceForFiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmChangeSpaceForFiles, sizeof(struct ns1__srmChangeSpaceForFiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmChangeSpaceForFiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmChangeSpaceForFilesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmChangeSpaceForFilesRequest(soap, "srmChangeSpaceForFilesRequest", &a->srmChangeSpaceForFilesRequest, "ns1:srmChangeSpaceForFilesRequest"))
				{	soap_flag_srmChangeSpaceForFilesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmChangeSpaceForFiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmChangeSpaceForFiles, 0, sizeof(struct ns1__srmChangeSpaceForFiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmChangeSpaceForFiles(struct soap *soap, const struct ns1__srmChangeSpaceForFiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmChangeSpaceForFiles);
	if (soap_out_ns1__srmChangeSpaceForFiles(soap, tag?tag:"ns1:srmChangeSpaceForFiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFiles * SOAP_FMAC4 soap_get_ns1__srmChangeSpaceForFiles(struct soap *soap, struct ns1__srmChangeSpaceForFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmChangeSpaceForFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmChangeSpaceForFilesResponse_(struct soap *soap, struct ns1__srmChangeSpaceForFilesResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmChangeSpaceForFilesResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmChangeSpaceForFilesResponse_(struct soap *soap, const struct ns1__srmChangeSpaceForFilesResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmChangeSpaceForFilesResponse(soap, &a->srmChangeSpaceForFilesResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmChangeSpaceForFilesResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmChangeSpaceForFilesResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmChangeSpaceForFilesResponse(soap, "srmChangeSpaceForFilesResponse", -1, &a->srmChangeSpaceForFilesResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFilesResponse_ * SOAP_FMAC4 soap_in_ns1__srmChangeSpaceForFilesResponse_(struct soap *soap, const char *tag, struct ns1__srmChangeSpaceForFilesResponse_ *a, const char *type)
{
	size_t soap_flag_srmChangeSpaceForFilesResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmChangeSpaceForFilesResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse_, sizeof(struct ns1__srmChangeSpaceForFilesResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmChangeSpaceForFilesResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmChangeSpaceForFilesResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmChangeSpaceForFilesResponse(soap, "srmChangeSpaceForFilesResponse", &a->srmChangeSpaceForFilesResponse, "ns1:srmChangeSpaceForFilesResponse"))
				{	soap_flag_srmChangeSpaceForFilesResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmChangeSpaceForFilesResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse_, 0, sizeof(struct ns1__srmChangeSpaceForFilesResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmChangeSpaceForFilesResponse_(struct soap *soap, const struct ns1__srmChangeSpaceForFilesResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse_);
	if (soap_out_ns1__srmChangeSpaceForFilesResponse_(soap, tag?tag:"ns1:srmChangeSpaceForFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFilesResponse_ * SOAP_FMAC4 soap_get_ns1__srmChangeSpaceForFilesResponse_(struct soap *soap, struct ns1__srmChangeSpaceForFilesResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmChangeSpaceForFilesResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetSpaceMetaData(struct soap *soap, struct ns1__srmGetSpaceMetaData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetSpaceMetaDataRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetSpaceMetaData(struct soap *soap, const struct ns1__srmGetSpaceMetaData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmGetSpaceMetaDataRequest(soap, &a->srmGetSpaceMetaDataRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetSpaceMetaData(struct soap *soap, const char *tag, int id, const struct ns1__srmGetSpaceMetaData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetSpaceMetaData), type))
		return soap->error;
	if (soap_out_PointerTons1__srmGetSpaceMetaDataRequest(soap, "srmGetSpaceMetaDataRequest", -1, &a->srmGetSpaceMetaDataRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaData * SOAP_FMAC4 soap_in_ns1__srmGetSpaceMetaData(struct soap *soap, const char *tag, struct ns1__srmGetSpaceMetaData *a, const char *type)
{
	size_t soap_flag_srmGetSpaceMetaDataRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetSpaceMetaData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetSpaceMetaData, sizeof(struct ns1__srmGetSpaceMetaData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetSpaceMetaData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetSpaceMetaDataRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmGetSpaceMetaDataRequest(soap, "srmGetSpaceMetaDataRequest", &a->srmGetSpaceMetaDataRequest, "ns1:srmGetSpaceMetaDataRequest"))
				{	soap_flag_srmGetSpaceMetaDataRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceMetaData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetSpaceMetaData, 0, sizeof(struct ns1__srmGetSpaceMetaData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetSpaceMetaData(struct soap *soap, const struct ns1__srmGetSpaceMetaData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetSpaceMetaData);
	if (soap_out_ns1__srmGetSpaceMetaData(soap, tag?tag:"ns1:srmGetSpaceMetaData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaData * SOAP_FMAC4 soap_get_ns1__srmGetSpaceMetaData(struct soap *soap, struct ns1__srmGetSpaceMetaData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetSpaceMetaData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetSpaceMetaDataResponse_(struct soap *soap, struct ns1__srmGetSpaceMetaDataResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetSpaceMetaDataResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetSpaceMetaDataResponse_(struct soap *soap, const struct ns1__srmGetSpaceMetaDataResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmGetSpaceMetaDataResponse(soap, &a->srmGetSpaceMetaDataResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetSpaceMetaDataResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmGetSpaceMetaDataResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmGetSpaceMetaDataResponse(soap, "srmGetSpaceMetaDataResponse", -1, &a->srmGetSpaceMetaDataResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaDataResponse_ * SOAP_FMAC4 soap_in_ns1__srmGetSpaceMetaDataResponse_(struct soap *soap, const char *tag, struct ns1__srmGetSpaceMetaDataResponse_ *a, const char *type)
{
	size_t soap_flag_srmGetSpaceMetaDataResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetSpaceMetaDataResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse_, sizeof(struct ns1__srmGetSpaceMetaDataResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetSpaceMetaDataResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetSpaceMetaDataResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmGetSpaceMetaDataResponse(soap, "srmGetSpaceMetaDataResponse", &a->srmGetSpaceMetaDataResponse, "ns1:srmGetSpaceMetaDataResponse"))
				{	soap_flag_srmGetSpaceMetaDataResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceMetaDataResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse_, 0, sizeof(struct ns1__srmGetSpaceMetaDataResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetSpaceMetaDataResponse_(struct soap *soap, const struct ns1__srmGetSpaceMetaDataResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse_);
	if (soap_out_ns1__srmGetSpaceMetaDataResponse_(soap, tag?tag:"ns1:srmGetSpaceMetaDataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaDataResponse_ * SOAP_FMAC4 soap_get_ns1__srmGetSpaceMetaDataResponse_(struct soap *soap, struct ns1__srmGetSpaceMetaDataResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetSpaceMetaDataResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfUpdateSpaceRequest(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfUpdateSpaceRequestRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfUpdateSpaceRequest(struct soap *soap, const struct ns1__srmStatusOfUpdateSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(soap, &a->srmStatusOfUpdateSpaceRequestRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfUpdateSpaceRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfUpdateSpaceRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(soap, "srmStatusOfUpdateSpaceRequestRequest", -1, &a->srmStatusOfUpdateSpaceRequestRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfUpdateSpaceRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfUpdateSpaceRequest *a, const char *type)
{
	size_t soap_flag_srmStatusOfUpdateSpaceRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfUpdateSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequest, sizeof(struct ns1__srmStatusOfUpdateSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfUpdateSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfUpdateSpaceRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(soap, "srmStatusOfUpdateSpaceRequestRequest", &a->srmStatusOfUpdateSpaceRequestRequest, "ns1:srmStatusOfUpdateSpaceRequestRequest"))
				{	soap_flag_srmStatusOfUpdateSpaceRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfUpdateSpaceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequest, 0, sizeof(struct ns1__srmStatusOfUpdateSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfUpdateSpaceRequest(struct soap *soap, const struct ns1__srmStatusOfUpdateSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequest);
	if (soap_out_ns1__srmStatusOfUpdateSpaceRequest(soap, tag?tag:"ns1:srmStatusOfUpdateSpaceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfUpdateSpaceRequest(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfUpdateSpaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfUpdateSpaceRequestResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(soap, &a->srmStatusOfUpdateSpaceRequestResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(soap, "srmStatusOfUpdateSpaceRequestResponse", -1, &a->srmStatusOfUpdateSpaceRequestResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequestResponse_ * SOAP_FMAC4 soap_in_ns1__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *a, const char *type)
{
	size_t soap_flag_srmStatusOfUpdateSpaceRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse_, sizeof(struct ns1__srmStatusOfUpdateSpaceRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfUpdateSpaceRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfUpdateSpaceRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(soap, "srmStatusOfUpdateSpaceRequestResponse", &a->srmStatusOfUpdateSpaceRequestResponse, "ns1:srmStatusOfUpdateSpaceRequestResponse"))
				{	soap_flag_srmStatusOfUpdateSpaceRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse_, 0, sizeof(struct ns1__srmStatusOfUpdateSpaceRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse_);
	if (soap_out_ns1__srmStatusOfUpdateSpaceRequestResponse_(soap, tag?tag:"ns1:srmStatusOfUpdateSpaceRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequestResponse_ * SOAP_FMAC4 soap_get_ns1__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmUpdateSpace(struct soap *soap, struct ns1__srmUpdateSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmUpdateSpaceRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmUpdateSpace(struct soap *soap, const struct ns1__srmUpdateSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmUpdateSpaceRequest(soap, &a->srmUpdateSpaceRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmUpdateSpace(struct soap *soap, const char *tag, int id, const struct ns1__srmUpdateSpace *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmUpdateSpace), type))
		return soap->error;
	if (soap_out_PointerTons1__srmUpdateSpaceRequest(soap, "srmUpdateSpaceRequest", -1, &a->srmUpdateSpaceRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmUpdateSpace * SOAP_FMAC4 soap_in_ns1__srmUpdateSpace(struct soap *soap, const char *tag, struct ns1__srmUpdateSpace *a, const char *type)
{
	size_t soap_flag_srmUpdateSpaceRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmUpdateSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmUpdateSpace, sizeof(struct ns1__srmUpdateSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmUpdateSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmUpdateSpaceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmUpdateSpaceRequest(soap, "srmUpdateSpaceRequest", &a->srmUpdateSpaceRequest, "ns1:srmUpdateSpaceRequest"))
				{	soap_flag_srmUpdateSpaceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmUpdateSpace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmUpdateSpace, 0, sizeof(struct ns1__srmUpdateSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmUpdateSpace(struct soap *soap, const struct ns1__srmUpdateSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmUpdateSpace);
	if (soap_out_ns1__srmUpdateSpace(soap, tag?tag:"ns1:srmUpdateSpace", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmUpdateSpace * SOAP_FMAC4 soap_get_ns1__srmUpdateSpace(struct soap *soap, struct ns1__srmUpdateSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmUpdateSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmUpdateSpaceResponse_(struct soap *soap, struct ns1__srmUpdateSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmUpdateSpaceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmUpdateSpaceResponse_(struct soap *soap, const struct ns1__srmUpdateSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmUpdateSpaceResponse(soap, &a->srmUpdateSpaceResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmUpdateSpaceResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmUpdateSpaceResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmUpdateSpaceResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmUpdateSpaceResponse(soap, "srmUpdateSpaceResponse", -1, &a->srmUpdateSpaceResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmUpdateSpaceResponse_ * SOAP_FMAC4 soap_in_ns1__srmUpdateSpaceResponse_(struct soap *soap, const char *tag, struct ns1__srmUpdateSpaceResponse_ *a, const char *type)
{
	size_t soap_flag_srmUpdateSpaceResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmUpdateSpaceResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmUpdateSpaceResponse_, sizeof(struct ns1__srmUpdateSpaceResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmUpdateSpaceResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmUpdateSpaceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmUpdateSpaceResponse(soap, "srmUpdateSpaceResponse", &a->srmUpdateSpaceResponse, "ns1:srmUpdateSpaceResponse"))
				{	soap_flag_srmUpdateSpaceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmUpdateSpaceResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmUpdateSpaceResponse_, 0, sizeof(struct ns1__srmUpdateSpaceResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmUpdateSpaceResponse_(struct soap *soap, const struct ns1__srmUpdateSpaceResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmUpdateSpaceResponse_);
	if (soap_out_ns1__srmUpdateSpaceResponse_(soap, tag?tag:"ns1:srmUpdateSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmUpdateSpaceResponse_ * SOAP_FMAC4 soap_get_ns1__srmUpdateSpaceResponse_(struct soap *soap, struct ns1__srmUpdateSpaceResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmUpdateSpaceResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmReleaseSpace(struct soap *soap, struct ns1__srmReleaseSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmReleaseSpaceRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmReleaseSpace(struct soap *soap, const struct ns1__srmReleaseSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmReleaseSpaceRequest(soap, &a->srmReleaseSpaceRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmReleaseSpace(struct soap *soap, const char *tag, int id, const struct ns1__srmReleaseSpace *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmReleaseSpace), type))
		return soap->error;
	if (soap_out_PointerTons1__srmReleaseSpaceRequest(soap, "srmReleaseSpaceRequest", -1, &a->srmReleaseSpaceRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmReleaseSpace * SOAP_FMAC4 soap_in_ns1__srmReleaseSpace(struct soap *soap, const char *tag, struct ns1__srmReleaseSpace *a, const char *type)
{
	size_t soap_flag_srmReleaseSpaceRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmReleaseSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmReleaseSpace, sizeof(struct ns1__srmReleaseSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmReleaseSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmReleaseSpaceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmReleaseSpaceRequest(soap, "srmReleaseSpaceRequest", &a->srmReleaseSpaceRequest, "ns1:srmReleaseSpaceRequest"))
				{	soap_flag_srmReleaseSpaceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseSpace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmReleaseSpace, 0, sizeof(struct ns1__srmReleaseSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmReleaseSpace(struct soap *soap, const struct ns1__srmReleaseSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmReleaseSpace);
	if (soap_out_ns1__srmReleaseSpace(soap, tag?tag:"ns1:srmReleaseSpace", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseSpace * SOAP_FMAC4 soap_get_ns1__srmReleaseSpace(struct soap *soap, struct ns1__srmReleaseSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmReleaseSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmReleaseSpaceResponse_(struct soap *soap, struct ns1__srmReleaseSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmReleaseSpaceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmReleaseSpaceResponse_(struct soap *soap, const struct ns1__srmReleaseSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmReleaseSpaceResponse(soap, &a->srmReleaseSpaceResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmReleaseSpaceResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmReleaseSpaceResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmReleaseSpaceResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmReleaseSpaceResponse(soap, "srmReleaseSpaceResponse", -1, &a->srmReleaseSpaceResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmReleaseSpaceResponse_ * SOAP_FMAC4 soap_in_ns1__srmReleaseSpaceResponse_(struct soap *soap, const char *tag, struct ns1__srmReleaseSpaceResponse_ *a, const char *type)
{
	size_t soap_flag_srmReleaseSpaceResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmReleaseSpaceResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmReleaseSpaceResponse_, sizeof(struct ns1__srmReleaseSpaceResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmReleaseSpaceResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmReleaseSpaceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmReleaseSpaceResponse(soap, "srmReleaseSpaceResponse", &a->srmReleaseSpaceResponse, "ns1:srmReleaseSpaceResponse"))
				{	soap_flag_srmReleaseSpaceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseSpaceResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmReleaseSpaceResponse_, 0, sizeof(struct ns1__srmReleaseSpaceResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmReleaseSpaceResponse_(struct soap *soap, const struct ns1__srmReleaseSpaceResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmReleaseSpaceResponse_);
	if (soap_out_ns1__srmReleaseSpaceResponse_(soap, tag?tag:"ns1:srmReleaseSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseSpaceResponse_ * SOAP_FMAC4 soap_get_ns1__srmReleaseSpaceResponse_(struct soap *soap, struct ns1__srmReleaseSpaceResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmReleaseSpaceResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfReserveSpaceRequest(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfReserveSpaceRequestRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfReserveSpaceRequest(struct soap *soap, const struct ns1__srmStatusOfReserveSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfReserveSpaceRequestRequest(soap, &a->srmStatusOfReserveSpaceRequestRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfReserveSpaceRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfReserveSpaceRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfReserveSpaceRequestRequest(soap, "srmStatusOfReserveSpaceRequestRequest", -1, &a->srmStatusOfReserveSpaceRequestRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfReserveSpaceRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfReserveSpaceRequest *a, const char *type)
{
	size_t soap_flag_srmStatusOfReserveSpaceRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfReserveSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequest, sizeof(struct ns1__srmStatusOfReserveSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfReserveSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfReserveSpaceRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfReserveSpaceRequestRequest(soap, "srmStatusOfReserveSpaceRequestRequest", &a->srmStatusOfReserveSpaceRequestRequest, "ns1:srmStatusOfReserveSpaceRequestRequest"))
				{	soap_flag_srmStatusOfReserveSpaceRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfReserveSpaceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequest, 0, sizeof(struct ns1__srmStatusOfReserveSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfReserveSpaceRequest(struct soap *soap, const struct ns1__srmStatusOfReserveSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequest);
	if (soap_out_ns1__srmStatusOfReserveSpaceRequest(soap, tag?tag:"ns1:srmStatusOfReserveSpaceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfReserveSpaceRequest(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfReserveSpaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfReserveSpaceRequestResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfReserveSpaceRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmStatusOfReserveSpaceRequestResponse(soap, &a->srmStatusOfReserveSpaceRequestResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfReserveSpaceRequestResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmStatusOfReserveSpaceRequestResponse(soap, "srmStatusOfReserveSpaceRequestResponse", -1, &a->srmStatusOfReserveSpaceRequestResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequestResponse_ * SOAP_FMAC4 soap_in_ns1__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfReserveSpaceRequestResponse_ *a, const char *type)
{
	size_t soap_flag_srmStatusOfReserveSpaceRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfReserveSpaceRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse_, sizeof(struct ns1__srmStatusOfReserveSpaceRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfReserveSpaceRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfReserveSpaceRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmStatusOfReserveSpaceRequestResponse(soap, "srmStatusOfReserveSpaceRequestResponse", &a->srmStatusOfReserveSpaceRequestResponse, "ns1:srmStatusOfReserveSpaceRequestResponse"))
				{	soap_flag_srmStatusOfReserveSpaceRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfReserveSpaceRequestResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse_, 0, sizeof(struct ns1__srmStatusOfReserveSpaceRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, const struct ns1__srmStatusOfReserveSpaceRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse_);
	if (soap_out_ns1__srmStatusOfReserveSpaceRequestResponse_(soap, tag?tag:"ns1:srmStatusOfReserveSpaceRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequestResponse_ * SOAP_FMAC4 soap_get_ns1__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfReserveSpaceRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmReserveSpace(struct soap *soap, struct ns1__srmReserveSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmReserveSpaceRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmReserveSpace(struct soap *soap, const struct ns1__srmReserveSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmReserveSpaceRequest(soap, &a->srmReserveSpaceRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmReserveSpace(struct soap *soap, const char *tag, int id, const struct ns1__srmReserveSpace *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmReserveSpace), type))
		return soap->error;
	if (soap_out_PointerTons1__srmReserveSpaceRequest(soap, "srmReserveSpaceRequest", -1, &a->srmReserveSpaceRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmReserveSpace * SOAP_FMAC4 soap_in_ns1__srmReserveSpace(struct soap *soap, const char *tag, struct ns1__srmReserveSpace *a, const char *type)
{
	size_t soap_flag_srmReserveSpaceRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmReserveSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmReserveSpace, sizeof(struct ns1__srmReserveSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmReserveSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmReserveSpaceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmReserveSpaceRequest(soap, "srmReserveSpaceRequest", &a->srmReserveSpaceRequest, "ns1:srmReserveSpaceRequest"))
				{	soap_flag_srmReserveSpaceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReserveSpace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmReserveSpace, 0, sizeof(struct ns1__srmReserveSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmReserveSpace(struct soap *soap, const struct ns1__srmReserveSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmReserveSpace);
	if (soap_out_ns1__srmReserveSpace(soap, tag?tag:"ns1:srmReserveSpace", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReserveSpace * SOAP_FMAC4 soap_get_ns1__srmReserveSpace(struct soap *soap, struct ns1__srmReserveSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmReserveSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmReserveSpaceResponse_(struct soap *soap, struct ns1__srmReserveSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmReserveSpaceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmReserveSpaceResponse_(struct soap *soap, const struct ns1__srmReserveSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__srmReserveSpaceResponse(soap, &a->srmReserveSpaceResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmReserveSpaceResponse_(struct soap *soap, const char *tag, int id, const struct ns1__srmReserveSpaceResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmReserveSpaceResponse_), type))
		return soap->error;
	if (soap_out_PointerTons1__srmReserveSpaceResponse(soap, "srmReserveSpaceResponse", -1, &a->srmReserveSpaceResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmReserveSpaceResponse_ * SOAP_FMAC4 soap_in_ns1__srmReserveSpaceResponse_(struct soap *soap, const char *tag, struct ns1__srmReserveSpaceResponse_ *a, const char *type)
{
	size_t soap_flag_srmReserveSpaceResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmReserveSpaceResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmReserveSpaceResponse_, sizeof(struct ns1__srmReserveSpaceResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmReserveSpaceResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmReserveSpaceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__srmReserveSpaceResponse(soap, "srmReserveSpaceResponse", &a->srmReserveSpaceResponse, "ns1:srmReserveSpaceResponse"))
				{	soap_flag_srmReserveSpaceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReserveSpaceResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmReserveSpaceResponse_, 0, sizeof(struct ns1__srmReserveSpaceResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmReserveSpaceResponse_(struct soap *soap, const struct ns1__srmReserveSpaceResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmReserveSpaceResponse_);
	if (soap_out_ns1__srmReserveSpaceResponse_(soap, tag?tag:"ns1:srmReserveSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReserveSpaceResponse_ * SOAP_FMAC4 soap_get_ns1__srmReserveSpaceResponse_(struct soap *soap, struct ns1__srmReserveSpaceResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmReserveSpaceResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPingResponse(struct soap *soap, struct ns1__srmPingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->versionInfo);
	a->otherInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPingResponse(struct soap *soap, const struct ns1__srmPingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->versionInfo);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->otherInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPingResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmPingResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPingResponse), type))
		return soap->error;
	if (soap_out_string(soap, "versionInfo", -1, &a->versionInfo, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "otherInfo", -1, &a->otherInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPingResponse * SOAP_FMAC4 soap_in_ns1__srmPingResponse(struct soap *soap, const char *tag, struct ns1__srmPingResponse *a, const char *type)
{
	size_t soap_flag_versionInfo = 1;
	size_t soap_flag_otherInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPingResponse, sizeof(struct ns1__srmPingResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_versionInfo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "versionInfo", &a->versionInfo, "xsd:string"))
				{	soap_flag_versionInfo--;
					continue;
				}
			if (soap_flag_otherInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "otherInfo", &a->otherInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_otherInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPingResponse, 0, sizeof(struct ns1__srmPingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_versionInfo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPingResponse(struct soap *soap, const struct ns1__srmPingResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPingResponse);
	if (soap_out_ns1__srmPingResponse(soap, tag?tag:"ns1:srmPingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPingResponse * SOAP_FMAC4 soap_get_ns1__srmPingResponse(struct soap *soap, struct ns1__srmPingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPingRequest(struct soap *soap, struct ns1__srmPingRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPingRequest(struct soap *soap, const struct ns1__srmPingRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPingRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmPingRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPingRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPingRequest * SOAP_FMAC4 soap_in_ns1__srmPingRequest(struct soap *soap, const char *tag, struct ns1__srmPingRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPingRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPingRequest, sizeof(struct ns1__srmPingRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPingRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPingRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPingRequest, 0, sizeof(struct ns1__srmPingRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPingRequest(struct soap *soap, const struct ns1__srmPingRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPingRequest);
	if (soap_out_ns1__srmPingRequest(soap, tag?tag:"ns1:srmPingRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPingRequest * SOAP_FMAC4 soap_get_ns1__srmPingRequest(struct soap *soap, struct ns1__srmPingRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPingRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetTransferProtocolsResponse(struct soap *soap, struct ns1__srmGetTransferProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->protocolInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetTransferProtocolsResponse(struct soap *soap, const struct ns1__srmGetTransferProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTSupportedTransferProtocol(soap, &a->protocolInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetTransferProtocolsResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmGetTransferProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTSupportedTransferProtocol(soap, "protocolInfo", -1, &a->protocolInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocolsResponse * SOAP_FMAC4 soap_in_ns1__srmGetTransferProtocolsResponse(struct soap *soap, const char *tag, struct ns1__srmGetTransferProtocolsResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_protocolInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetTransferProtocolsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse, sizeof(struct ns1__srmGetTransferProtocolsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetTransferProtocolsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_protocolInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTSupportedTransferProtocol(soap, "protocolInfo", &a->protocolInfo, "ns1:ArrayOfTSupportedTransferProtocol"))
				{	soap_flag_protocolInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetTransferProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse, 0, sizeof(struct ns1__srmGetTransferProtocolsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetTransferProtocolsResponse(struct soap *soap, const struct ns1__srmGetTransferProtocolsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse);
	if (soap_out_ns1__srmGetTransferProtocolsResponse(soap, tag?tag:"ns1:srmGetTransferProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocolsResponse * SOAP_FMAC4 soap_get_ns1__srmGetTransferProtocolsResponse(struct soap *soap, struct ns1__srmGetTransferProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetTransferProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetTransferProtocolsRequest(struct soap *soap, struct ns1__srmGetTransferProtocolsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetTransferProtocolsRequest(struct soap *soap, const struct ns1__srmGetTransferProtocolsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetTransferProtocolsRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmGetTransferProtocolsRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetTransferProtocolsRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocolsRequest * SOAP_FMAC4 soap_in_ns1__srmGetTransferProtocolsRequest(struct soap *soap, const char *tag, struct ns1__srmGetTransferProtocolsRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetTransferProtocolsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetTransferProtocolsRequest, sizeof(struct ns1__srmGetTransferProtocolsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetTransferProtocolsRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetTransferProtocolsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetTransferProtocolsRequest, 0, sizeof(struct ns1__srmGetTransferProtocolsRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetTransferProtocolsRequest(struct soap *soap, const struct ns1__srmGetTransferProtocolsRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetTransferProtocolsRequest);
	if (soap_out_ns1__srmGetTransferProtocolsRequest(soap, tag?tag:"ns1:srmGetTransferProtocolsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocolsRequest * SOAP_FMAC4 soap_get_ns1__srmGetTransferProtocolsRequest(struct soap *soap, struct ns1__srmGetTransferProtocolsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetTransferProtocolsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetRequestTokensResponse(struct soap *soap, struct ns1__srmGetRequestTokensResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfRequestTokens = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetRequestTokensResponse(struct soap *soap, const struct ns1__srmGetRequestTokensResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTRequestTokenReturn(soap, &a->arrayOfRequestTokens);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetRequestTokensResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmGetRequestTokensResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetRequestTokensResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTRequestTokenReturn(soap, "arrayOfRequestTokens", -1, &a->arrayOfRequestTokens, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokensResponse * SOAP_FMAC4 soap_in_ns1__srmGetRequestTokensResponse(struct soap *soap, const char *tag, struct ns1__srmGetRequestTokensResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfRequestTokens = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetRequestTokensResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetRequestTokensResponse, sizeof(struct ns1__srmGetRequestTokensResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetRequestTokensResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfRequestTokens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTRequestTokenReturn(soap, "arrayOfRequestTokens", &a->arrayOfRequestTokens, "ns1:ArrayOfTRequestTokenReturn"))
				{	soap_flag_arrayOfRequestTokens--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestTokensResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetRequestTokensResponse, 0, sizeof(struct ns1__srmGetRequestTokensResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetRequestTokensResponse(struct soap *soap, const struct ns1__srmGetRequestTokensResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetRequestTokensResponse);
	if (soap_out_ns1__srmGetRequestTokensResponse(soap, tag?tag:"ns1:srmGetRequestTokensResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokensResponse * SOAP_FMAC4 soap_get_ns1__srmGetRequestTokensResponse(struct soap *soap, struct ns1__srmGetRequestTokensResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetRequestTokensResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetRequestTokensRequest(struct soap *soap, struct ns1__srmGetRequestTokensRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->userRequestDescription);
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetRequestTokensRequest(struct soap *soap, const struct ns1__srmGetRequestTokensRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->userRequestDescription);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetRequestTokensRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmGetRequestTokensRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetRequestTokensRequest), type))
		return soap->error;
	if (soap_out_string(soap, "userRequestDescription", -1, &a->userRequestDescription, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokensRequest * SOAP_FMAC4 soap_in_ns1__srmGetRequestTokensRequest(struct soap *soap, const char *tag, struct ns1__srmGetRequestTokensRequest *a, const char *type)
{
	size_t soap_flag_userRequestDescription = 1;
	size_t soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetRequestTokensRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetRequestTokensRequest, sizeof(struct ns1__srmGetRequestTokensRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetRequestTokensRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userRequestDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRequestDescription", &a->userRequestDescription, "xsd:string"))
				{	soap_flag_userRequestDescription--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestTokensRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetRequestTokensRequest, 0, sizeof(struct ns1__srmGetRequestTokensRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetRequestTokensRequest(struct soap *soap, const struct ns1__srmGetRequestTokensRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetRequestTokensRequest);
	if (soap_out_ns1__srmGetRequestTokensRequest(soap, tag?tag:"ns1:srmGetRequestTokensRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokensRequest * SOAP_FMAC4 soap_get_ns1__srmGetRequestTokensRequest(struct soap *soap, struct ns1__srmGetRequestTokensRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetRequestTokensRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmExtendFileLifeTimeResponse(struct soap *soap, struct ns1__srmExtendFileLifeTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmExtendFileLifeTimeResponse(struct soap *soap, const struct ns1__srmExtendFileLifeTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmExtendFileLifeTimeResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmExtendFileLifeTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeResponse * SOAP_FMAC4 soap_in_ns1__srmExtendFileLifeTimeResponse(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmExtendFileLifeTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse, sizeof(struct ns1__srmExtendFileLifeTimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmExtendFileLifeTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTSURLLifetimeReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse, 0, sizeof(struct ns1__srmExtendFileLifeTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmExtendFileLifeTimeResponse(struct soap *soap, const struct ns1__srmExtendFileLifeTimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse);
	if (soap_out_ns1__srmExtendFileLifeTimeResponse(soap, tag?tag:"ns1:srmExtendFileLifeTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeResponse * SOAP_FMAC4 soap_get_ns1__srmExtendFileLifeTimeResponse(struct soap *soap, struct ns1__srmExtendFileLifeTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmExtendFileLifeTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmExtendFileLifeTimeRequest(struct soap *soap, struct ns1__srmExtendFileLifeTimeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->requestToken);
	a->arrayOfSURLs = NULL;
	a->newFileLifeTime = NULL;
	a->newPinLifeTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmExtendFileLifeTimeRequest(struct soap *soap, const struct ns1__srmExtendFileLifeTimeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_PointerToint(soap, &a->newFileLifeTime);
	soap_serialize_PointerToint(soap, &a->newPinLifeTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmExtendFileLifeTimeRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmExtendFileLifeTimeRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "newFileLifeTime", -1, &a->newFileLifeTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "newPinLifeTime", -1, &a->newPinLifeTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeRequest * SOAP_FMAC4 soap_in_ns1__srmExtendFileLifeTimeRequest(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_arrayOfSURLs = 1;
	size_t soap_flag_newFileLifeTime = 1;
	size_t soap_flag_newPinLifeTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmExtendFileLifeTimeRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeRequest, sizeof(struct ns1__srmExtendFileLifeTimeRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmExtendFileLifeTimeRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_newFileLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "newFileLifeTime", &a->newFileLifeTime, "xsd:int"))
				{	soap_flag_newFileLifeTime--;
					continue;
				}
			if (soap_flag_newPinLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "newPinLifeTime", &a->newPinLifeTime, "xsd:int"))
				{	soap_flag_newPinLifeTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmExtendFileLifeTimeRequest, 0, sizeof(struct ns1__srmExtendFileLifeTimeRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmExtendFileLifeTimeRequest(struct soap *soap, const struct ns1__srmExtendFileLifeTimeRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmExtendFileLifeTimeRequest);
	if (soap_out_ns1__srmExtendFileLifeTimeRequest(soap, tag?tag:"ns1:srmExtendFileLifeTimeRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeRequest * SOAP_FMAC4 soap_get_ns1__srmExtendFileLifeTimeRequest(struct soap *soap, struct ns1__srmExtendFileLifeTimeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmExtendFileLifeTimeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetRequestSummaryResponse(struct soap *soap, struct ns1__srmGetRequestSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfRequestSummaries = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetRequestSummaryResponse(struct soap *soap, const struct ns1__srmGetRequestSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTRequestSummary(soap, &a->arrayOfRequestSummaries);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetRequestSummaryResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmGetRequestSummaryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetRequestSummaryResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTRequestSummary(soap, "arrayOfRequestSummaries", -1, &a->arrayOfRequestSummaries, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummaryResponse * SOAP_FMAC4 soap_in_ns1__srmGetRequestSummaryResponse(struct soap *soap, const char *tag, struct ns1__srmGetRequestSummaryResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfRequestSummaries = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetRequestSummaryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetRequestSummaryResponse, sizeof(struct ns1__srmGetRequestSummaryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetRequestSummaryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfRequestSummaries && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTRequestSummary(soap, "arrayOfRequestSummaries", &a->arrayOfRequestSummaries, "ns1:ArrayOfTRequestSummary"))
				{	soap_flag_arrayOfRequestSummaries--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestSummaryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetRequestSummaryResponse, 0, sizeof(struct ns1__srmGetRequestSummaryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetRequestSummaryResponse(struct soap *soap, const struct ns1__srmGetRequestSummaryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetRequestSummaryResponse);
	if (soap_out_ns1__srmGetRequestSummaryResponse(soap, tag?tag:"ns1:srmGetRequestSummaryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummaryResponse * SOAP_FMAC4 soap_get_ns1__srmGetRequestSummaryResponse(struct soap *soap, struct ns1__srmGetRequestSummaryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetRequestSummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetRequestSummaryRequest(struct soap *soap, struct ns1__srmGetRequestSummaryRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->arrayOfRequestTokens = NULL;
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetRequestSummaryRequest(struct soap *soap, const struct ns1__srmGetRequestSummaryRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfString(soap, &a->arrayOfRequestTokens);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetRequestSummaryRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmGetRequestSummaryRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetRequestSummaryRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "arrayOfRequestTokens", -1, &a->arrayOfRequestTokens, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummaryRequest * SOAP_FMAC4 soap_in_ns1__srmGetRequestSummaryRequest(struct soap *soap, const char *tag, struct ns1__srmGetRequestSummaryRequest *a, const char *type)
{
	size_t soap_flag_arrayOfRequestTokens = 1;
	size_t soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetRequestSummaryRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetRequestSummaryRequest, sizeof(struct ns1__srmGetRequestSummaryRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetRequestSummaryRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arrayOfRequestTokens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "arrayOfRequestTokens", &a->arrayOfRequestTokens, "ns1:ArrayOfString"))
				{	soap_flag_arrayOfRequestTokens--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestSummaryRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetRequestSummaryRequest, 0, sizeof(struct ns1__srmGetRequestSummaryRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfRequestTokens > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetRequestSummaryRequest(struct soap *soap, const struct ns1__srmGetRequestSummaryRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetRequestSummaryRequest);
	if (soap_out_ns1__srmGetRequestSummaryRequest(soap, tag?tag:"ns1:srmGetRequestSummaryRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummaryRequest * SOAP_FMAC4 soap_get_ns1__srmGetRequestSummaryRequest(struct soap *soap, struct ns1__srmGetRequestSummaryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetRequestSummaryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmResumeRequestResponse(struct soap *soap, struct ns1__srmResumeRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmResumeRequestResponse(struct soap *soap, const struct ns1__srmResumeRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmResumeRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmResumeRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmResumeRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmResumeRequestResponse * SOAP_FMAC4 soap_in_ns1__srmResumeRequestResponse(struct soap *soap, const char *tag, struct ns1__srmResumeRequestResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmResumeRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmResumeRequestResponse, sizeof(struct ns1__srmResumeRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmResumeRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmResumeRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmResumeRequestResponse, 0, sizeof(struct ns1__srmResumeRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmResumeRequestResponse(struct soap *soap, const struct ns1__srmResumeRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmResumeRequestResponse);
	if (soap_out_ns1__srmResumeRequestResponse(soap, tag?tag:"ns1:srmResumeRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmResumeRequestResponse * SOAP_FMAC4 soap_get_ns1__srmResumeRequestResponse(struct soap *soap, struct ns1__srmResumeRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmResumeRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmResumeRequestRequest(struct soap *soap, struct ns1__srmResumeRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmResumeRequestRequest(struct soap *soap, const struct ns1__srmResumeRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmResumeRequestRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmResumeRequestRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmResumeRequestRequest), type))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmResumeRequestRequest * SOAP_FMAC4 soap_in_ns1__srmResumeRequestRequest(struct soap *soap, const char *tag, struct ns1__srmResumeRequestRequest *a, const char *type)
{
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmResumeRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmResumeRequestRequest, sizeof(struct ns1__srmResumeRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmResumeRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmResumeRequestRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmResumeRequestRequest, 0, sizeof(struct ns1__srmResumeRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmResumeRequestRequest(struct soap *soap, const struct ns1__srmResumeRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmResumeRequestRequest);
	if (soap_out_ns1__srmResumeRequestRequest(soap, tag?tag:"ns1:srmResumeRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmResumeRequestRequest * SOAP_FMAC4 soap_get_ns1__srmResumeRequestRequest(struct soap *soap, struct ns1__srmResumeRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmResumeRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmSuspendRequestResponse(struct soap *soap, struct ns1__srmSuspendRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmSuspendRequestResponse(struct soap *soap, const struct ns1__srmSuspendRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmSuspendRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmSuspendRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmSuspendRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmSuspendRequestResponse * SOAP_FMAC4 soap_in_ns1__srmSuspendRequestResponse(struct soap *soap, const char *tag, struct ns1__srmSuspendRequestResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmSuspendRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmSuspendRequestResponse, sizeof(struct ns1__srmSuspendRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmSuspendRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSuspendRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmSuspendRequestResponse, 0, sizeof(struct ns1__srmSuspendRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmSuspendRequestResponse(struct soap *soap, const struct ns1__srmSuspendRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmSuspendRequestResponse);
	if (soap_out_ns1__srmSuspendRequestResponse(soap, tag?tag:"ns1:srmSuspendRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSuspendRequestResponse * SOAP_FMAC4 soap_get_ns1__srmSuspendRequestResponse(struct soap *soap, struct ns1__srmSuspendRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmSuspendRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmSuspendRequestRequest(struct soap *soap, struct ns1__srmSuspendRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmSuspendRequestRequest(struct soap *soap, const struct ns1__srmSuspendRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmSuspendRequestRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmSuspendRequestRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmSuspendRequestRequest), type))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmSuspendRequestRequest * SOAP_FMAC4 soap_in_ns1__srmSuspendRequestRequest(struct soap *soap, const char *tag, struct ns1__srmSuspendRequestRequest *a, const char *type)
{
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmSuspendRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmSuspendRequestRequest, sizeof(struct ns1__srmSuspendRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmSuspendRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSuspendRequestRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmSuspendRequestRequest, 0, sizeof(struct ns1__srmSuspendRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmSuspendRequestRequest(struct soap *soap, const struct ns1__srmSuspendRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmSuspendRequestRequest);
	if (soap_out_ns1__srmSuspendRequestRequest(soap, tag?tag:"ns1:srmSuspendRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSuspendRequestRequest * SOAP_FMAC4 soap_get_ns1__srmSuspendRequestRequest(struct soap *soap, struct ns1__srmSuspendRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmSuspendRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmAbortFilesResponse(struct soap *soap, struct ns1__srmAbortFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmAbortFilesResponse(struct soap *soap, const struct ns1__srmAbortFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmAbortFilesResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmAbortFilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmAbortFilesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmAbortFilesResponse * SOAP_FMAC4 soap_in_ns1__srmAbortFilesResponse(struct soap *soap, const char *tag, struct ns1__srmAbortFilesResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmAbortFilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmAbortFilesResponse, sizeof(struct ns1__srmAbortFilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmAbortFilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortFilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmAbortFilesResponse, 0, sizeof(struct ns1__srmAbortFilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmAbortFilesResponse(struct soap *soap, const struct ns1__srmAbortFilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmAbortFilesResponse);
	if (soap_out_ns1__srmAbortFilesResponse(soap, tag?tag:"ns1:srmAbortFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortFilesResponse * SOAP_FMAC4 soap_get_ns1__srmAbortFilesResponse(struct soap *soap, struct ns1__srmAbortFilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmAbortFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmAbortFilesRequest(struct soap *soap, struct ns1__srmAbortFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	a->arrayOfSURLs = NULL;
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmAbortFilesRequest(struct soap *soap, const struct ns1__srmAbortFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmAbortFilesRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmAbortFilesRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmAbortFilesRequest), type))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmAbortFilesRequest * SOAP_FMAC4 soap_in_ns1__srmAbortFilesRequest(struct soap *soap, const char *tag, struct ns1__srmAbortFilesRequest *a, const char *type)
{
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_arrayOfSURLs = 1;
	size_t soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmAbortFilesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmAbortFilesRequest, sizeof(struct ns1__srmAbortFilesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmAbortFilesRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortFilesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmAbortFilesRequest, 0, sizeof(struct ns1__srmAbortFilesRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0 || soap_flag_arrayOfSURLs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmAbortFilesRequest(struct soap *soap, const struct ns1__srmAbortFilesRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmAbortFilesRequest);
	if (soap_out_ns1__srmAbortFilesRequest(soap, tag?tag:"ns1:srmAbortFilesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortFilesRequest * SOAP_FMAC4 soap_get_ns1__srmAbortFilesRequest(struct soap *soap, struct ns1__srmAbortFilesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmAbortFilesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmAbortRequestResponse(struct soap *soap, struct ns1__srmAbortRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmAbortRequestResponse(struct soap *soap, const struct ns1__srmAbortRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmAbortRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmAbortRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmAbortRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmAbortRequestResponse * SOAP_FMAC4 soap_in_ns1__srmAbortRequestResponse(struct soap *soap, const char *tag, struct ns1__srmAbortRequestResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmAbortRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmAbortRequestResponse, sizeof(struct ns1__srmAbortRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmAbortRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmAbortRequestResponse, 0, sizeof(struct ns1__srmAbortRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmAbortRequestResponse(struct soap *soap, const struct ns1__srmAbortRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmAbortRequestResponse);
	if (soap_out_ns1__srmAbortRequestResponse(soap, tag?tag:"ns1:srmAbortRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortRequestResponse * SOAP_FMAC4 soap_get_ns1__srmAbortRequestResponse(struct soap *soap, struct ns1__srmAbortRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmAbortRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmAbortRequestRequest(struct soap *soap, struct ns1__srmAbortRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmAbortRequestRequest(struct soap *soap, const struct ns1__srmAbortRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmAbortRequestRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmAbortRequestRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmAbortRequestRequest), type))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmAbortRequestRequest * SOAP_FMAC4 soap_in_ns1__srmAbortRequestRequest(struct soap *soap, const char *tag, struct ns1__srmAbortRequestRequest *a, const char *type)
{
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmAbortRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmAbortRequestRequest, sizeof(struct ns1__srmAbortRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmAbortRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortRequestRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmAbortRequestRequest, 0, sizeof(struct ns1__srmAbortRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmAbortRequestRequest(struct soap *soap, const struct ns1__srmAbortRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmAbortRequestRequest);
	if (soap_out_ns1__srmAbortRequestRequest(soap, tag?tag:"ns1:srmAbortRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortRequestRequest * SOAP_FMAC4 soap_get_ns1__srmAbortRequestRequest(struct soap *soap, struct ns1__srmAbortRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmAbortRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPutDoneResponse(struct soap *soap, struct ns1__srmPutDoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPutDoneResponse(struct soap *soap, const struct ns1__srmPutDoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPutDoneResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmPutDoneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPutDoneResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPutDoneResponse * SOAP_FMAC4 soap_in_ns1__srmPutDoneResponse(struct soap *soap, const char *tag, struct ns1__srmPutDoneResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPutDoneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPutDoneResponse, sizeof(struct ns1__srmPutDoneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPutDoneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPutDoneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPutDoneResponse, 0, sizeof(struct ns1__srmPutDoneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPutDoneResponse(struct soap *soap, const struct ns1__srmPutDoneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPutDoneResponse);
	if (soap_out_ns1__srmPutDoneResponse(soap, tag?tag:"ns1:srmPutDoneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPutDoneResponse * SOAP_FMAC4 soap_get_ns1__srmPutDoneResponse(struct soap *soap, struct ns1__srmPutDoneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPutDoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPutDoneRequest(struct soap *soap, struct ns1__srmPutDoneRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPutDoneRequest(struct soap *soap, const struct ns1__srmPutDoneRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPutDoneRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmPutDoneRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPutDoneRequest), type))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPutDoneRequest * SOAP_FMAC4 soap_in_ns1__srmPutDoneRequest(struct soap *soap, const char *tag, struct ns1__srmPutDoneRequest *a, const char *type)
{
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfSURLs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPutDoneRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPutDoneRequest, sizeof(struct ns1__srmPutDoneRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPutDoneRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPutDoneRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPutDoneRequest, 0, sizeof(struct ns1__srmPutDoneRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0 || soap_flag_arrayOfSURLs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPutDoneRequest(struct soap *soap, const struct ns1__srmPutDoneRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPutDoneRequest);
	if (soap_out_ns1__srmPutDoneRequest(soap, tag?tag:"ns1:srmPutDoneRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPutDoneRequest * SOAP_FMAC4 soap_get_ns1__srmPutDoneRequest(struct soap *soap, struct ns1__srmPutDoneRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPutDoneRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmReleaseFilesResponse(struct soap *soap, struct ns1__srmReleaseFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmReleaseFilesResponse(struct soap *soap, const struct ns1__srmReleaseFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmReleaseFilesResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmReleaseFilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmReleaseFilesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmReleaseFilesResponse * SOAP_FMAC4 soap_in_ns1__srmReleaseFilesResponse(struct soap *soap, const char *tag, struct ns1__srmReleaseFilesResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmReleaseFilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmReleaseFilesResponse, sizeof(struct ns1__srmReleaseFilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmReleaseFilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseFilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmReleaseFilesResponse, 0, sizeof(struct ns1__srmReleaseFilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmReleaseFilesResponse(struct soap *soap, const struct ns1__srmReleaseFilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmReleaseFilesResponse);
	if (soap_out_ns1__srmReleaseFilesResponse(soap, tag?tag:"ns1:srmReleaseFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseFilesResponse * SOAP_FMAC4 soap_get_ns1__srmReleaseFilesResponse(struct soap *soap, struct ns1__srmReleaseFilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmReleaseFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmReleaseFilesRequest(struct soap *soap, struct ns1__srmReleaseFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
	a->doRemove = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmReleaseFilesRequest(struct soap *soap, const struct ns1__srmReleaseFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_PointerToxsd__boolean(soap, &a->doRemove);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmReleaseFilesRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmReleaseFilesRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmReleaseFilesRequest), type))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "doRemove", -1, &a->doRemove, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmReleaseFilesRequest * SOAP_FMAC4 soap_in_ns1__srmReleaseFilesRequest(struct soap *soap, const char *tag, struct ns1__srmReleaseFilesRequest *a, const char *type)
{
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfSURLs = 1;
	size_t soap_flag_doRemove = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmReleaseFilesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmReleaseFilesRequest, sizeof(struct ns1__srmReleaseFilesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmReleaseFilesRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_doRemove && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "doRemove", &a->doRemove, "xsd:boolean"))
				{	soap_flag_doRemove--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseFilesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmReleaseFilesRequest, 0, sizeof(struct ns1__srmReleaseFilesRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmReleaseFilesRequest(struct soap *soap, const struct ns1__srmReleaseFilesRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmReleaseFilesRequest);
	if (soap_out_ns1__srmReleaseFilesRequest(soap, tag?tag:"ns1:srmReleaseFilesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseFilesRequest * SOAP_FMAC4 soap_get_ns1__srmReleaseFilesRequest(struct soap *soap, struct ns1__srmReleaseFilesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmReleaseFilesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfCopyRequestResponse(struct soap *soap, struct ns1__srmStatusOfCopyRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfCopyRequestResponse(struct soap *soap, const struct ns1__srmStatusOfCopyRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTCopyRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfCopyRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfCopyRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTCopyRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequestResponse * SOAP_FMAC4 soap_in_ns1__srmStatusOfCopyRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfCopyRequestResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	size_t soap_flag_remainingTotalRequestTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfCopyRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse, sizeof(struct ns1__srmStatusOfCopyRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfCopyRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTCopyRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTCopyRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfCopyRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse, 0, sizeof(struct ns1__srmStatusOfCopyRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfCopyRequestResponse(struct soap *soap, const struct ns1__srmStatusOfCopyRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse);
	if (soap_out_ns1__srmStatusOfCopyRequestResponse(soap, tag?tag:"ns1:srmStatusOfCopyRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequestResponse * SOAP_FMAC4 soap_get_ns1__srmStatusOfCopyRequestResponse(struct soap *soap, struct ns1__srmStatusOfCopyRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfCopyRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfCopyRequestRequest(struct soap *soap, struct ns1__srmStatusOfCopyRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSourceSURLs = NULL;
	a->arrayOfTargetSURLs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfCopyRequestRequest(struct soap *soap, const struct ns1__srmStatusOfCopyRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSourceSURLs);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfTargetSURLs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfCopyRequestRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfCopyRequestRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfCopyRequestRequest), type))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSourceSURLs", -1, &a->arrayOfSourceSURLs, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfTargetSURLs", -1, &a->arrayOfTargetSURLs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequestRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfCopyRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfCopyRequestRequest *a, const char *type)
{
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfSourceSURLs = 1;
	size_t soap_flag_arrayOfTargetSURLs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfCopyRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfCopyRequestRequest, sizeof(struct ns1__srmStatusOfCopyRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfCopyRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSourceSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSourceSURLs", &a->arrayOfSourceSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSourceSURLs--;
					continue;
				}
			if (soap_flag_arrayOfTargetSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfTargetSURLs", &a->arrayOfTargetSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfTargetSURLs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfCopyRequestRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfCopyRequestRequest, 0, sizeof(struct ns1__srmStatusOfCopyRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfCopyRequestRequest(struct soap *soap, const struct ns1__srmStatusOfCopyRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfCopyRequestRequest);
	if (soap_out_ns1__srmStatusOfCopyRequestRequest(soap, tag?tag:"ns1:srmStatusOfCopyRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequestRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfCopyRequestRequest(struct soap *soap, struct ns1__srmStatusOfCopyRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfCopyRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmCopyResponse(struct soap *soap, struct ns1__srmCopyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmCopyResponse(struct soap *soap, const struct ns1__srmCopyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTons1__ArrayOfTCopyRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmCopyResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmCopyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmCopyResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTCopyRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmCopyResponse * SOAP_FMAC4 soap_in_ns1__srmCopyResponse(struct soap *soap, const char *tag, struct ns1__srmCopyResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	size_t soap_flag_remainingTotalRequestTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmCopyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmCopyResponse, sizeof(struct ns1__srmCopyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmCopyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTCopyRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTCopyRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCopyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmCopyResponse, 0, sizeof(struct ns1__srmCopyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmCopyResponse(struct soap *soap, const struct ns1__srmCopyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmCopyResponse);
	if (soap_out_ns1__srmCopyResponse(soap, tag?tag:"ns1:srmCopyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCopyResponse * SOAP_FMAC4 soap_get_ns1__srmCopyResponse(struct soap *soap, struct ns1__srmCopyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmCopyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmCopyRequest(struct soap *soap, struct ns1__srmCopyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfFileRequests = NULL;
	soap_default_string(soap, &a->userRequestDescription);
	a->overwriteOption = NULL;
	a->desiredTotalRequestTime = NULL;
	a->desiredTargetSURLLifeTime = NULL;
	a->targetFileStorageType = NULL;
	soap_default_string(soap, &a->targetSpaceToken);
	a->targetFileRetentionPolicyInfo = NULL;
	a->sourceStorageSystemInfo = NULL;
	a->targetStorageSystemInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmCopyRequest(struct soap *soap, const struct ns1__srmCopyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfTCopyFileRequest(soap, &a->arrayOfFileRequests);
	soap_serialize_string(soap, &a->userRequestDescription);
	soap_serialize_PointerTons1__TOverwriteMode(soap, &a->overwriteOption);
	soap_serialize_PointerToint(soap, &a->desiredTotalRequestTime);
	soap_serialize_PointerToint(soap, &a->desiredTargetSURLLifeTime);
	soap_serialize_PointerTons1__TFileStorageType(soap, &a->targetFileStorageType);
	soap_serialize_string(soap, &a->targetSpaceToken);
	soap_serialize_PointerTons1__TRetentionPolicyInfo(soap, &a->targetFileRetentionPolicyInfo);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->sourceStorageSystemInfo);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->targetStorageSystemInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmCopyRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmCopyRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmCopyRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTCopyFileRequest(soap, "arrayOfFileRequests", -1, &a->arrayOfFileRequests, ""))
		return soap->error;
	if (soap_out_string(soap, "userRequestDescription", -1, &a->userRequestDescription, ""))
		return soap->error;
	if (soap_out_PointerTons1__TOverwriteMode(soap, "overwriteOption", -1, &a->overwriteOption, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "desiredTotalRequestTime", -1, &a->desiredTotalRequestTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "desiredTargetSURLLifeTime", -1, &a->desiredTargetSURLLifeTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__TFileStorageType(soap, "targetFileStorageType", -1, &a->targetFileStorageType, ""))
		return soap->error;
	if (soap_out_string(soap, "targetSpaceToken", -1, &a->targetSpaceToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", -1, &a->targetFileRetentionPolicyInfo, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "sourceStorageSystemInfo", -1, &a->sourceStorageSystemInfo, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "targetStorageSystemInfo", -1, &a->targetStorageSystemInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmCopyRequest * SOAP_FMAC4 soap_in_ns1__srmCopyRequest(struct soap *soap, const char *tag, struct ns1__srmCopyRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfFileRequests = 1;
	size_t soap_flag_userRequestDescription = 1;
	size_t soap_flag_overwriteOption = 1;
	size_t soap_flag_desiredTotalRequestTime = 1;
	size_t soap_flag_desiredTargetSURLLifeTime = 1;
	size_t soap_flag_targetFileStorageType = 1;
	size_t soap_flag_targetSpaceToken = 1;
	size_t soap_flag_targetFileRetentionPolicyInfo = 1;
	size_t soap_flag_sourceStorageSystemInfo = 1;
	size_t soap_flag_targetStorageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmCopyRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmCopyRequest, sizeof(struct ns1__srmCopyRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmCopyRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfFileRequests && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTCopyFileRequest(soap, "arrayOfFileRequests", &a->arrayOfFileRequests, "ns1:ArrayOfTCopyFileRequest"))
				{	soap_flag_arrayOfFileRequests--;
					continue;
				}
			if (soap_flag_userRequestDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRequestDescription", &a->userRequestDescription, "xsd:string"))
				{	soap_flag_userRequestDescription--;
					continue;
				}
			if (soap_flag_overwriteOption && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TOverwriteMode(soap, "overwriteOption", &a->overwriteOption, "ns1:TOverwriteMode"))
				{	soap_flag_overwriteOption--;
					continue;
				}
			if (soap_flag_desiredTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredTotalRequestTime", &a->desiredTotalRequestTime, "xsd:int"))
				{	soap_flag_desiredTotalRequestTime--;
					continue;
				}
			if (soap_flag_desiredTargetSURLLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredTargetSURLLifeTime", &a->desiredTargetSURLLifeTime, "xsd:int"))
				{	soap_flag_desiredTargetSURLLifeTime--;
					continue;
				}
			if (soap_flag_targetFileStorageType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TFileStorageType(soap, "targetFileStorageType", &a->targetFileStorageType, "ns1:TFileStorageType"))
				{	soap_flag_targetFileStorageType--;
					continue;
				}
			if (soap_flag_targetSpaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "targetSpaceToken", &a->targetSpaceToken, "xsd:string"))
				{	soap_flag_targetSpaceToken--;
					continue;
				}
			if (soap_flag_targetFileRetentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", &a->targetFileRetentionPolicyInfo, "ns1:TRetentionPolicyInfo"))
				{	soap_flag_targetFileRetentionPolicyInfo--;
					continue;
				}
			if (soap_flag_sourceStorageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "sourceStorageSystemInfo", &a->sourceStorageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_sourceStorageSystemInfo--;
					continue;
				}
			if (soap_flag_targetStorageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "targetStorageSystemInfo", &a->targetStorageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_targetStorageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCopyRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmCopyRequest, 0, sizeof(struct ns1__srmCopyRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfFileRequests > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmCopyRequest(struct soap *soap, const struct ns1__srmCopyRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmCopyRequest);
	if (soap_out_ns1__srmCopyRequest(soap, tag?tag:"ns1:srmCopyRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCopyRequest * SOAP_FMAC4 soap_get_ns1__srmCopyRequest(struct soap *soap, struct ns1__srmCopyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmCopyRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfPutRequestResponse(struct soap *soap, struct ns1__srmStatusOfPutRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfPutRequestResponse(struct soap *soap, const struct ns1__srmStatusOfPutRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTPutRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfPutRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfPutRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTPutRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequestResponse * SOAP_FMAC4 soap_in_ns1__srmStatusOfPutRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfPutRequestResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	size_t soap_flag_remainingTotalRequestTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfPutRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse, sizeof(struct ns1__srmStatusOfPutRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfPutRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTPutRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTPutRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfPutRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse, 0, sizeof(struct ns1__srmStatusOfPutRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfPutRequestResponse(struct soap *soap, const struct ns1__srmStatusOfPutRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse);
	if (soap_out_ns1__srmStatusOfPutRequestResponse(soap, tag?tag:"ns1:srmStatusOfPutRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequestResponse * SOAP_FMAC4 soap_get_ns1__srmStatusOfPutRequestResponse(struct soap *soap, struct ns1__srmStatusOfPutRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfPutRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfPutRequestRequest(struct soap *soap, struct ns1__srmStatusOfPutRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfTargetSURLs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfPutRequestRequest(struct soap *soap, const struct ns1__srmStatusOfPutRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfTargetSURLs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfPutRequestRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfPutRequestRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfPutRequestRequest), type))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfTargetSURLs", -1, &a->arrayOfTargetSURLs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequestRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfPutRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfPutRequestRequest *a, const char *type)
{
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfTargetSURLs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfPutRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfPutRequestRequest, sizeof(struct ns1__srmStatusOfPutRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfPutRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfTargetSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfTargetSURLs", &a->arrayOfTargetSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfTargetSURLs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfPutRequestRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfPutRequestRequest, 0, sizeof(struct ns1__srmStatusOfPutRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfPutRequestRequest(struct soap *soap, const struct ns1__srmStatusOfPutRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfPutRequestRequest);
	if (soap_out_ns1__srmStatusOfPutRequestRequest(soap, tag?tag:"ns1:srmStatusOfPutRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequestRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfPutRequestRequest(struct soap *soap, struct ns1__srmStatusOfPutRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfPutRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPrepareToPutResponse(struct soap *soap, struct ns1__srmPrepareToPutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPrepareToPutResponse(struct soap *soap, const struct ns1__srmPrepareToPutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTons1__ArrayOfTPutRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPrepareToPutResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmPrepareToPutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPrepareToPutResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTPutRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPrepareToPutResponse * SOAP_FMAC4 soap_in_ns1__srmPrepareToPutResponse(struct soap *soap, const char *tag, struct ns1__srmPrepareToPutResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	size_t soap_flag_remainingTotalRequestTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPrepareToPutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPrepareToPutResponse, sizeof(struct ns1__srmPrepareToPutResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPrepareToPutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTPutRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTPutRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToPutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPrepareToPutResponse, 0, sizeof(struct ns1__srmPrepareToPutResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPrepareToPutResponse(struct soap *soap, const struct ns1__srmPrepareToPutResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPrepareToPutResponse);
	if (soap_out_ns1__srmPrepareToPutResponse(soap, tag?tag:"ns1:srmPrepareToPutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToPutResponse * SOAP_FMAC4 soap_get_ns1__srmPrepareToPutResponse(struct soap *soap, struct ns1__srmPrepareToPutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPrepareToPutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPrepareToPutRequest(struct soap *soap, struct ns1__srmPrepareToPutRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfFileRequests = NULL;
	soap_default_string(soap, &a->userRequestDescription);
	a->overwriteOption = NULL;
	a->storageSystemInfo = NULL;
	a->desiredTotalRequestTime = NULL;
	a->desiredPinLifeTime = NULL;
	a->desiredFileLifeTime = NULL;
	a->desiredFileStorageType = NULL;
	soap_default_string(soap, &a->targetSpaceToken);
	a->targetFileRetentionPolicyInfo = NULL;
	a->transferParameters = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPrepareToPutRequest(struct soap *soap, const struct ns1__srmPrepareToPutRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfTPutFileRequest(soap, &a->arrayOfFileRequests);
	soap_serialize_string(soap, &a->userRequestDescription);
	soap_serialize_PointerTons1__TOverwriteMode(soap, &a->overwriteOption);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerToint(soap, &a->desiredTotalRequestTime);
	soap_serialize_PointerToint(soap, &a->desiredPinLifeTime);
	soap_serialize_PointerToint(soap, &a->desiredFileLifeTime);
	soap_serialize_PointerTons1__TFileStorageType(soap, &a->desiredFileStorageType);
	soap_serialize_string(soap, &a->targetSpaceToken);
	soap_serialize_PointerTons1__TRetentionPolicyInfo(soap, &a->targetFileRetentionPolicyInfo);
	soap_serialize_PointerTons1__TTransferParameters(soap, &a->transferParameters);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPrepareToPutRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmPrepareToPutRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPrepareToPutRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTPutFileRequest(soap, "arrayOfFileRequests", -1, &a->arrayOfFileRequests, ""))
		return soap->error;
	if (soap_out_string(soap, "userRequestDescription", -1, &a->userRequestDescription, ""))
		return soap->error;
	if (soap_out_PointerTons1__TOverwriteMode(soap, "overwriteOption", -1, &a->overwriteOption, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "desiredTotalRequestTime", -1, &a->desiredTotalRequestTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "desiredPinLifeTime", -1, &a->desiredPinLifeTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "desiredFileLifeTime", -1, &a->desiredFileLifeTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__TFileStorageType(soap, "desiredFileStorageType", -1, &a->desiredFileStorageType, ""))
		return soap->error;
	if (soap_out_string(soap, "targetSpaceToken", -1, &a->targetSpaceToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", -1, &a->targetFileRetentionPolicyInfo, ""))
		return soap->error;
	if (soap_out_PointerTons1__TTransferParameters(soap, "transferParameters", -1, &a->transferParameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPrepareToPutRequest * SOAP_FMAC4 soap_in_ns1__srmPrepareToPutRequest(struct soap *soap, const char *tag, struct ns1__srmPrepareToPutRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfFileRequests = 1;
	size_t soap_flag_userRequestDescription = 1;
	size_t soap_flag_overwriteOption = 1;
	size_t soap_flag_storageSystemInfo = 1;
	size_t soap_flag_desiredTotalRequestTime = 1;
	size_t soap_flag_desiredPinLifeTime = 1;
	size_t soap_flag_desiredFileLifeTime = 1;
	size_t soap_flag_desiredFileStorageType = 1;
	size_t soap_flag_targetSpaceToken = 1;
	size_t soap_flag_targetFileRetentionPolicyInfo = 1;
	size_t soap_flag_transferParameters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPrepareToPutRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPrepareToPutRequest, sizeof(struct ns1__srmPrepareToPutRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPrepareToPutRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfFileRequests && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTPutFileRequest(soap, "arrayOfFileRequests", &a->arrayOfFileRequests, "ns1:ArrayOfTPutFileRequest"))
				{	soap_flag_arrayOfFileRequests--;
					continue;
				}
			if (soap_flag_userRequestDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRequestDescription", &a->userRequestDescription, "xsd:string"))
				{	soap_flag_userRequestDescription--;
					continue;
				}
			if (soap_flag_overwriteOption && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TOverwriteMode(soap, "overwriteOption", &a->overwriteOption, "ns1:TOverwriteMode"))
				{	soap_flag_overwriteOption--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_desiredTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredTotalRequestTime", &a->desiredTotalRequestTime, "xsd:int"))
				{	soap_flag_desiredTotalRequestTime--;
					continue;
				}
			if (soap_flag_desiredPinLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredPinLifeTime", &a->desiredPinLifeTime, "xsd:int"))
				{	soap_flag_desiredPinLifeTime--;
					continue;
				}
			if (soap_flag_desiredFileLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredFileLifeTime", &a->desiredFileLifeTime, "xsd:int"))
				{	soap_flag_desiredFileLifeTime--;
					continue;
				}
			if (soap_flag_desiredFileStorageType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TFileStorageType(soap, "desiredFileStorageType", &a->desiredFileStorageType, "ns1:TFileStorageType"))
				{	soap_flag_desiredFileStorageType--;
					continue;
				}
			if (soap_flag_targetSpaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "targetSpaceToken", &a->targetSpaceToken, "xsd:string"))
				{	soap_flag_targetSpaceToken--;
					continue;
				}
			if (soap_flag_targetFileRetentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", &a->targetFileRetentionPolicyInfo, "ns1:TRetentionPolicyInfo"))
				{	soap_flag_targetFileRetentionPolicyInfo--;
					continue;
				}
			if (soap_flag_transferParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TTransferParameters(soap, "transferParameters", &a->transferParameters, "ns1:TTransferParameters"))
				{	soap_flag_transferParameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToPutRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPrepareToPutRequest, 0, sizeof(struct ns1__srmPrepareToPutRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPrepareToPutRequest(struct soap *soap, const struct ns1__srmPrepareToPutRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPrepareToPutRequest);
	if (soap_out_ns1__srmPrepareToPutRequest(soap, tag?tag:"ns1:srmPrepareToPutRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToPutRequest * SOAP_FMAC4 soap_get_ns1__srmPrepareToPutRequest(struct soap *soap, struct ns1__srmPrepareToPutRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPrepareToPutRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfBringOnlineRequestResponse(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
	a->remainingDeferredStartTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfBringOnlineRequestResponse(struct soap *soap, const struct ns1__srmStatusOfBringOnlineRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
	soap_serialize_PointerToint(soap, &a->remainingDeferredStartTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfBringOnlineRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfBringOnlineRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingDeferredStartTime", -1, &a->remainingDeferredStartTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequestResponse * SOAP_FMAC4 soap_in_ns1__srmStatusOfBringOnlineRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfBringOnlineRequestResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	size_t soap_flag_remainingTotalRequestTime = 1;
	size_t soap_flag_remainingDeferredStartTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfBringOnlineRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse, sizeof(struct ns1__srmStatusOfBringOnlineRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfBringOnlineRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTBringOnlineRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap_flag_remainingDeferredStartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingDeferredStartTime", &a->remainingDeferredStartTime, "xsd:int"))
				{	soap_flag_remainingDeferredStartTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfBringOnlineRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse, 0, sizeof(struct ns1__srmStatusOfBringOnlineRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfBringOnlineRequestResponse(struct soap *soap, const struct ns1__srmStatusOfBringOnlineRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse);
	if (soap_out_ns1__srmStatusOfBringOnlineRequestResponse(soap, tag?tag:"ns1:srmStatusOfBringOnlineRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequestResponse * SOAP_FMAC4 soap_get_ns1__srmStatusOfBringOnlineRequestResponse(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfBringOnlineRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfBringOnlineRequestRequest(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSourceSURLs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfBringOnlineRequestRequest(struct soap *soap, const struct ns1__srmStatusOfBringOnlineRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSourceSURLs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfBringOnlineRequestRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfBringOnlineRequestRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestRequest), type))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSourceSURLs", -1, &a->arrayOfSourceSURLs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequestRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfBringOnlineRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfBringOnlineRequestRequest *a, const char *type)
{
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfSourceSURLs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfBringOnlineRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestRequest, sizeof(struct ns1__srmStatusOfBringOnlineRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfBringOnlineRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSourceSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSourceSURLs", &a->arrayOfSourceSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSourceSURLs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfBringOnlineRequestRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestRequest, 0, sizeof(struct ns1__srmStatusOfBringOnlineRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfBringOnlineRequestRequest(struct soap *soap, const struct ns1__srmStatusOfBringOnlineRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestRequest);
	if (soap_out_ns1__srmStatusOfBringOnlineRequestRequest(soap, tag?tag:"ns1:srmStatusOfBringOnlineRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequestRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfBringOnlineRequestRequest(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfBringOnlineRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmBringOnlineResponse(struct soap *soap, struct ns1__srmBringOnlineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
	a->remainingDeferredStartTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmBringOnlineResponse(struct soap *soap, const struct ns1__srmBringOnlineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
	soap_serialize_PointerToint(soap, &a->remainingDeferredStartTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmBringOnlineResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmBringOnlineResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmBringOnlineResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingDeferredStartTime", -1, &a->remainingDeferredStartTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmBringOnlineResponse * SOAP_FMAC4 soap_in_ns1__srmBringOnlineResponse(struct soap *soap, const char *tag, struct ns1__srmBringOnlineResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	size_t soap_flag_remainingTotalRequestTime = 1;
	size_t soap_flag_remainingDeferredStartTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmBringOnlineResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmBringOnlineResponse, sizeof(struct ns1__srmBringOnlineResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmBringOnlineResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTBringOnlineRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap_flag_remainingDeferredStartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingDeferredStartTime", &a->remainingDeferredStartTime, "xsd:int"))
				{	soap_flag_remainingDeferredStartTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmBringOnlineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmBringOnlineResponse, 0, sizeof(struct ns1__srmBringOnlineResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmBringOnlineResponse(struct soap *soap, const struct ns1__srmBringOnlineResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmBringOnlineResponse);
	if (soap_out_ns1__srmBringOnlineResponse(soap, tag?tag:"ns1:srmBringOnlineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmBringOnlineResponse * SOAP_FMAC4 soap_get_ns1__srmBringOnlineResponse(struct soap *soap, struct ns1__srmBringOnlineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmBringOnlineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmBringOnlineRequest(struct soap *soap, struct ns1__srmBringOnlineRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfFileRequests = NULL;
	soap_default_string(soap, &a->userRequestDescription);
	a->storageSystemInfo = NULL;
	a->desiredFileStorageType = NULL;
	a->desiredTotalRequestTime = NULL;
	a->desiredLifeTime = NULL;
	soap_default_string(soap, &a->targetSpaceToken);
	a->targetFileRetentionPolicyInfo = NULL;
	a->transferParameters = NULL;
	a->deferredStartTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmBringOnlineRequest(struct soap *soap, const struct ns1__srmBringOnlineRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfTGetFileRequest(soap, &a->arrayOfFileRequests);
	soap_serialize_string(soap, &a->userRequestDescription);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerTons1__TFileStorageType(soap, &a->desiredFileStorageType);
	soap_serialize_PointerToint(soap, &a->desiredTotalRequestTime);
	soap_serialize_PointerToint(soap, &a->desiredLifeTime);
	soap_serialize_string(soap, &a->targetSpaceToken);
	soap_serialize_PointerTons1__TRetentionPolicyInfo(soap, &a->targetFileRetentionPolicyInfo);
	soap_serialize_PointerTons1__TTransferParameters(soap, &a->transferParameters);
	soap_serialize_PointerToint(soap, &a->deferredStartTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmBringOnlineRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmBringOnlineRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmBringOnlineRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTGetFileRequest(soap, "arrayOfFileRequests", -1, &a->arrayOfFileRequests, ""))
		return soap->error;
	if (soap_out_string(soap, "userRequestDescription", -1, &a->userRequestDescription, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	if (soap_out_PointerTons1__TFileStorageType(soap, "desiredFileStorageType", -1, &a->desiredFileStorageType, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "desiredTotalRequestTime", -1, &a->desiredTotalRequestTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "desiredLifeTime", -1, &a->desiredLifeTime, ""))
		return soap->error;
	if (soap_out_string(soap, "targetSpaceToken", -1, &a->targetSpaceToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", -1, &a->targetFileRetentionPolicyInfo, ""))
		return soap->error;
	if (soap_out_PointerTons1__TTransferParameters(soap, "transferParameters", -1, &a->transferParameters, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "deferredStartTime", -1, &a->deferredStartTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmBringOnlineRequest * SOAP_FMAC4 soap_in_ns1__srmBringOnlineRequest(struct soap *soap, const char *tag, struct ns1__srmBringOnlineRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfFileRequests = 1;
	size_t soap_flag_userRequestDescription = 1;
	size_t soap_flag_storageSystemInfo = 1;
	size_t soap_flag_desiredFileStorageType = 1;
	size_t soap_flag_desiredTotalRequestTime = 1;
	size_t soap_flag_desiredLifeTime = 1;
	size_t soap_flag_targetSpaceToken = 1;
	size_t soap_flag_targetFileRetentionPolicyInfo = 1;
	size_t soap_flag_transferParameters = 1;
	size_t soap_flag_deferredStartTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmBringOnlineRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmBringOnlineRequest, sizeof(struct ns1__srmBringOnlineRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmBringOnlineRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfFileRequests && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTGetFileRequest(soap, "arrayOfFileRequests", &a->arrayOfFileRequests, "ns1:ArrayOfTGetFileRequest"))
				{	soap_flag_arrayOfFileRequests--;
					continue;
				}
			if (soap_flag_userRequestDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRequestDescription", &a->userRequestDescription, "xsd:string"))
				{	soap_flag_userRequestDescription--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_desiredFileStorageType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TFileStorageType(soap, "desiredFileStorageType", &a->desiredFileStorageType, "ns1:TFileStorageType"))
				{	soap_flag_desiredFileStorageType--;
					continue;
				}
			if (soap_flag_desiredTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredTotalRequestTime", &a->desiredTotalRequestTime, "xsd:int"))
				{	soap_flag_desiredTotalRequestTime--;
					continue;
				}
			if (soap_flag_desiredLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredLifeTime", &a->desiredLifeTime, "xsd:int"))
				{	soap_flag_desiredLifeTime--;
					continue;
				}
			if (soap_flag_targetSpaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "targetSpaceToken", &a->targetSpaceToken, "xsd:string"))
				{	soap_flag_targetSpaceToken--;
					continue;
				}
			if (soap_flag_targetFileRetentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", &a->targetFileRetentionPolicyInfo, "ns1:TRetentionPolicyInfo"))
				{	soap_flag_targetFileRetentionPolicyInfo--;
					continue;
				}
			if (soap_flag_transferParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TTransferParameters(soap, "transferParameters", &a->transferParameters, "ns1:TTransferParameters"))
				{	soap_flag_transferParameters--;
					continue;
				}
			if (soap_flag_deferredStartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "deferredStartTime", &a->deferredStartTime, "xsd:int"))
				{	soap_flag_deferredStartTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmBringOnlineRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmBringOnlineRequest, 0, sizeof(struct ns1__srmBringOnlineRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfFileRequests > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmBringOnlineRequest(struct soap *soap, const struct ns1__srmBringOnlineRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmBringOnlineRequest);
	if (soap_out_ns1__srmBringOnlineRequest(soap, tag?tag:"ns1:srmBringOnlineRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmBringOnlineRequest * SOAP_FMAC4 soap_get_ns1__srmBringOnlineRequest(struct soap *soap, struct ns1__srmBringOnlineRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmBringOnlineRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfGetRequestResponse(struct soap *soap, struct ns1__srmStatusOfGetRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfGetRequestResponse(struct soap *soap, const struct ns1__srmStatusOfGetRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTGetRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfGetRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfGetRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTGetRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequestResponse * SOAP_FMAC4 soap_in_ns1__srmStatusOfGetRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfGetRequestResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	size_t soap_flag_remainingTotalRequestTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfGetRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse, sizeof(struct ns1__srmStatusOfGetRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfGetRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTGetRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTGetRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfGetRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse, 0, sizeof(struct ns1__srmStatusOfGetRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfGetRequestResponse(struct soap *soap, const struct ns1__srmStatusOfGetRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse);
	if (soap_out_ns1__srmStatusOfGetRequestResponse(soap, tag?tag:"ns1:srmStatusOfGetRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequestResponse * SOAP_FMAC4 soap_get_ns1__srmStatusOfGetRequestResponse(struct soap *soap, struct ns1__srmStatusOfGetRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfGetRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfGetRequestRequest(struct soap *soap, struct ns1__srmStatusOfGetRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSourceSURLs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfGetRequestRequest(struct soap *soap, const struct ns1__srmStatusOfGetRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSourceSURLs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfGetRequestRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfGetRequestRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfGetRequestRequest), type))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSourceSURLs", -1, &a->arrayOfSourceSURLs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequestRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfGetRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfGetRequestRequest *a, const char *type)
{
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfSourceSURLs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfGetRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfGetRequestRequest, sizeof(struct ns1__srmStatusOfGetRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfGetRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSourceSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSourceSURLs", &a->arrayOfSourceSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSourceSURLs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfGetRequestRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfGetRequestRequest, 0, sizeof(struct ns1__srmStatusOfGetRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfGetRequestRequest(struct soap *soap, const struct ns1__srmStatusOfGetRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfGetRequestRequest);
	if (soap_out_ns1__srmStatusOfGetRequestRequest(soap, tag?tag:"ns1:srmStatusOfGetRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequestRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfGetRequestRequest(struct soap *soap, struct ns1__srmStatusOfGetRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfGetRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPrepareToGetResponse(struct soap *soap, struct ns1__srmPrepareToGetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPrepareToGetResponse(struct soap *soap, const struct ns1__srmPrepareToGetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTons1__ArrayOfTGetRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPrepareToGetResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmPrepareToGetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPrepareToGetResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTGetRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPrepareToGetResponse * SOAP_FMAC4 soap_in_ns1__srmPrepareToGetResponse(struct soap *soap, const char *tag, struct ns1__srmPrepareToGetResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	size_t soap_flag_remainingTotalRequestTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPrepareToGetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPrepareToGetResponse, sizeof(struct ns1__srmPrepareToGetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPrepareToGetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTGetRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTGetRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPrepareToGetResponse, 0, sizeof(struct ns1__srmPrepareToGetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPrepareToGetResponse(struct soap *soap, const struct ns1__srmPrepareToGetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPrepareToGetResponse);
	if (soap_out_ns1__srmPrepareToGetResponse(soap, tag?tag:"ns1:srmPrepareToGetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToGetResponse * SOAP_FMAC4 soap_get_ns1__srmPrepareToGetResponse(struct soap *soap, struct ns1__srmPrepareToGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPrepareToGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPrepareToGetRequest(struct soap *soap, struct ns1__srmPrepareToGetRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfFileRequests = NULL;
	soap_default_string(soap, &a->userRequestDescription);
	a->storageSystemInfo = NULL;
	a->desiredFileStorageType = NULL;
	a->desiredTotalRequestTime = NULL;
	a->desiredPinLifeTime = NULL;
	soap_default_string(soap, &a->targetSpaceToken);
	a->targetFileRetentionPolicyInfo = NULL;
	a->transferParameters = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPrepareToGetRequest(struct soap *soap, const struct ns1__srmPrepareToGetRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfTGetFileRequest(soap, &a->arrayOfFileRequests);
	soap_serialize_string(soap, &a->userRequestDescription);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerTons1__TFileStorageType(soap, &a->desiredFileStorageType);
	soap_serialize_PointerToint(soap, &a->desiredTotalRequestTime);
	soap_serialize_PointerToint(soap, &a->desiredPinLifeTime);
	soap_serialize_string(soap, &a->targetSpaceToken);
	soap_serialize_PointerTons1__TRetentionPolicyInfo(soap, &a->targetFileRetentionPolicyInfo);
	soap_serialize_PointerTons1__TTransferParameters(soap, &a->transferParameters);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPrepareToGetRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmPrepareToGetRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPrepareToGetRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTGetFileRequest(soap, "arrayOfFileRequests", -1, &a->arrayOfFileRequests, ""))
		return soap->error;
	if (soap_out_string(soap, "userRequestDescription", -1, &a->userRequestDescription, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	if (soap_out_PointerTons1__TFileStorageType(soap, "desiredFileStorageType", -1, &a->desiredFileStorageType, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "desiredTotalRequestTime", -1, &a->desiredTotalRequestTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "desiredPinLifeTime", -1, &a->desiredPinLifeTime, ""))
		return soap->error;
	if (soap_out_string(soap, "targetSpaceToken", -1, &a->targetSpaceToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", -1, &a->targetFileRetentionPolicyInfo, ""))
		return soap->error;
	if (soap_out_PointerTons1__TTransferParameters(soap, "transferParameters", -1, &a->transferParameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPrepareToGetRequest * SOAP_FMAC4 soap_in_ns1__srmPrepareToGetRequest(struct soap *soap, const char *tag, struct ns1__srmPrepareToGetRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfFileRequests = 1;
	size_t soap_flag_userRequestDescription = 1;
	size_t soap_flag_storageSystemInfo = 1;
	size_t soap_flag_desiredFileStorageType = 1;
	size_t soap_flag_desiredTotalRequestTime = 1;
	size_t soap_flag_desiredPinLifeTime = 1;
	size_t soap_flag_targetSpaceToken = 1;
	size_t soap_flag_targetFileRetentionPolicyInfo = 1;
	size_t soap_flag_transferParameters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPrepareToGetRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPrepareToGetRequest, sizeof(struct ns1__srmPrepareToGetRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPrepareToGetRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfFileRequests && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTGetFileRequest(soap, "arrayOfFileRequests", &a->arrayOfFileRequests, "ns1:ArrayOfTGetFileRequest"))
				{	soap_flag_arrayOfFileRequests--;
					continue;
				}
			if (soap_flag_userRequestDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRequestDescription", &a->userRequestDescription, "xsd:string"))
				{	soap_flag_userRequestDescription--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_desiredFileStorageType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TFileStorageType(soap, "desiredFileStorageType", &a->desiredFileStorageType, "ns1:TFileStorageType"))
				{	soap_flag_desiredFileStorageType--;
					continue;
				}
			if (soap_flag_desiredTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredTotalRequestTime", &a->desiredTotalRequestTime, "xsd:int"))
				{	soap_flag_desiredTotalRequestTime--;
					continue;
				}
			if (soap_flag_desiredPinLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredPinLifeTime", &a->desiredPinLifeTime, "xsd:int"))
				{	soap_flag_desiredPinLifeTime--;
					continue;
				}
			if (soap_flag_targetSpaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "targetSpaceToken", &a->targetSpaceToken, "xsd:string"))
				{	soap_flag_targetSpaceToken--;
					continue;
				}
			if (soap_flag_targetFileRetentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", &a->targetFileRetentionPolicyInfo, "ns1:TRetentionPolicyInfo"))
				{	soap_flag_targetFileRetentionPolicyInfo--;
					continue;
				}
			if (soap_flag_transferParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TTransferParameters(soap, "transferParameters", &a->transferParameters, "ns1:TTransferParameters"))
				{	soap_flag_transferParameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToGetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPrepareToGetRequest, 0, sizeof(struct ns1__srmPrepareToGetRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfFileRequests > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPrepareToGetRequest(struct soap *soap, const struct ns1__srmPrepareToGetRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPrepareToGetRequest);
	if (soap_out_ns1__srmPrepareToGetRequest(soap, tag?tag:"ns1:srmPrepareToGetRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToGetRequest * SOAP_FMAC4 soap_get_ns1__srmPrepareToGetRequest(struct soap *soap, struct ns1__srmPrepareToGetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPrepareToGetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmMvResponse(struct soap *soap, struct ns1__srmMvResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmMvResponse(struct soap *soap, const struct ns1__srmMvResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmMvResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmMvResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmMvResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmMvResponse * SOAP_FMAC4 soap_in_ns1__srmMvResponse(struct soap *soap, const char *tag, struct ns1__srmMvResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmMvResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmMvResponse, sizeof(struct ns1__srmMvResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmMvResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMvResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmMvResponse, 0, sizeof(struct ns1__srmMvResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmMvResponse(struct soap *soap, const struct ns1__srmMvResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmMvResponse);
	if (soap_out_ns1__srmMvResponse(soap, tag?tag:"ns1:srmMvResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMvResponse * SOAP_FMAC4 soap_get_ns1__srmMvResponse(struct soap *soap, struct ns1__srmMvResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmMvResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmMvRequest(struct soap *soap, struct ns1__srmMvRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_xsd__anyURI(soap, &a->fromSURL);
	soap_default_xsd__anyURI(soap, &a->toSURL);
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmMvRequest(struct soap *soap, const struct ns1__srmMvRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_xsd__anyURI(soap, &a->fromSURL);
	soap_serialize_xsd__anyURI(soap, &a->toSURL);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmMvRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmMvRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmMvRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "fromSURL", -1, &a->fromSURL, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "toSURL", -1, &a->toSURL, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmMvRequest * SOAP_FMAC4 soap_in_ns1__srmMvRequest(struct soap *soap, const char *tag, struct ns1__srmMvRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_fromSURL = 1;
	size_t soap_flag_toSURL = 1;
	size_t soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmMvRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmMvRequest, sizeof(struct ns1__srmMvRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmMvRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_fromSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "fromSURL", &a->fromSURL, "xsd:anyURI"))
				{	soap_flag_fromSURL--;
					continue;
				}
			if (soap_flag_toSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "toSURL", &a->toSURL, "xsd:anyURI"))
				{	soap_flag_toSURL--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMvRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmMvRequest, 0, sizeof(struct ns1__srmMvRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fromSURL > 0 || soap_flag_toSURL > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmMvRequest(struct soap *soap, const struct ns1__srmMvRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmMvRequest);
	if (soap_out_ns1__srmMvRequest(soap, tag?tag:"ns1:srmMvRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMvRequest * SOAP_FMAC4 soap_get_ns1__srmMvRequest(struct soap *soap, struct ns1__srmMvRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmMvRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfLsRequestResponse(struct soap *soap, struct ns1__srmStatusOfLsRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->details = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfLsRequestResponse(struct soap *soap, const struct ns1__srmStatusOfLsRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTMetaDataPathDetail(soap, &a->details);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfLsRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfLsRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTMetaDataPathDetail(soap, "details", -1, &a->details, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequestResponse * SOAP_FMAC4 soap_in_ns1__srmStatusOfLsRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfLsRequestResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_details = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfLsRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse, sizeof(struct ns1__srmStatusOfLsRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfLsRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_details && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTMetaDataPathDetail(soap, "details", &a->details, "ns1:ArrayOfTMetaDataPathDetail"))
				{	soap_flag_details--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfLsRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse, 0, sizeof(struct ns1__srmStatusOfLsRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfLsRequestResponse(struct soap *soap, const struct ns1__srmStatusOfLsRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse);
	if (soap_out_ns1__srmStatusOfLsRequestResponse(soap, tag?tag:"ns1:srmStatusOfLsRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequestResponse * SOAP_FMAC4 soap_get_ns1__srmStatusOfLsRequestResponse(struct soap *soap, struct ns1__srmStatusOfLsRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfLsRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfLsRequestRequest(struct soap *soap, struct ns1__srmStatusOfLsRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->requestToken);
	a->offset = NULL;
	a->count = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfLsRequestRequest(struct soap *soap, const struct ns1__srmStatusOfLsRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerToint(soap, &a->offset);
	soap_serialize_PointerToint(soap, &a->count);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfLsRequestRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfLsRequestRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfLsRequestRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "count", -1, &a->count, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequestRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfLsRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfLsRequestRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_offset = 1;
	size_t soap_flag_count = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfLsRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfLsRequestRequest, sizeof(struct ns1__srmStatusOfLsRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfLsRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_count && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "count", &a->count, "xsd:int"))
				{	soap_flag_count--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfLsRequestRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfLsRequestRequest, 0, sizeof(struct ns1__srmStatusOfLsRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfLsRequestRequest(struct soap *soap, const struct ns1__srmStatusOfLsRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfLsRequestRequest);
	if (soap_out_ns1__srmStatusOfLsRequestRequest(soap, tag?tag:"ns1:srmStatusOfLsRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequestRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfLsRequestRequest(struct soap *soap, struct ns1__srmStatusOfLsRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfLsRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmLsResponse(struct soap *soap, struct ns1__srmLsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->details = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmLsResponse(struct soap *soap, const struct ns1__srmLsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTons1__ArrayOfTMetaDataPathDetail(soap, &a->details);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmLsResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmLsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmLsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTMetaDataPathDetail(soap, "details", -1, &a->details, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmLsResponse * SOAP_FMAC4 soap_in_ns1__srmLsResponse(struct soap *soap, const char *tag, struct ns1__srmLsResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_details = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmLsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmLsResponse, sizeof(struct ns1__srmLsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmLsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_details && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTMetaDataPathDetail(soap, "details", &a->details, "ns1:ArrayOfTMetaDataPathDetail"))
				{	soap_flag_details--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmLsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmLsResponse, 0, sizeof(struct ns1__srmLsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmLsResponse(struct soap *soap, const struct ns1__srmLsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmLsResponse);
	if (soap_out_ns1__srmLsResponse(soap, tag?tag:"ns1:srmLsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmLsResponse * SOAP_FMAC4 soap_get_ns1__srmLsResponse(struct soap *soap, struct ns1__srmLsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmLsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmLsRequest(struct soap *soap, struct ns1__srmLsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
	a->storageSystemInfo = NULL;
	a->fileStorageType = NULL;
	a->fullDetailedList = NULL;
	a->allLevelRecursive = NULL;
	a->numOfLevels = NULL;
	a->offset = NULL;
	a->count = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmLsRequest(struct soap *soap, const struct ns1__srmLsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerTons1__TFileStorageType(soap, &a->fileStorageType);
	soap_serialize_PointerToxsd__boolean(soap, &a->fullDetailedList);
	soap_serialize_PointerToxsd__boolean(soap, &a->allLevelRecursive);
	soap_serialize_PointerToint(soap, &a->numOfLevels);
	soap_serialize_PointerToint(soap, &a->offset);
	soap_serialize_PointerToint(soap, &a->count);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmLsRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmLsRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmLsRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	if (soap_out_PointerTons1__TFileStorageType(soap, "fileStorageType", -1, &a->fileStorageType, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "fullDetailedList", -1, &a->fullDetailedList, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "allLevelRecursive", -1, &a->allLevelRecursive, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "numOfLevels", -1, &a->numOfLevels, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "count", -1, &a->count, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmLsRequest * SOAP_FMAC4 soap_in_ns1__srmLsRequest(struct soap *soap, const char *tag, struct ns1__srmLsRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfSURLs = 1;
	size_t soap_flag_storageSystemInfo = 1;
	size_t soap_flag_fileStorageType = 1;
	size_t soap_flag_fullDetailedList = 1;
	size_t soap_flag_allLevelRecursive = 1;
	size_t soap_flag_numOfLevels = 1;
	size_t soap_flag_offset = 1;
	size_t soap_flag_count = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmLsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmLsRequest, sizeof(struct ns1__srmLsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmLsRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_fileStorageType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TFileStorageType(soap, "fileStorageType", &a->fileStorageType, "ns1:TFileStorageType"))
				{	soap_flag_fileStorageType--;
					continue;
				}
			if (soap_flag_fullDetailedList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "fullDetailedList", &a->fullDetailedList, "xsd:boolean"))
				{	soap_flag_fullDetailedList--;
					continue;
				}
			if (soap_flag_allLevelRecursive && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "allLevelRecursive", &a->allLevelRecursive, "xsd:boolean"))
				{	soap_flag_allLevelRecursive--;
					continue;
				}
			if (soap_flag_numOfLevels && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numOfLevels", &a->numOfLevels, "xsd:int"))
				{	soap_flag_numOfLevels--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_count && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "count", &a->count, "xsd:int"))
				{	soap_flag_count--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmLsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmLsRequest, 0, sizeof(struct ns1__srmLsRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmLsRequest(struct soap *soap, const struct ns1__srmLsRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmLsRequest);
	if (soap_out_ns1__srmLsRequest(soap, tag?tag:"ns1:srmLsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmLsRequest * SOAP_FMAC4 soap_get_ns1__srmLsRequest(struct soap *soap, struct ns1__srmLsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmLsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmRmResponse(struct soap *soap, struct ns1__srmRmResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmRmResponse(struct soap *soap, const struct ns1__srmRmResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmRmResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmRmResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmRmResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmRmResponse * SOAP_FMAC4 soap_in_ns1__srmRmResponse(struct soap *soap, const char *tag, struct ns1__srmRmResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmRmResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmRmResponse, sizeof(struct ns1__srmRmResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmRmResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmRmResponse, 0, sizeof(struct ns1__srmRmResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmRmResponse(struct soap *soap, const struct ns1__srmRmResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmRmResponse);
	if (soap_out_ns1__srmRmResponse(soap, tag?tag:"ns1:srmRmResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmResponse * SOAP_FMAC4 soap_get_ns1__srmRmResponse(struct soap *soap, struct ns1__srmRmResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmRmResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmRmRequest(struct soap *soap, struct ns1__srmRmRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmRmRequest(struct soap *soap, const struct ns1__srmRmRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmRmRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmRmRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmRmRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmRmRequest * SOAP_FMAC4 soap_in_ns1__srmRmRequest(struct soap *soap, const char *tag, struct ns1__srmRmRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfSURLs = 1;
	size_t soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmRmRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmRmRequest, sizeof(struct ns1__srmRmRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmRmRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmRmRequest, 0, sizeof(struct ns1__srmRmRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmRmRequest(struct soap *soap, const struct ns1__srmRmRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmRmRequest);
	if (soap_out_ns1__srmRmRequest(soap, tag?tag:"ns1:srmRmRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmRequest * SOAP_FMAC4 soap_get_ns1__srmRmRequest(struct soap *soap, struct ns1__srmRmRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmRmRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmRmdirResponse(struct soap *soap, struct ns1__srmRmdirResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmRmdirResponse(struct soap *soap, const struct ns1__srmRmdirResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmRmdirResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmRmdirResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmRmdirResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmRmdirResponse * SOAP_FMAC4 soap_in_ns1__srmRmdirResponse(struct soap *soap, const char *tag, struct ns1__srmRmdirResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmRmdirResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmRmdirResponse, sizeof(struct ns1__srmRmdirResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmRmdirResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmdirResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmRmdirResponse, 0, sizeof(struct ns1__srmRmdirResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmRmdirResponse(struct soap *soap, const struct ns1__srmRmdirResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmRmdirResponse);
	if (soap_out_ns1__srmRmdirResponse(soap, tag?tag:"ns1:srmRmdirResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmdirResponse * SOAP_FMAC4 soap_get_ns1__srmRmdirResponse(struct soap *soap, struct ns1__srmRmdirResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmRmdirResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmRmdirRequest(struct soap *soap, struct ns1__srmRmdirRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_xsd__anyURI(soap, &a->SURL);
	a->storageSystemInfo = NULL;
	a->recursive = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmRmdirRequest(struct soap *soap, const struct ns1__srmRmdirRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_xsd__anyURI(soap, &a->SURL);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerToxsd__boolean(soap, &a->recursive);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmRmdirRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmRmdirRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmRmdirRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "SURL", -1, &a->SURL, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "recursive", -1, &a->recursive, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmRmdirRequest * SOAP_FMAC4 soap_in_ns1__srmRmdirRequest(struct soap *soap, const char *tag, struct ns1__srmRmdirRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_SURL = 1;
	size_t soap_flag_storageSystemInfo = 1;
	size_t soap_flag_recursive = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmRmdirRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmRmdirRequest, sizeof(struct ns1__srmRmdirRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmRmdirRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_SURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "SURL", &a->SURL, "xsd:anyURI"))
				{	soap_flag_SURL--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_recursive && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "recursive", &a->recursive, "xsd:boolean"))
				{	soap_flag_recursive--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmdirRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmRmdirRequest, 0, sizeof(struct ns1__srmRmdirRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SURL > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmRmdirRequest(struct soap *soap, const struct ns1__srmRmdirRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmRmdirRequest);
	if (soap_out_ns1__srmRmdirRequest(soap, tag?tag:"ns1:srmRmdirRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmdirRequest * SOAP_FMAC4 soap_get_ns1__srmRmdirRequest(struct soap *soap, struct ns1__srmRmdirRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmRmdirRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmMkdirResponse(struct soap *soap, struct ns1__srmMkdirResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmMkdirResponse(struct soap *soap, const struct ns1__srmMkdirResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmMkdirResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmMkdirResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmMkdirResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmMkdirResponse * SOAP_FMAC4 soap_in_ns1__srmMkdirResponse(struct soap *soap, const char *tag, struct ns1__srmMkdirResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmMkdirResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmMkdirResponse, sizeof(struct ns1__srmMkdirResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmMkdirResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMkdirResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmMkdirResponse, 0, sizeof(struct ns1__srmMkdirResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmMkdirResponse(struct soap *soap, const struct ns1__srmMkdirResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmMkdirResponse);
	if (soap_out_ns1__srmMkdirResponse(soap, tag?tag:"ns1:srmMkdirResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMkdirResponse * SOAP_FMAC4 soap_get_ns1__srmMkdirResponse(struct soap *soap, struct ns1__srmMkdirResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmMkdirResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmMkdirRequest(struct soap *soap, struct ns1__srmMkdirRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_xsd__anyURI(soap, &a->SURL);
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmMkdirRequest(struct soap *soap, const struct ns1__srmMkdirRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_xsd__anyURI(soap, &a->SURL);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmMkdirRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmMkdirRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmMkdirRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "SURL", -1, &a->SURL, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmMkdirRequest * SOAP_FMAC4 soap_in_ns1__srmMkdirRequest(struct soap *soap, const char *tag, struct ns1__srmMkdirRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_SURL = 1;
	size_t soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmMkdirRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmMkdirRequest, sizeof(struct ns1__srmMkdirRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmMkdirRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_SURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "SURL", &a->SURL, "xsd:anyURI"))
				{	soap_flag_SURL--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMkdirRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmMkdirRequest, 0, sizeof(struct ns1__srmMkdirRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SURL > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmMkdirRequest(struct soap *soap, const struct ns1__srmMkdirRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmMkdirRequest);
	if (soap_out_ns1__srmMkdirRequest(soap, tag?tag:"ns1:srmMkdirRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMkdirRequest * SOAP_FMAC4 soap_get_ns1__srmMkdirRequest(struct soap *soap, struct ns1__srmMkdirRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmMkdirRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetPermissionResponse(struct soap *soap, struct ns1__srmGetPermissionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfPermissionReturns = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetPermissionResponse(struct soap *soap, const struct ns1__srmGetPermissionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTPermissionReturn(soap, &a->arrayOfPermissionReturns);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetPermissionResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmGetPermissionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetPermissionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTPermissionReturn(soap, "arrayOfPermissionReturns", -1, &a->arrayOfPermissionReturns, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetPermissionResponse * SOAP_FMAC4 soap_in_ns1__srmGetPermissionResponse(struct soap *soap, const char *tag, struct ns1__srmGetPermissionResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfPermissionReturns = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetPermissionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetPermissionResponse, sizeof(struct ns1__srmGetPermissionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetPermissionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfPermissionReturns && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTPermissionReturn(soap, "arrayOfPermissionReturns", &a->arrayOfPermissionReturns, "ns1:ArrayOfTPermissionReturn"))
				{	soap_flag_arrayOfPermissionReturns--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetPermissionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetPermissionResponse, 0, sizeof(struct ns1__srmGetPermissionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetPermissionResponse(struct soap *soap, const struct ns1__srmGetPermissionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetPermissionResponse);
	if (soap_out_ns1__srmGetPermissionResponse(soap, tag?tag:"ns1:srmGetPermissionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetPermissionResponse * SOAP_FMAC4 soap_get_ns1__srmGetPermissionResponse(struct soap *soap, struct ns1__srmGetPermissionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetPermissionRequest(struct soap *soap, struct ns1__srmGetPermissionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetPermissionRequest(struct soap *soap, const struct ns1__srmGetPermissionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetPermissionRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmGetPermissionRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetPermissionRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetPermissionRequest * SOAP_FMAC4 soap_in_ns1__srmGetPermissionRequest(struct soap *soap, const char *tag, struct ns1__srmGetPermissionRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfSURLs = 1;
	size_t soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetPermissionRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetPermissionRequest, sizeof(struct ns1__srmGetPermissionRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetPermissionRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetPermissionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetPermissionRequest, 0, sizeof(struct ns1__srmGetPermissionRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetPermissionRequest(struct soap *soap, const struct ns1__srmGetPermissionRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetPermissionRequest);
	if (soap_out_ns1__srmGetPermissionRequest(soap, tag?tag:"ns1:srmGetPermissionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetPermissionRequest * SOAP_FMAC4 soap_get_ns1__srmGetPermissionRequest(struct soap *soap, struct ns1__srmGetPermissionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetPermissionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmCheckPermissionResponse(struct soap *soap, struct ns1__srmCheckPermissionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfPermissions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmCheckPermissionResponse(struct soap *soap, const struct ns1__srmCheckPermissionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTSURLPermissionReturn(soap, &a->arrayOfPermissions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmCheckPermissionResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmCheckPermissionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmCheckPermissionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTSURLPermissionReturn(soap, "arrayOfPermissions", -1, &a->arrayOfPermissions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmCheckPermissionResponse * SOAP_FMAC4 soap_in_ns1__srmCheckPermissionResponse(struct soap *soap, const char *tag, struct ns1__srmCheckPermissionResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfPermissions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmCheckPermissionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmCheckPermissionResponse, sizeof(struct ns1__srmCheckPermissionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmCheckPermissionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfPermissions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTSURLPermissionReturn(soap, "arrayOfPermissions", &a->arrayOfPermissions, "ns1:ArrayOfTSURLPermissionReturn"))
				{	soap_flag_arrayOfPermissions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCheckPermissionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmCheckPermissionResponse, 0, sizeof(struct ns1__srmCheckPermissionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmCheckPermissionResponse(struct soap *soap, const struct ns1__srmCheckPermissionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmCheckPermissionResponse);
	if (soap_out_ns1__srmCheckPermissionResponse(soap, tag?tag:"ns1:srmCheckPermissionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCheckPermissionResponse * SOAP_FMAC4 soap_get_ns1__srmCheckPermissionResponse(struct soap *soap, struct ns1__srmCheckPermissionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmCheckPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmCheckPermissionRequest(struct soap *soap, struct ns1__srmCheckPermissionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->arrayOfSURLs = NULL;
	soap_default_string(soap, &a->authorizationID);
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmCheckPermissionRequest(struct soap *soap, const struct ns1__srmCheckPermissionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmCheckPermissionRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmCheckPermissionRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmCheckPermissionRequest), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmCheckPermissionRequest * SOAP_FMAC4 soap_in_ns1__srmCheckPermissionRequest(struct soap *soap, const char *tag, struct ns1__srmCheckPermissionRequest *a, const char *type)
{
	size_t soap_flag_arrayOfSURLs = 1;
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmCheckPermissionRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmCheckPermissionRequest, sizeof(struct ns1__srmCheckPermissionRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmCheckPermissionRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCheckPermissionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmCheckPermissionRequest, 0, sizeof(struct ns1__srmCheckPermissionRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmCheckPermissionRequest(struct soap *soap, const struct ns1__srmCheckPermissionRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmCheckPermissionRequest);
	if (soap_out_ns1__srmCheckPermissionRequest(soap, tag?tag:"ns1:srmCheckPermissionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCheckPermissionRequest * SOAP_FMAC4 soap_get_ns1__srmCheckPermissionRequest(struct soap *soap, struct ns1__srmCheckPermissionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmCheckPermissionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmSetPermissionResponse(struct soap *soap, struct ns1__srmSetPermissionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmSetPermissionResponse(struct soap *soap, const struct ns1__srmSetPermissionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmSetPermissionResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmSetPermissionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmSetPermissionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmSetPermissionResponse * SOAP_FMAC4 soap_in_ns1__srmSetPermissionResponse(struct soap *soap, const char *tag, struct ns1__srmSetPermissionResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmSetPermissionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmSetPermissionResponse, sizeof(struct ns1__srmSetPermissionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmSetPermissionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSetPermissionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmSetPermissionResponse, 0, sizeof(struct ns1__srmSetPermissionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmSetPermissionResponse(struct soap *soap, const struct ns1__srmSetPermissionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmSetPermissionResponse);
	if (soap_out_ns1__srmSetPermissionResponse(soap, tag?tag:"ns1:srmSetPermissionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSetPermissionResponse * SOAP_FMAC4 soap_get_ns1__srmSetPermissionResponse(struct soap *soap, struct ns1__srmSetPermissionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmSetPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmSetPermissionRequest(struct soap *soap, struct ns1__srmSetPermissionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_xsd__anyURI(soap, &a->SURL);
	soap_default_ns1__TPermissionType(soap, &a->permissionType);
	a->ownerPermission = NULL;
	a->arrayOfUserPermissions = NULL;
	a->arrayOfGroupPermissions = NULL;
	a->otherPermission = NULL;
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmSetPermissionRequest(struct soap *soap, const struct ns1__srmSetPermissionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_xsd__anyURI(soap, &a->SURL);
	soap_serialize_PointerTons1__TPermissionMode(soap, &a->ownerPermission);
	soap_serialize_PointerTons1__ArrayOfTUserPermission(soap, &a->arrayOfUserPermissions);
	soap_serialize_PointerTons1__ArrayOfTGroupPermission(soap, &a->arrayOfGroupPermissions);
	soap_serialize_PointerTons1__TPermissionMode(soap, &a->otherPermission);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmSetPermissionRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmSetPermissionRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmSetPermissionRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "SURL", -1, &a->SURL, ""))
		return soap->error;
	if (soap_out_ns1__TPermissionType(soap, "permissionType", -1, &a->permissionType, ""))
		return soap->error;
	if (soap_out_PointerTons1__TPermissionMode(soap, "ownerPermission", -1, &a->ownerPermission, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTUserPermission(soap, "arrayOfUserPermissions", -1, &a->arrayOfUserPermissions, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTGroupPermission(soap, "arrayOfGroupPermissions", -1, &a->arrayOfGroupPermissions, ""))
		return soap->error;
	if (soap_out_PointerTons1__TPermissionMode(soap, "otherPermission", -1, &a->otherPermission, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmSetPermissionRequest * SOAP_FMAC4 soap_in_ns1__srmSetPermissionRequest(struct soap *soap, const char *tag, struct ns1__srmSetPermissionRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_SURL = 1;
	size_t soap_flag_permissionType = 1;
	size_t soap_flag_ownerPermission = 1;
	size_t soap_flag_arrayOfUserPermissions = 1;
	size_t soap_flag_arrayOfGroupPermissions = 1;
	size_t soap_flag_otherPermission = 1;
	size_t soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmSetPermissionRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmSetPermissionRequest, sizeof(struct ns1__srmSetPermissionRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmSetPermissionRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_SURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "SURL", &a->SURL, "xsd:anyURI"))
				{	soap_flag_SURL--;
					continue;
				}
			if (soap_flag_permissionType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__TPermissionType(soap, "permissionType", &a->permissionType, "ns1:TPermissionType"))
				{	soap_flag_permissionType--;
					continue;
				}
			if (soap_flag_ownerPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TPermissionMode(soap, "ownerPermission", &a->ownerPermission, "ns1:TPermissionMode"))
				{	soap_flag_ownerPermission--;
					continue;
				}
			if (soap_flag_arrayOfUserPermissions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTUserPermission(soap, "arrayOfUserPermissions", &a->arrayOfUserPermissions, "ns1:ArrayOfTUserPermission"))
				{	soap_flag_arrayOfUserPermissions--;
					continue;
				}
			if (soap_flag_arrayOfGroupPermissions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTGroupPermission(soap, "arrayOfGroupPermissions", &a->arrayOfGroupPermissions, "ns1:ArrayOfTGroupPermission"))
				{	soap_flag_arrayOfGroupPermissions--;
					continue;
				}
			if (soap_flag_otherPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TPermissionMode(soap, "otherPermission", &a->otherPermission, "ns1:TPermissionMode"))
				{	soap_flag_otherPermission--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSetPermissionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmSetPermissionRequest, 0, sizeof(struct ns1__srmSetPermissionRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SURL > 0 || soap_flag_permissionType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmSetPermissionRequest(struct soap *soap, const struct ns1__srmSetPermissionRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmSetPermissionRequest);
	if (soap_out_ns1__srmSetPermissionRequest(soap, tag?tag:"ns1:srmSetPermissionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSetPermissionRequest * SOAP_FMAC4 soap_get_ns1__srmSetPermissionRequest(struct soap *soap, struct ns1__srmSetPermissionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmSetPermissionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetSpaceTokensResponse(struct soap *soap, struct ns1__srmGetSpaceTokensResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfSpaceTokens = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetSpaceTokensResponse(struct soap *soap, const struct ns1__srmGetSpaceTokensResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfString(soap, &a->arrayOfSpaceTokens);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetSpaceTokensResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmGetSpaceTokensResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetSpaceTokensResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "arrayOfSpaceTokens", -1, &a->arrayOfSpaceTokens, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokensResponse * SOAP_FMAC4 soap_in_ns1__srmGetSpaceTokensResponse(struct soap *soap, const char *tag, struct ns1__srmGetSpaceTokensResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfSpaceTokens = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetSpaceTokensResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetSpaceTokensResponse, sizeof(struct ns1__srmGetSpaceTokensResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetSpaceTokensResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfSpaceTokens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "arrayOfSpaceTokens", &a->arrayOfSpaceTokens, "ns1:ArrayOfString"))
				{	soap_flag_arrayOfSpaceTokens--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceTokensResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetSpaceTokensResponse, 0, sizeof(struct ns1__srmGetSpaceTokensResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetSpaceTokensResponse(struct soap *soap, const struct ns1__srmGetSpaceTokensResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetSpaceTokensResponse);
	if (soap_out_ns1__srmGetSpaceTokensResponse(soap, tag?tag:"ns1:srmGetSpaceTokensResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokensResponse * SOAP_FMAC4 soap_get_ns1__srmGetSpaceTokensResponse(struct soap *soap, struct ns1__srmGetSpaceTokensResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetSpaceTokensResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetSpaceTokensRequest(struct soap *soap, struct ns1__srmGetSpaceTokensRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->userSpaceTokenDescription);
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetSpaceTokensRequest(struct soap *soap, const struct ns1__srmGetSpaceTokensRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->userSpaceTokenDescription);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetSpaceTokensRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmGetSpaceTokensRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetSpaceTokensRequest), type))
		return soap->error;
	if (soap_out_string(soap, "userSpaceTokenDescription", -1, &a->userSpaceTokenDescription, ""))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokensRequest * SOAP_FMAC4 soap_in_ns1__srmGetSpaceTokensRequest(struct soap *soap, const char *tag, struct ns1__srmGetSpaceTokensRequest *a, const char *type)
{
	size_t soap_flag_userSpaceTokenDescription = 1;
	size_t soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetSpaceTokensRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetSpaceTokensRequest, sizeof(struct ns1__srmGetSpaceTokensRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetSpaceTokensRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userSpaceTokenDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSpaceTokenDescription", &a->userSpaceTokenDescription, "xsd:string"))
				{	soap_flag_userSpaceTokenDescription--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceTokensRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetSpaceTokensRequest, 0, sizeof(struct ns1__srmGetSpaceTokensRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetSpaceTokensRequest(struct soap *soap, const struct ns1__srmGetSpaceTokensRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetSpaceTokensRequest);
	if (soap_out_ns1__srmGetSpaceTokensRequest(soap, tag?tag:"ns1:srmGetSpaceTokensRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokensRequest * SOAP_FMAC4 soap_get_ns1__srmGetSpaceTokensRequest(struct soap *soap, struct ns1__srmGetSpaceTokensRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetSpaceTokensRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPurgeFromSpaceResponse(struct soap *soap, struct ns1__srmPurgeFromSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPurgeFromSpaceResponse(struct soap *soap, const struct ns1__srmPurgeFromSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPurgeFromSpaceResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmPurgeFromSpaceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpaceResponse * SOAP_FMAC4 soap_in_ns1__srmPurgeFromSpaceResponse(struct soap *soap, const char *tag, struct ns1__srmPurgeFromSpaceResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPurgeFromSpaceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse, sizeof(struct ns1__srmPurgeFromSpaceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPurgeFromSpaceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPurgeFromSpaceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse, 0, sizeof(struct ns1__srmPurgeFromSpaceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPurgeFromSpaceResponse(struct soap *soap, const struct ns1__srmPurgeFromSpaceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse);
	if (soap_out_ns1__srmPurgeFromSpaceResponse(soap, tag?tag:"ns1:srmPurgeFromSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpaceResponse * SOAP_FMAC4 soap_get_ns1__srmPurgeFromSpaceResponse(struct soap *soap, struct ns1__srmPurgeFromSpaceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPurgeFromSpaceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmPurgeFromSpaceRequest(struct soap *soap, struct ns1__srmPurgeFromSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
	soap_default_string(soap, &a->spaceToken);
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmPurgeFromSpaceRequest(struct soap *soap, const struct ns1__srmPurgeFromSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_string(soap, &a->spaceToken);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmPurgeFromSpaceRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmPurgeFromSpaceRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmPurgeFromSpaceRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, ""))
		return soap->error;
	if (soap_out_string(soap, "spaceToken", -1, &a->spaceToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpaceRequest * SOAP_FMAC4 soap_in_ns1__srmPurgeFromSpaceRequest(struct soap *soap, const char *tag, struct ns1__srmPurgeFromSpaceRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfSURLs = 1;
	size_t soap_flag_spaceToken = 1;
	size_t soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmPurgeFromSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmPurgeFromSpaceRequest, sizeof(struct ns1__srmPurgeFromSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmPurgeFromSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPurgeFromSpaceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmPurgeFromSpaceRequest, 0, sizeof(struct ns1__srmPurgeFromSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0 || soap_flag_spaceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmPurgeFromSpaceRequest(struct soap *soap, const struct ns1__srmPurgeFromSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmPurgeFromSpaceRequest);
	if (soap_out_ns1__srmPurgeFromSpaceRequest(soap, tag?tag:"ns1:srmPurgeFromSpaceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpaceRequest * SOAP_FMAC4 soap_get_ns1__srmPurgeFromSpaceRequest(struct soap *soap, struct ns1__srmPurgeFromSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmPurgeFromSpaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, const struct ns1__srmExtendFileLifeTimeInSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmExtendFileLifeTimeInSpaceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpaceResponse * SOAP_FMAC4 soap_in_ns1__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeInSpaceResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmExtendFileLifeTimeInSpaceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse, sizeof(struct ns1__srmExtendFileLifeTimeInSpaceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmExtendFileLifeTimeInSpaceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTSURLLifetimeReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeInSpaceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse, 0, sizeof(struct ns1__srmExtendFileLifeTimeInSpaceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, const struct ns1__srmExtendFileLifeTimeInSpaceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse);
	if (soap_out_ns1__srmExtendFileLifeTimeInSpaceResponse(soap, tag?tag:"ns1:srmExtendFileLifeTimeInSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpaceResponse * SOAP_FMAC4 soap_get_ns1__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmExtendFileLifeTimeInSpaceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->spaceToken);
	a->arrayOfSURLs = NULL;
	a->newLifeTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, const struct ns1__srmExtendFileLifeTimeInSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->spaceToken);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_PointerToint(soap, &a->newLifeTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmExtendFileLifeTimeInSpaceRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_string(soap, "spaceToken", -1, &a->spaceToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "newLifeTime", -1, &a->newLifeTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpaceRequest * SOAP_FMAC4 soap_in_ns1__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeInSpaceRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_spaceToken = 1;
	size_t soap_flag_arrayOfSURLs = 1;
	size_t soap_flag_newLifeTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmExtendFileLifeTimeInSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceRequest, sizeof(struct ns1__srmExtendFileLifeTimeInSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmExtendFileLifeTimeInSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_newLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "newLifeTime", &a->newLifeTime, "xsd:int"))
				{	soap_flag_newLifeTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeInSpaceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceRequest, 0, sizeof(struct ns1__srmExtendFileLifeTimeInSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_spaceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, const struct ns1__srmExtendFileLifeTimeInSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceRequest);
	if (soap_out_ns1__srmExtendFileLifeTimeInSpaceRequest(soap, tag?tag:"ns1:srmExtendFileLifeTimeInSpaceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpaceRequest * SOAP_FMAC4 soap_get_ns1__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmExtendFileLifeTimeInSpaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->estimatedProcessingTime = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, const struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerToint(soap, &a->estimatedProcessingTime);
	soap_serialize_PointerTons1__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "estimatedProcessingTime", -1, &a->estimatedProcessingTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse * SOAP_FMAC4 soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_estimatedProcessingTime = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_estimatedProcessingTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedProcessingTime", &a->estimatedProcessingTime, "xsd:int"))
				{	soap_flag_estimatedProcessingTime--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse, 0, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, const struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse);
	if (soap_out_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag?tag:"ns1:srmStatusOfChangeSpaceForFilesRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse * SOAP_FMAC4 soap_get_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->requestToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, const struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->requestToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_requestToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestRequest, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestRequest, 0, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, const struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestRequest);
	if (soap_out_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag?tag:"ns1:srmStatusOfChangeSpaceForFilesRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmChangeSpaceForFilesResponse(struct soap *soap, struct ns1__srmChangeSpaceForFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->estimatedProcessingTime = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmChangeSpaceForFilesResponse(struct soap *soap, const struct ns1__srmChangeSpaceForFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerToint(soap, &a->estimatedProcessingTime);
	soap_serialize_PointerTons1__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmChangeSpaceForFilesResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmChangeSpaceForFilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "estimatedProcessingTime", -1, &a->estimatedProcessingTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFilesResponse * SOAP_FMAC4 soap_in_ns1__srmChangeSpaceForFilesResponse(struct soap *soap, const char *tag, struct ns1__srmChangeSpaceForFilesResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_estimatedProcessingTime = 1;
	size_t soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmChangeSpaceForFilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse, sizeof(struct ns1__srmChangeSpaceForFilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmChangeSpaceForFilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_estimatedProcessingTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedProcessingTime", &a->estimatedProcessingTime, "xsd:int"))
				{	soap_flag_estimatedProcessingTime--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "ns1:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmChangeSpaceForFilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse, 0, sizeof(struct ns1__srmChangeSpaceForFilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmChangeSpaceForFilesResponse(struct soap *soap, const struct ns1__srmChangeSpaceForFilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse);
	if (soap_out_ns1__srmChangeSpaceForFilesResponse(soap, tag?tag:"ns1:srmChangeSpaceForFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFilesResponse * SOAP_FMAC4 soap_get_ns1__srmChangeSpaceForFilesResponse(struct soap *soap, struct ns1__srmChangeSpaceForFilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmChangeSpaceForFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmChangeSpaceForFilesRequest(struct soap *soap, struct ns1__srmChangeSpaceForFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
	soap_default_string(soap, &a->targetSpaceToken);
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmChangeSpaceForFilesRequest(struct soap *soap, const struct ns1__srmChangeSpaceForFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_string(soap, &a->targetSpaceToken);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmChangeSpaceForFilesRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmChangeSpaceForFilesRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmChangeSpaceForFilesRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, ""))
		return soap->error;
	if (soap_out_string(soap, "targetSpaceToken", -1, &a->targetSpaceToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFilesRequest * SOAP_FMAC4 soap_in_ns1__srmChangeSpaceForFilesRequest(struct soap *soap, const char *tag, struct ns1__srmChangeSpaceForFilesRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfSURLs = 1;
	size_t soap_flag_targetSpaceToken = 1;
	size_t soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmChangeSpaceForFilesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmChangeSpaceForFilesRequest, sizeof(struct ns1__srmChangeSpaceForFilesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmChangeSpaceForFilesRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "ns1:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_targetSpaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "targetSpaceToken", &a->targetSpaceToken, "xsd:string"))
				{	soap_flag_targetSpaceToken--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmChangeSpaceForFilesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmChangeSpaceForFilesRequest, 0, sizeof(struct ns1__srmChangeSpaceForFilesRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0 || soap_flag_targetSpaceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmChangeSpaceForFilesRequest(struct soap *soap, const struct ns1__srmChangeSpaceForFilesRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmChangeSpaceForFilesRequest);
	if (soap_out_ns1__srmChangeSpaceForFilesRequest(soap, tag?tag:"ns1:srmChangeSpaceForFilesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFilesRequest * SOAP_FMAC4 soap_get_ns1__srmChangeSpaceForFilesRequest(struct soap *soap, struct ns1__srmChangeSpaceForFilesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmChangeSpaceForFilesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetSpaceMetaDataResponse(struct soap *soap, struct ns1__srmGetSpaceMetaDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfSpaceDetails = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetSpaceMetaDataResponse(struct soap *soap, const struct ns1__srmGetSpaceMetaDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTons1__ArrayOfTMetaDataSpace(soap, &a->arrayOfSpaceDetails);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetSpaceMetaDataResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmGetSpaceMetaDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTMetaDataSpace(soap, "arrayOfSpaceDetails", -1, &a->arrayOfSpaceDetails, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaDataResponse * SOAP_FMAC4 soap_in_ns1__srmGetSpaceMetaDataResponse(struct soap *soap, const char *tag, struct ns1__srmGetSpaceMetaDataResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_arrayOfSpaceDetails = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetSpaceMetaDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse, sizeof(struct ns1__srmGetSpaceMetaDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetSpaceMetaDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfSpaceDetails && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTMetaDataSpace(soap, "arrayOfSpaceDetails", &a->arrayOfSpaceDetails, "ns1:ArrayOfTMetaDataSpace"))
				{	soap_flag_arrayOfSpaceDetails--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceMetaDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse, 0, sizeof(struct ns1__srmGetSpaceMetaDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetSpaceMetaDataResponse(struct soap *soap, const struct ns1__srmGetSpaceMetaDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse);
	if (soap_out_ns1__srmGetSpaceMetaDataResponse(soap, tag?tag:"ns1:srmGetSpaceMetaDataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaDataResponse * SOAP_FMAC4 soap_get_ns1__srmGetSpaceMetaDataResponse(struct soap *soap, struct ns1__srmGetSpaceMetaDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetSpaceMetaDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmGetSpaceMetaDataRequest(struct soap *soap, struct ns1__srmGetSpaceMetaDataRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSpaceTokens = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmGetSpaceMetaDataRequest(struct soap *soap, const struct ns1__srmGetSpaceMetaDataRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTons1__ArrayOfString(soap, &a->arrayOfSpaceTokens);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmGetSpaceMetaDataRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmGetSpaceMetaDataRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmGetSpaceMetaDataRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "arrayOfSpaceTokens", -1, &a->arrayOfSpaceTokens, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaDataRequest * SOAP_FMAC4 soap_in_ns1__srmGetSpaceMetaDataRequest(struct soap *soap, const char *tag, struct ns1__srmGetSpaceMetaDataRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_arrayOfSpaceTokens = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmGetSpaceMetaDataRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmGetSpaceMetaDataRequest, sizeof(struct ns1__srmGetSpaceMetaDataRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmGetSpaceMetaDataRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSpaceTokens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "arrayOfSpaceTokens", &a->arrayOfSpaceTokens, "ns1:ArrayOfString"))
				{	soap_flag_arrayOfSpaceTokens--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceMetaDataRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmGetSpaceMetaDataRequest, 0, sizeof(struct ns1__srmGetSpaceMetaDataRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSpaceTokens > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmGetSpaceMetaDataRequest(struct soap *soap, const struct ns1__srmGetSpaceMetaDataRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmGetSpaceMetaDataRequest);
	if (soap_out_ns1__srmGetSpaceMetaDataRequest(soap, tag?tag:"ns1:srmGetSpaceMetaDataRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaDataRequest * SOAP_FMAC4 soap_get_ns1__srmGetSpaceMetaDataRequest(struct soap *soap, struct ns1__srmGetSpaceMetaDataRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmGetSpaceMetaDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->sizeOfTotalSpace = NULL;
	a->sizeOfGuaranteedSpace = NULL;
	a->lifetimeGranted = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, const struct ns1__srmStatusOfUpdateSpaceRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfTotalSpace);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfGuaranteedSpace);
	soap_serialize_PointerToint(soap, &a->lifetimeGranted);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfUpdateSpaceRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "sizeOfTotalSpace", -1, &a->sizeOfTotalSpace, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "sizeOfGuaranteedSpace", -1, &a->sizeOfGuaranteedSpace, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "lifetimeGranted", -1, &a->lifetimeGranted, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequestResponse * SOAP_FMAC4 soap_in_ns1__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfUpdateSpaceRequestResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_sizeOfTotalSpace = 1;
	size_t soap_flag_sizeOfGuaranteedSpace = 1;
	size_t soap_flag_lifetimeGranted = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfUpdateSpaceRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse, sizeof(struct ns1__srmStatusOfUpdateSpaceRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfUpdateSpaceRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_sizeOfTotalSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfTotalSpace", &a->sizeOfTotalSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfTotalSpace--;
					continue;
				}
			if (soap_flag_sizeOfGuaranteedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfGuaranteedSpace", &a->sizeOfGuaranteedSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfGuaranteedSpace--;
					continue;
				}
			if (soap_flag_lifetimeGranted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeGranted", &a->lifetimeGranted, "xsd:int"))
				{	soap_flag_lifetimeGranted--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfUpdateSpaceRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse, 0, sizeof(struct ns1__srmStatusOfUpdateSpaceRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, const struct ns1__srmStatusOfUpdateSpaceRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse);
	if (soap_out_ns1__srmStatusOfUpdateSpaceRequestResponse(soap, tag?tag:"ns1:srmStatusOfUpdateSpaceRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequestResponse * SOAP_FMAC4 soap_get_ns1__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfUpdateSpaceRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->requestToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, const struct ns1__srmStatusOfUpdateSpaceRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->requestToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfUpdateSpaceRequestRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequestRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfUpdateSpaceRequestRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_requestToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfUpdateSpaceRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestRequest, sizeof(struct ns1__srmStatusOfUpdateSpaceRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfUpdateSpaceRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfUpdateSpaceRequestRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestRequest, 0, sizeof(struct ns1__srmStatusOfUpdateSpaceRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, const struct ns1__srmStatusOfUpdateSpaceRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestRequest);
	if (soap_out_ns1__srmStatusOfUpdateSpaceRequestRequest(soap, tag?tag:"ns1:srmStatusOfUpdateSpaceRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequestRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfUpdateSpaceRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmUpdateSpaceResponse(struct soap *soap, struct ns1__srmUpdateSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->sizeOfTotalSpace = NULL;
	a->sizeOfGuaranteedSpace = NULL;
	a->lifetimeGranted = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmUpdateSpaceResponse(struct soap *soap, const struct ns1__srmUpdateSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfTotalSpace);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfGuaranteedSpace);
	soap_serialize_PointerToint(soap, &a->lifetimeGranted);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmUpdateSpaceResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmUpdateSpaceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmUpdateSpaceResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "sizeOfTotalSpace", -1, &a->sizeOfTotalSpace, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "sizeOfGuaranteedSpace", -1, &a->sizeOfGuaranteedSpace, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "lifetimeGranted", -1, &a->lifetimeGranted, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmUpdateSpaceResponse * SOAP_FMAC4 soap_in_ns1__srmUpdateSpaceResponse(struct soap *soap, const char *tag, struct ns1__srmUpdateSpaceResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_sizeOfTotalSpace = 1;
	size_t soap_flag_sizeOfGuaranteedSpace = 1;
	size_t soap_flag_lifetimeGranted = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmUpdateSpaceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmUpdateSpaceResponse, sizeof(struct ns1__srmUpdateSpaceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmUpdateSpaceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_sizeOfTotalSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfTotalSpace", &a->sizeOfTotalSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfTotalSpace--;
					continue;
				}
			if (soap_flag_sizeOfGuaranteedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfGuaranteedSpace", &a->sizeOfGuaranteedSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfGuaranteedSpace--;
					continue;
				}
			if (soap_flag_lifetimeGranted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeGranted", &a->lifetimeGranted, "xsd:int"))
				{	soap_flag_lifetimeGranted--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmUpdateSpaceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmUpdateSpaceResponse, 0, sizeof(struct ns1__srmUpdateSpaceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmUpdateSpaceResponse(struct soap *soap, const struct ns1__srmUpdateSpaceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmUpdateSpaceResponse);
	if (soap_out_ns1__srmUpdateSpaceResponse(soap, tag?tag:"ns1:srmUpdateSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmUpdateSpaceResponse * SOAP_FMAC4 soap_get_ns1__srmUpdateSpaceResponse(struct soap *soap, struct ns1__srmUpdateSpaceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmUpdateSpaceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmUpdateSpaceRequest(struct soap *soap, struct ns1__srmUpdateSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->spaceToken);
	a->newSizeOfTotalSpaceDesired = NULL;
	a->newSizeOfGuaranteedSpaceDesired = NULL;
	a->newLifeTime = NULL;
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmUpdateSpaceRequest(struct soap *soap, const struct ns1__srmUpdateSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->spaceToken);
	soap_serialize_PointerTounsignedLONG64(soap, &a->newSizeOfTotalSpaceDesired);
	soap_serialize_PointerTounsignedLONG64(soap, &a->newSizeOfGuaranteedSpaceDesired);
	soap_serialize_PointerToint(soap, &a->newLifeTime);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmUpdateSpaceRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmUpdateSpaceRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmUpdateSpaceRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_string(soap, "spaceToken", -1, &a->spaceToken, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "newSizeOfTotalSpaceDesired", -1, &a->newSizeOfTotalSpaceDesired, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "newSizeOfGuaranteedSpaceDesired", -1, &a->newSizeOfGuaranteedSpaceDesired, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "newLifeTime", -1, &a->newLifeTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmUpdateSpaceRequest * SOAP_FMAC4 soap_in_ns1__srmUpdateSpaceRequest(struct soap *soap, const char *tag, struct ns1__srmUpdateSpaceRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_spaceToken = 1;
	size_t soap_flag_newSizeOfTotalSpaceDesired = 1;
	size_t soap_flag_newSizeOfGuaranteedSpaceDesired = 1;
	size_t soap_flag_newLifeTime = 1;
	size_t soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmUpdateSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmUpdateSpaceRequest, sizeof(struct ns1__srmUpdateSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmUpdateSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap_flag_newSizeOfTotalSpaceDesired && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "newSizeOfTotalSpaceDesired", &a->newSizeOfTotalSpaceDesired, "xsd:unsignedLong"))
				{	soap_flag_newSizeOfTotalSpaceDesired--;
					continue;
				}
			if (soap_flag_newSizeOfGuaranteedSpaceDesired && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "newSizeOfGuaranteedSpaceDesired", &a->newSizeOfGuaranteedSpaceDesired, "xsd:unsignedLong"))
				{	soap_flag_newSizeOfGuaranteedSpaceDesired--;
					continue;
				}
			if (soap_flag_newLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "newLifeTime", &a->newLifeTime, "xsd:int"))
				{	soap_flag_newLifeTime--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmUpdateSpaceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmUpdateSpaceRequest, 0, sizeof(struct ns1__srmUpdateSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_spaceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmUpdateSpaceRequest(struct soap *soap, const struct ns1__srmUpdateSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmUpdateSpaceRequest);
	if (soap_out_ns1__srmUpdateSpaceRequest(soap, tag?tag:"ns1:srmUpdateSpaceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmUpdateSpaceRequest * SOAP_FMAC4 soap_get_ns1__srmUpdateSpaceRequest(struct soap *soap, struct ns1__srmUpdateSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmUpdateSpaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmReleaseSpaceResponse(struct soap *soap, struct ns1__srmReleaseSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmReleaseSpaceResponse(struct soap *soap, const struct ns1__srmReleaseSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmReleaseSpaceResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmReleaseSpaceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmReleaseSpaceResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmReleaseSpaceResponse * SOAP_FMAC4 soap_in_ns1__srmReleaseSpaceResponse(struct soap *soap, const char *tag, struct ns1__srmReleaseSpaceResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmReleaseSpaceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmReleaseSpaceResponse, sizeof(struct ns1__srmReleaseSpaceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmReleaseSpaceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseSpaceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmReleaseSpaceResponse, 0, sizeof(struct ns1__srmReleaseSpaceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmReleaseSpaceResponse(struct soap *soap, const struct ns1__srmReleaseSpaceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmReleaseSpaceResponse);
	if (soap_out_ns1__srmReleaseSpaceResponse(soap, tag?tag:"ns1:srmReleaseSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseSpaceResponse * SOAP_FMAC4 soap_get_ns1__srmReleaseSpaceResponse(struct soap *soap, struct ns1__srmReleaseSpaceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmReleaseSpaceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmReleaseSpaceRequest(struct soap *soap, struct ns1__srmReleaseSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->spaceToken);
	a->storageSystemInfo = NULL;
	a->forceFileRelease = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmReleaseSpaceRequest(struct soap *soap, const struct ns1__srmReleaseSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->spaceToken);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerToxsd__boolean(soap, &a->forceFileRelease);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmReleaseSpaceRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmReleaseSpaceRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmReleaseSpaceRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_string(soap, "spaceToken", -1, &a->spaceToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "forceFileRelease", -1, &a->forceFileRelease, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmReleaseSpaceRequest * SOAP_FMAC4 soap_in_ns1__srmReleaseSpaceRequest(struct soap *soap, const char *tag, struct ns1__srmReleaseSpaceRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_spaceToken = 1;
	size_t soap_flag_storageSystemInfo = 1;
	size_t soap_flag_forceFileRelease = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmReleaseSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmReleaseSpaceRequest, sizeof(struct ns1__srmReleaseSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmReleaseSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_forceFileRelease && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "forceFileRelease", &a->forceFileRelease, "xsd:boolean"))
				{	soap_flag_forceFileRelease--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseSpaceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmReleaseSpaceRequest, 0, sizeof(struct ns1__srmReleaseSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_spaceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmReleaseSpaceRequest(struct soap *soap, const struct ns1__srmReleaseSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmReleaseSpaceRequest);
	if (soap_out_ns1__srmReleaseSpaceRequest(soap, tag?tag:"ns1:srmReleaseSpaceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseSpaceRequest * SOAP_FMAC4 soap_get_ns1__srmReleaseSpaceRequest(struct soap *soap, struct ns1__srmReleaseSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmReleaseSpaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->estimatedProcessingTime = NULL;
	a->retentionPolicyInfo = NULL;
	a->sizeOfTotalReservedSpace = NULL;
	a->sizeOfGuaranteedReservedSpace = NULL;
	a->lifetimeOfReservedSpace = NULL;
	soap_default_string(soap, &a->spaceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, const struct ns1__srmStatusOfReserveSpaceRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerToint(soap, &a->estimatedProcessingTime);
	soap_serialize_PointerTons1__TRetentionPolicyInfo(soap, &a->retentionPolicyInfo);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfTotalReservedSpace);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfGuaranteedReservedSpace);
	soap_serialize_PointerToint(soap, &a->lifetimeOfReservedSpace);
	soap_serialize_string(soap, &a->spaceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfReserveSpaceRequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "estimatedProcessingTime", -1, &a->estimatedProcessingTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__TRetentionPolicyInfo(soap, "retentionPolicyInfo", -1, &a->retentionPolicyInfo, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "sizeOfTotalReservedSpace", -1, &a->sizeOfTotalReservedSpace, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "sizeOfGuaranteedReservedSpace", -1, &a->sizeOfGuaranteedReservedSpace, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "lifetimeOfReservedSpace", -1, &a->lifetimeOfReservedSpace, ""))
		return soap->error;
	if (soap_out_string(soap, "spaceToken", -1, &a->spaceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequestResponse * SOAP_FMAC4 soap_in_ns1__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfReserveSpaceRequestResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_estimatedProcessingTime = 1;
	size_t soap_flag_retentionPolicyInfo = 1;
	size_t soap_flag_sizeOfTotalReservedSpace = 1;
	size_t soap_flag_sizeOfGuaranteedReservedSpace = 1;
	size_t soap_flag_lifetimeOfReservedSpace = 1;
	size_t soap_flag_spaceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfReserveSpaceRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse, sizeof(struct ns1__srmStatusOfReserveSpaceRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfReserveSpaceRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_estimatedProcessingTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedProcessingTime", &a->estimatedProcessingTime, "xsd:int"))
				{	soap_flag_estimatedProcessingTime--;
					continue;
				}
			if (soap_flag_retentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TRetentionPolicyInfo(soap, "retentionPolicyInfo", &a->retentionPolicyInfo, "ns1:TRetentionPolicyInfo"))
				{	soap_flag_retentionPolicyInfo--;
					continue;
				}
			if (soap_flag_sizeOfTotalReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfTotalReservedSpace", &a->sizeOfTotalReservedSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfTotalReservedSpace--;
					continue;
				}
			if (soap_flag_sizeOfGuaranteedReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfGuaranteedReservedSpace", &a->sizeOfGuaranteedReservedSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfGuaranteedReservedSpace--;
					continue;
				}
			if (soap_flag_lifetimeOfReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeOfReservedSpace", &a->lifetimeOfReservedSpace, "xsd:int"))
				{	soap_flag_lifetimeOfReservedSpace--;
					continue;
				}
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfReserveSpaceRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse, 0, sizeof(struct ns1__srmStatusOfReserveSpaceRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, const struct ns1__srmStatusOfReserveSpaceRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse);
	if (soap_out_ns1__srmStatusOfReserveSpaceRequestResponse(soap, tag?tag:"ns1:srmStatusOfReserveSpaceRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequestResponse * SOAP_FMAC4 soap_get_ns1__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfReserveSpaceRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->requestToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, const struct ns1__srmStatusOfReserveSpaceRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->requestToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmStatusOfReserveSpaceRequestRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequestRequest * SOAP_FMAC4 soap_in_ns1__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfReserveSpaceRequestRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_requestToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmStatusOfReserveSpaceRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestRequest, sizeof(struct ns1__srmStatusOfReserveSpaceRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmStatusOfReserveSpaceRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfReserveSpaceRequestRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestRequest, 0, sizeof(struct ns1__srmStatusOfReserveSpaceRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, const struct ns1__srmStatusOfReserveSpaceRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestRequest);
	if (soap_out_ns1__srmStatusOfReserveSpaceRequestRequest(soap, tag?tag:"ns1:srmStatusOfReserveSpaceRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequestRequest * SOAP_FMAC4 soap_get_ns1__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmStatusOfReserveSpaceRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmReserveSpaceResponse(struct soap *soap, struct ns1__srmReserveSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->estimatedProcessingTime = NULL;
	a->retentionPolicyInfo = NULL;
	a->sizeOfTotalReservedSpace = NULL;
	a->sizeOfGuaranteedReservedSpace = NULL;
	a->lifetimeOfReservedSpace = NULL;
	soap_default_string(soap, &a->spaceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmReserveSpaceResponse(struct soap *soap, const struct ns1__srmReserveSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerToint(soap, &a->estimatedProcessingTime);
	soap_serialize_PointerTons1__TRetentionPolicyInfo(soap, &a->retentionPolicyInfo);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfTotalReservedSpace);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfGuaranteedReservedSpace);
	soap_serialize_PointerToint(soap, &a->lifetimeOfReservedSpace);
	soap_serialize_string(soap, &a->spaceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmReserveSpaceResponse(struct soap *soap, const char *tag, int id, const struct ns1__srmReserveSpaceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmReserveSpaceResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "estimatedProcessingTime", -1, &a->estimatedProcessingTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__TRetentionPolicyInfo(soap, "retentionPolicyInfo", -1, &a->retentionPolicyInfo, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "sizeOfTotalReservedSpace", -1, &a->sizeOfTotalReservedSpace, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "sizeOfGuaranteedReservedSpace", -1, &a->sizeOfGuaranteedReservedSpace, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "lifetimeOfReservedSpace", -1, &a->lifetimeOfReservedSpace, ""))
		return soap->error;
	if (soap_out_string(soap, "spaceToken", -1, &a->spaceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmReserveSpaceResponse * SOAP_FMAC4 soap_in_ns1__srmReserveSpaceResponse(struct soap *soap, const char *tag, struct ns1__srmReserveSpaceResponse *a, const char *type)
{
	size_t soap_flag_returnStatus = 1;
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_estimatedProcessingTime = 1;
	size_t soap_flag_retentionPolicyInfo = 1;
	size_t soap_flag_sizeOfTotalReservedSpace = 1;
	size_t soap_flag_sizeOfGuaranteedReservedSpace = 1;
	size_t soap_flag_lifetimeOfReservedSpace = 1;
	size_t soap_flag_spaceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmReserveSpaceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmReserveSpaceResponse, sizeof(struct ns1__srmReserveSpaceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmReserveSpaceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "returnStatus", &a->returnStatus, "ns1:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_estimatedProcessingTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedProcessingTime", &a->estimatedProcessingTime, "xsd:int"))
				{	soap_flag_estimatedProcessingTime--;
					continue;
				}
			if (soap_flag_retentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TRetentionPolicyInfo(soap, "retentionPolicyInfo", &a->retentionPolicyInfo, "ns1:TRetentionPolicyInfo"))
				{	soap_flag_retentionPolicyInfo--;
					continue;
				}
			if (soap_flag_sizeOfTotalReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfTotalReservedSpace", &a->sizeOfTotalReservedSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfTotalReservedSpace--;
					continue;
				}
			if (soap_flag_sizeOfGuaranteedReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfGuaranteedReservedSpace", &a->sizeOfGuaranteedReservedSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfGuaranteedReservedSpace--;
					continue;
				}
			if (soap_flag_lifetimeOfReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeOfReservedSpace", &a->lifetimeOfReservedSpace, "xsd:int"))
				{	soap_flag_lifetimeOfReservedSpace--;
					continue;
				}
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReserveSpaceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmReserveSpaceResponse, 0, sizeof(struct ns1__srmReserveSpaceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmReserveSpaceResponse(struct soap *soap, const struct ns1__srmReserveSpaceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmReserveSpaceResponse);
	if (soap_out_ns1__srmReserveSpaceResponse(soap, tag?tag:"ns1:srmReserveSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReserveSpaceResponse * SOAP_FMAC4 soap_get_ns1__srmReserveSpaceResponse(struct soap *soap, struct ns1__srmReserveSpaceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmReserveSpaceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__srmReserveSpaceRequest(struct soap *soap, struct ns1__srmReserveSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->userSpaceTokenDescription);
	a->retentionPolicyInfo = NULL;
	a->desiredSizeOfTotalSpace = NULL;
	soap_default_unsignedLONG64(soap, &a->desiredSizeOfGuaranteedSpace);
	a->desiredLifetimeOfReservedSpace = NULL;
	a->arrayOfExpectedFileSizes = NULL;
	a->storageSystemInfo = NULL;
	a->transferParameters = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__srmReserveSpaceRequest(struct soap *soap, const struct ns1__srmReserveSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->userSpaceTokenDescription);
	soap_serialize_PointerTons1__TRetentionPolicyInfo(soap, &a->retentionPolicyInfo);
	soap_serialize_PointerTounsignedLONG64(soap, &a->desiredSizeOfTotalSpace);
	soap_embedded(soap, &a->desiredSizeOfGuaranteedSpace, SOAP_TYPE_unsignedLONG64);
	soap_serialize_PointerToint(soap, &a->desiredLifetimeOfReservedSpace);
	soap_serialize_PointerTons1__ArrayOfUnsignedLong(soap, &a->arrayOfExpectedFileSizes);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerTons1__TTransferParameters(soap, &a->transferParameters);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__srmReserveSpaceRequest(struct soap *soap, const char *tag, int id, const struct ns1__srmReserveSpaceRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__srmReserveSpaceRequest), type))
		return soap->error;
	if (soap_out_string(soap, "authorizationID", -1, &a->authorizationID, ""))
		return soap->error;
	if (soap_out_string(soap, "userSpaceTokenDescription", -1, &a->userSpaceTokenDescription, ""))
		return soap->error;
	if (soap_out_PointerTons1__TRetentionPolicyInfo(soap, "retentionPolicyInfo", -1, &a->retentionPolicyInfo, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "desiredSizeOfTotalSpace", -1, &a->desiredSizeOfTotalSpace, ""))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "desiredSizeOfGuaranteedSpace", -1, &a->desiredSizeOfGuaranteedSpace, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "desiredLifetimeOfReservedSpace", -1, &a->desiredLifetimeOfReservedSpace, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfUnsignedLong(soap, "arrayOfExpectedFileSizes", -1, &a->arrayOfExpectedFileSizes, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, ""))
		return soap->error;
	if (soap_out_PointerTons1__TTransferParameters(soap, "transferParameters", -1, &a->transferParameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__srmReserveSpaceRequest * SOAP_FMAC4 soap_in_ns1__srmReserveSpaceRequest(struct soap *soap, const char *tag, struct ns1__srmReserveSpaceRequest *a, const char *type)
{
	size_t soap_flag_authorizationID = 1;
	size_t soap_flag_userSpaceTokenDescription = 1;
	size_t soap_flag_retentionPolicyInfo = 1;
	size_t soap_flag_desiredSizeOfTotalSpace = 1;
	size_t soap_flag_desiredSizeOfGuaranteedSpace = 1;
	size_t soap_flag_desiredLifetimeOfReservedSpace = 1;
	size_t soap_flag_arrayOfExpectedFileSizes = 1;
	size_t soap_flag_storageSystemInfo = 1;
	size_t soap_flag_transferParameters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__srmReserveSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__srmReserveSpaceRequest, sizeof(struct ns1__srmReserveSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__srmReserveSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_userSpaceTokenDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSpaceTokenDescription", &a->userSpaceTokenDescription, "xsd:string"))
				{	soap_flag_userSpaceTokenDescription--;
					continue;
				}
			if (soap_flag_retentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TRetentionPolicyInfo(soap, "retentionPolicyInfo", &a->retentionPolicyInfo, "ns1:TRetentionPolicyInfo"))
				{	soap_flag_retentionPolicyInfo--;
					continue;
				}
			if (soap_flag_desiredSizeOfTotalSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "desiredSizeOfTotalSpace", &a->desiredSizeOfTotalSpace, "xsd:unsignedLong"))
				{	soap_flag_desiredSizeOfTotalSpace--;
					continue;
				}
			if (soap_flag_desiredSizeOfGuaranteedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "desiredSizeOfGuaranteedSpace", &a->desiredSizeOfGuaranteedSpace, "xsd:unsignedLong"))
				{	soap_flag_desiredSizeOfGuaranteedSpace--;
					continue;
				}
			if (soap_flag_desiredLifetimeOfReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredLifetimeOfReservedSpace", &a->desiredLifetimeOfReservedSpace, "xsd:int"))
				{	soap_flag_desiredLifetimeOfReservedSpace--;
					continue;
				}
			if (soap_flag_arrayOfExpectedFileSizes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfUnsignedLong(soap, "arrayOfExpectedFileSizes", &a->arrayOfExpectedFileSizes, "ns1:ArrayOfUnsignedLong"))
				{	soap_flag_arrayOfExpectedFileSizes--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_transferParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TTransferParameters(soap, "transferParameters", &a->transferParameters, "ns1:TTransferParameters"))
				{	soap_flag_transferParameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReserveSpaceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__srmReserveSpaceRequest, 0, sizeof(struct ns1__srmReserveSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_retentionPolicyInfo > 0 || soap_flag_desiredSizeOfGuaranteedSpace > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__srmReserveSpaceRequest(struct soap *soap, const struct ns1__srmReserveSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__srmReserveSpaceRequest);
	if (soap_out_ns1__srmReserveSpaceRequest(soap, tag?tag:"ns1:srmReserveSpaceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReserveSpaceRequest * SOAP_FMAC4 soap_get_ns1__srmReserveSpaceRequest(struct soap *soap, struct ns1__srmReserveSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__srmReserveSpaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTSupportedTransferProtocol(struct soap *soap, struct ns1__ArrayOfTSupportedTransferProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeprotocolArray = 0;
	a->protocolArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTSupportedTransferProtocol(struct soap *soap, const struct ns1__ArrayOfTSupportedTransferProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->protocolArray)
	{	int i;
		for (i = 0; i < a->__sizeprotocolArray; i++)
		{
			soap_embedded(soap, a->protocolArray + i, SOAP_TYPE_ns1__TSupportedTransferProtocol);
			soap_serialize_ns1__TSupportedTransferProtocol(soap, a->protocolArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTSupportedTransferProtocol(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTSupportedTransferProtocol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTSupportedTransferProtocol), type))
		return soap->error;
	if (a->protocolArray)
	{	int i;
		for (i = 0; i < a->__sizeprotocolArray; i++)
			if (soap_out_ns1__TSupportedTransferProtocol(soap, "protocolArray", -1, a->protocolArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTSupportedTransferProtocol * SOAP_FMAC4 soap_in_ns1__ArrayOfTSupportedTransferProtocol(struct soap *soap, const char *tag, struct ns1__ArrayOfTSupportedTransferProtocol *a, const char *type)
{
	struct soap_blist *soap_blist_protocolArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTSupportedTransferProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTSupportedTransferProtocol, sizeof(struct ns1__ArrayOfTSupportedTransferProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTSupportedTransferProtocol(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "protocolArray", 1, NULL))
			{	if (a->protocolArray == NULL)
				{	if (soap_blist_protocolArray == NULL)
						soap_blist_protocolArray = soap_new_block(soap);
					a->protocolArray = (struct ns1__TSupportedTransferProtocol *)soap_push_block(soap, soap_blist_protocolArray, sizeof(struct ns1__TSupportedTransferProtocol));
					if (a->protocolArray == NULL)
						return NULL;
					soap_default_ns1__TSupportedTransferProtocol(soap, a->protocolArray);
				}soap_revert(soap);
				if (soap_in_ns1__TSupportedTransferProtocol(soap, "protocolArray", a->protocolArray, "ns1:TSupportedTransferProtocol"))
				{	a->__sizeprotocolArray++;
					a->protocolArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->protocolArray)
			soap_pop_block(soap, soap_blist_protocolArray);
		if (a->__sizeprotocolArray)
			a->protocolArray = (struct ns1__TSupportedTransferProtocol *)soap_save_block(soap, soap_blist_protocolArray, NULL, 1);
		else
		{	a->protocolArray = NULL;
			if (soap_blist_protocolArray)
				soap_end_block(soap, soap_blist_protocolArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTSupportedTransferProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTSupportedTransferProtocol, 0, sizeof(struct ns1__ArrayOfTSupportedTransferProtocol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeprotocolArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTSupportedTransferProtocol(struct soap *soap, const struct ns1__ArrayOfTSupportedTransferProtocol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTSupportedTransferProtocol);
	if (soap_out_ns1__ArrayOfTSupportedTransferProtocol(soap, tag?tag:"ns1:ArrayOfTSupportedTransferProtocol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTSupportedTransferProtocol * SOAP_FMAC4 soap_get_ns1__ArrayOfTSupportedTransferProtocol(struct soap *soap, struct ns1__ArrayOfTSupportedTransferProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTSupportedTransferProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TSupportedTransferProtocol(struct soap *soap, struct ns1__TSupportedTransferProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->transferProtocol);
	a->attributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TSupportedTransferProtocol(struct soap *soap, const struct ns1__TSupportedTransferProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->transferProtocol);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->attributes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TSupportedTransferProtocol(struct soap *soap, const char *tag, int id, const struct ns1__TSupportedTransferProtocol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TSupportedTransferProtocol), type))
		return soap->error;
	if (soap_out_string(soap, "transferProtocol", -1, &a->transferProtocol, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "attributes", -1, &a->attributes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TSupportedTransferProtocol * SOAP_FMAC4 soap_in_ns1__TSupportedTransferProtocol(struct soap *soap, const char *tag, struct ns1__TSupportedTransferProtocol *a, const char *type)
{
	size_t soap_flag_transferProtocol = 1;
	size_t soap_flag_attributes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TSupportedTransferProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TSupportedTransferProtocol, sizeof(struct ns1__TSupportedTransferProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TSupportedTransferProtocol(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_transferProtocol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "transferProtocol", &a->transferProtocol, "xsd:string"))
				{	soap_flag_transferProtocol--;
					continue;
				}
			if (soap_flag_attributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "attributes", &a->attributes, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_attributes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TSupportedTransferProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TSupportedTransferProtocol, 0, sizeof(struct ns1__TSupportedTransferProtocol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_transferProtocol > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TSupportedTransferProtocol(struct soap *soap, const struct ns1__TSupportedTransferProtocol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TSupportedTransferProtocol);
	if (soap_out_ns1__TSupportedTransferProtocol(soap, tag?tag:"ns1:TSupportedTransferProtocol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TSupportedTransferProtocol * SOAP_FMAC4 soap_get_ns1__TSupportedTransferProtocol(struct soap *soap, struct ns1__TSupportedTransferProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TSupportedTransferProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTRequestTokenReturn(struct soap *soap, struct ns1__ArrayOfTRequestTokenReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizetokenArray = 0;
	a->tokenArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTRequestTokenReturn(struct soap *soap, const struct ns1__ArrayOfTRequestTokenReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->tokenArray)
	{	int i;
		for (i = 0; i < a->__sizetokenArray; i++)
		{
			soap_embedded(soap, a->tokenArray + i, SOAP_TYPE_ns1__TRequestTokenReturn);
			soap_serialize_ns1__TRequestTokenReturn(soap, a->tokenArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTRequestTokenReturn(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTRequestTokenReturn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTRequestTokenReturn), type))
		return soap->error;
	if (a->tokenArray)
	{	int i;
		for (i = 0; i < a->__sizetokenArray; i++)
			if (soap_out_ns1__TRequestTokenReturn(soap, "tokenArray", -1, a->tokenArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTRequestTokenReturn * SOAP_FMAC4 soap_in_ns1__ArrayOfTRequestTokenReturn(struct soap *soap, const char *tag, struct ns1__ArrayOfTRequestTokenReturn *a, const char *type)
{
	struct soap_blist *soap_blist_tokenArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTRequestTokenReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTRequestTokenReturn, sizeof(struct ns1__ArrayOfTRequestTokenReturn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTRequestTokenReturn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tokenArray", 1, NULL))
			{	if (a->tokenArray == NULL)
				{	if (soap_blist_tokenArray == NULL)
						soap_blist_tokenArray = soap_new_block(soap);
					a->tokenArray = (struct ns1__TRequestTokenReturn *)soap_push_block(soap, soap_blist_tokenArray, sizeof(struct ns1__TRequestTokenReturn));
					if (a->tokenArray == NULL)
						return NULL;
					soap_default_ns1__TRequestTokenReturn(soap, a->tokenArray);
				}soap_revert(soap);
				if (soap_in_ns1__TRequestTokenReturn(soap, "tokenArray", a->tokenArray, "ns1:TRequestTokenReturn"))
				{	a->__sizetokenArray++;
					a->tokenArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tokenArray)
			soap_pop_block(soap, soap_blist_tokenArray);
		if (a->__sizetokenArray)
			a->tokenArray = (struct ns1__TRequestTokenReturn *)soap_save_block(soap, soap_blist_tokenArray, NULL, 1);
		else
		{	a->tokenArray = NULL;
			if (soap_blist_tokenArray)
				soap_end_block(soap, soap_blist_tokenArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTRequestTokenReturn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTRequestTokenReturn, 0, sizeof(struct ns1__ArrayOfTRequestTokenReturn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizetokenArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTRequestTokenReturn(struct soap *soap, const struct ns1__ArrayOfTRequestTokenReturn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTRequestTokenReturn);
	if (soap_out_ns1__ArrayOfTRequestTokenReturn(soap, tag?tag:"ns1:ArrayOfTRequestTokenReturn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTRequestTokenReturn * SOAP_FMAC4 soap_get_ns1__ArrayOfTRequestTokenReturn(struct soap *soap, struct ns1__ArrayOfTRequestTokenReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTRequestTokenReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TRequestTokenReturn(struct soap *soap, struct ns1__TRequestTokenReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	a->createdAtTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TRequestTokenReturn(struct soap *soap, const struct ns1__TRequestTokenReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTotime(soap, &a->createdAtTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TRequestTokenReturn(struct soap *soap, const char *tag, int id, const struct ns1__TRequestTokenReturn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TRequestTokenReturn), type))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createdAtTime", -1, &a->createdAtTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TRequestTokenReturn * SOAP_FMAC4 soap_in_ns1__TRequestTokenReturn(struct soap *soap, const char *tag, struct ns1__TRequestTokenReturn *a, const char *type)
{
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_createdAtTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TRequestTokenReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TRequestTokenReturn, sizeof(struct ns1__TRequestTokenReturn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TRequestTokenReturn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_createdAtTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createdAtTime", &a->createdAtTime, "xsd:dateTime"))
				{	soap_flag_createdAtTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TRequestTokenReturn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TRequestTokenReturn, 0, sizeof(struct ns1__TRequestTokenReturn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TRequestTokenReturn(struct soap *soap, const struct ns1__TRequestTokenReturn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TRequestTokenReturn);
	if (soap_out_ns1__TRequestTokenReturn(soap, tag?tag:"ns1:TRequestTokenReturn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TRequestTokenReturn * SOAP_FMAC4 soap_get_ns1__TRequestTokenReturn(struct soap *soap, struct ns1__TRequestTokenReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TRequestTokenReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTPermissionReturn(struct soap *soap, struct ns1__ArrayOfTPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizepermissionArray = 0;
	a->permissionArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTPermissionReturn(struct soap *soap, const struct ns1__ArrayOfTPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->permissionArray)
	{	int i;
		for (i = 0; i < a->__sizepermissionArray; i++)
		{
			soap_embedded(soap, a->permissionArray + i, SOAP_TYPE_ns1__TPermissionReturn);
			soap_serialize_ns1__TPermissionReturn(soap, a->permissionArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTPermissionReturn(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTPermissionReturn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTPermissionReturn), type))
		return soap->error;
	if (a->permissionArray)
	{	int i;
		for (i = 0; i < a->__sizepermissionArray; i++)
			if (soap_out_ns1__TPermissionReturn(soap, "permissionArray", -1, a->permissionArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTPermissionReturn * SOAP_FMAC4 soap_in_ns1__ArrayOfTPermissionReturn(struct soap *soap, const char *tag, struct ns1__ArrayOfTPermissionReturn *a, const char *type)
{
	struct soap_blist *soap_blist_permissionArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTPermissionReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTPermissionReturn, sizeof(struct ns1__ArrayOfTPermissionReturn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTPermissionReturn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "permissionArray", 1, NULL))
			{	if (a->permissionArray == NULL)
				{	if (soap_blist_permissionArray == NULL)
						soap_blist_permissionArray = soap_new_block(soap);
					a->permissionArray = (struct ns1__TPermissionReturn *)soap_push_block(soap, soap_blist_permissionArray, sizeof(struct ns1__TPermissionReturn));
					if (a->permissionArray == NULL)
						return NULL;
					soap_default_ns1__TPermissionReturn(soap, a->permissionArray);
				}soap_revert(soap);
				if (soap_in_ns1__TPermissionReturn(soap, "permissionArray", a->permissionArray, "ns1:TPermissionReturn"))
				{	a->__sizepermissionArray++;
					a->permissionArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->permissionArray)
			soap_pop_block(soap, soap_blist_permissionArray);
		if (a->__sizepermissionArray)
			a->permissionArray = (struct ns1__TPermissionReturn *)soap_save_block(soap, soap_blist_permissionArray, NULL, 1);
		else
		{	a->permissionArray = NULL;
			if (soap_blist_permissionArray)
				soap_end_block(soap, soap_blist_permissionArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTPermissionReturn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTPermissionReturn, 0, sizeof(struct ns1__ArrayOfTPermissionReturn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizepermissionArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTPermissionReturn(struct soap *soap, const struct ns1__ArrayOfTPermissionReturn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTPermissionReturn);
	if (soap_out_ns1__ArrayOfTPermissionReturn(soap, tag?tag:"ns1:ArrayOfTPermissionReturn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTPermissionReturn * SOAP_FMAC4 soap_get_ns1__ArrayOfTPermissionReturn(struct soap *soap, struct ns1__ArrayOfTPermissionReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTPermissionReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TPermissionReturn(struct soap *soap, struct ns1__TPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->surl);
	a->status = NULL;
	soap_default_string(soap, &a->owner);
	a->ownerPermission = NULL;
	a->arrayOfUserPermissions = NULL;
	a->arrayOfGroupPermissions = NULL;
	a->otherPermission = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TPermissionReturn(struct soap *soap, const struct ns1__TPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->surl);
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->status);
	soap_serialize_string(soap, &a->owner);
	soap_serialize_PointerTons1__TPermissionMode(soap, &a->ownerPermission);
	soap_serialize_PointerTons1__ArrayOfTUserPermission(soap, &a->arrayOfUserPermissions);
	soap_serialize_PointerTons1__ArrayOfTGroupPermission(soap, &a->arrayOfGroupPermissions);
	soap_serialize_PointerTons1__TPermissionMode(soap, &a->otherPermission);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TPermissionReturn(struct soap *soap, const char *tag, int id, const struct ns1__TPermissionReturn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TPermissionReturn), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "surl", -1, &a->surl, ""))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_string(soap, "owner", -1, &a->owner, ""))
		return soap->error;
	if (soap_out_PointerTons1__TPermissionMode(soap, "ownerPermission", -1, &a->ownerPermission, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTUserPermission(soap, "arrayOfUserPermissions", -1, &a->arrayOfUserPermissions, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTGroupPermission(soap, "arrayOfGroupPermissions", -1, &a->arrayOfGroupPermissions, ""))
		return soap->error;
	if (soap_out_PointerTons1__TPermissionMode(soap, "otherPermission", -1, &a->otherPermission, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TPermissionReturn * SOAP_FMAC4 soap_in_ns1__TPermissionReturn(struct soap *soap, const char *tag, struct ns1__TPermissionReturn *a, const char *type)
{
	size_t soap_flag_surl = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_owner = 1;
	size_t soap_flag_ownerPermission = 1;
	size_t soap_flag_arrayOfUserPermissions = 1;
	size_t soap_flag_arrayOfGroupPermissions = 1;
	size_t soap_flag_otherPermission = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TPermissionReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TPermissionReturn, sizeof(struct ns1__TPermissionReturn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TPermissionReturn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_surl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "surl", &a->surl, "xsd:anyURI"))
				{	soap_flag_surl--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "status", &a->status, "ns1:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_owner && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "owner", &a->owner, "xsd:string"))
				{	soap_flag_owner--;
					continue;
				}
			if (soap_flag_ownerPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TPermissionMode(soap, "ownerPermission", &a->ownerPermission, "ns1:TPermissionMode"))
				{	soap_flag_ownerPermission--;
					continue;
				}
			if (soap_flag_arrayOfUserPermissions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTUserPermission(soap, "arrayOfUserPermissions", &a->arrayOfUserPermissions, "ns1:ArrayOfTUserPermission"))
				{	soap_flag_arrayOfUserPermissions--;
					continue;
				}
			if (soap_flag_arrayOfGroupPermissions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTGroupPermission(soap, "arrayOfGroupPermissions", &a->arrayOfGroupPermissions, "ns1:ArrayOfTGroupPermission"))
				{	soap_flag_arrayOfGroupPermissions--;
					continue;
				}
			if (soap_flag_otherPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TPermissionMode(soap, "otherPermission", &a->otherPermission, "ns1:TPermissionMode"))
				{	soap_flag_otherPermission--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TPermissionReturn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TPermissionReturn, 0, sizeof(struct ns1__TPermissionReturn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_surl > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TPermissionReturn(struct soap *soap, const struct ns1__TPermissionReturn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TPermissionReturn);
	if (soap_out_ns1__TPermissionReturn(soap, tag?tag:"ns1:TPermissionReturn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TPermissionReturn * SOAP_FMAC4 soap_get_ns1__TPermissionReturn(struct soap *soap, struct ns1__TPermissionReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TPermissionReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTSURLPermissionReturn(struct soap *soap, struct ns1__ArrayOfTSURLPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizesurlPermissionArray = 0;
	a->surlPermissionArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTSURLPermissionReturn(struct soap *soap, const struct ns1__ArrayOfTSURLPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->surlPermissionArray)
	{	int i;
		for (i = 0; i < a->__sizesurlPermissionArray; i++)
		{
			soap_embedded(soap, a->surlPermissionArray + i, SOAP_TYPE_ns1__TSURLPermissionReturn);
			soap_serialize_ns1__TSURLPermissionReturn(soap, a->surlPermissionArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTSURLPermissionReturn(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTSURLPermissionReturn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTSURLPermissionReturn), type))
		return soap->error;
	if (a->surlPermissionArray)
	{	int i;
		for (i = 0; i < a->__sizesurlPermissionArray; i++)
			if (soap_out_ns1__TSURLPermissionReturn(soap, "surlPermissionArray", -1, a->surlPermissionArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTSURLPermissionReturn * SOAP_FMAC4 soap_in_ns1__ArrayOfTSURLPermissionReturn(struct soap *soap, const char *tag, struct ns1__ArrayOfTSURLPermissionReturn *a, const char *type)
{
	struct soap_blist *soap_blist_surlPermissionArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTSURLPermissionReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTSURLPermissionReturn, sizeof(struct ns1__ArrayOfTSURLPermissionReturn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTSURLPermissionReturn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "surlPermissionArray", 1, NULL))
			{	if (a->surlPermissionArray == NULL)
				{	if (soap_blist_surlPermissionArray == NULL)
						soap_blist_surlPermissionArray = soap_new_block(soap);
					a->surlPermissionArray = (struct ns1__TSURLPermissionReturn *)soap_push_block(soap, soap_blist_surlPermissionArray, sizeof(struct ns1__TSURLPermissionReturn));
					if (a->surlPermissionArray == NULL)
						return NULL;
					soap_default_ns1__TSURLPermissionReturn(soap, a->surlPermissionArray);
				}soap_revert(soap);
				if (soap_in_ns1__TSURLPermissionReturn(soap, "surlPermissionArray", a->surlPermissionArray, "ns1:TSURLPermissionReturn"))
				{	a->__sizesurlPermissionArray++;
					a->surlPermissionArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->surlPermissionArray)
			soap_pop_block(soap, soap_blist_surlPermissionArray);
		if (a->__sizesurlPermissionArray)
			a->surlPermissionArray = (struct ns1__TSURLPermissionReturn *)soap_save_block(soap, soap_blist_surlPermissionArray, NULL, 1);
		else
		{	a->surlPermissionArray = NULL;
			if (soap_blist_surlPermissionArray)
				soap_end_block(soap, soap_blist_surlPermissionArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTSURLPermissionReturn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTSURLPermissionReturn, 0, sizeof(struct ns1__ArrayOfTSURLPermissionReturn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizesurlPermissionArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTSURLPermissionReturn(struct soap *soap, const struct ns1__ArrayOfTSURLPermissionReturn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTSURLPermissionReturn);
	if (soap_out_ns1__ArrayOfTSURLPermissionReturn(soap, tag?tag:"ns1:ArrayOfTSURLPermissionReturn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTSURLPermissionReturn * SOAP_FMAC4 soap_get_ns1__ArrayOfTSURLPermissionReturn(struct soap *soap, struct ns1__ArrayOfTSURLPermissionReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTSURLPermissionReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TSURLPermissionReturn(struct soap *soap, struct ns1__TSURLPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->surl);
	a->status = NULL;
	a->permission = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TSURLPermissionReturn(struct soap *soap, const struct ns1__TSURLPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->surl);
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTons1__TPermissionMode(soap, &a->permission);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TSURLPermissionReturn(struct soap *soap, const char *tag, int id, const struct ns1__TSURLPermissionReturn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TSURLPermissionReturn), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "surl", -1, &a->surl, ""))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_PointerTons1__TPermissionMode(soap, "permission", -1, &a->permission, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TSURLPermissionReturn * SOAP_FMAC4 soap_in_ns1__TSURLPermissionReturn(struct soap *soap, const char *tag, struct ns1__TSURLPermissionReturn *a, const char *type)
{
	size_t soap_flag_surl = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_permission = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TSURLPermissionReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TSURLPermissionReturn, sizeof(struct ns1__TSURLPermissionReturn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TSURLPermissionReturn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_surl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "surl", &a->surl, "xsd:anyURI"))
				{	soap_flag_surl--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "status", &a->status, "ns1:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_permission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TPermissionMode(soap, "permission", &a->permission, "ns1:TPermissionMode"))
				{	soap_flag_permission--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TSURLPermissionReturn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TSURLPermissionReturn, 0, sizeof(struct ns1__TSURLPermissionReturn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_surl > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TSURLPermissionReturn(struct soap *soap, const struct ns1__TSURLPermissionReturn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TSURLPermissionReturn);
	if (soap_out_ns1__TSURLPermissionReturn(soap, tag?tag:"ns1:TSURLPermissionReturn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TSURLPermissionReturn * SOAP_FMAC4 soap_get_ns1__TSURLPermissionReturn(struct soap *soap, struct ns1__TSURLPermissionReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TSURLPermissionReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTRequestSummary(struct soap *soap, struct ns1__ArrayOfTRequestSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizesummaryArray = 0;
	a->summaryArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTRequestSummary(struct soap *soap, const struct ns1__ArrayOfTRequestSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->summaryArray)
	{	int i;
		for (i = 0; i < a->__sizesummaryArray; i++)
		{
			soap_embedded(soap, a->summaryArray + i, SOAP_TYPE_ns1__TRequestSummary);
			soap_serialize_ns1__TRequestSummary(soap, a->summaryArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTRequestSummary(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTRequestSummary *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTRequestSummary), type))
		return soap->error;
	if (a->summaryArray)
	{	int i;
		for (i = 0; i < a->__sizesummaryArray; i++)
			if (soap_out_ns1__TRequestSummary(soap, "summaryArray", -1, a->summaryArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTRequestSummary * SOAP_FMAC4 soap_in_ns1__ArrayOfTRequestSummary(struct soap *soap, const char *tag, struct ns1__ArrayOfTRequestSummary *a, const char *type)
{
	struct soap_blist *soap_blist_summaryArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTRequestSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTRequestSummary, sizeof(struct ns1__ArrayOfTRequestSummary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTRequestSummary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "summaryArray", 1, NULL))
			{	if (a->summaryArray == NULL)
				{	if (soap_blist_summaryArray == NULL)
						soap_blist_summaryArray = soap_new_block(soap);
					a->summaryArray = (struct ns1__TRequestSummary *)soap_push_block(soap, soap_blist_summaryArray, sizeof(struct ns1__TRequestSummary));
					if (a->summaryArray == NULL)
						return NULL;
					soap_default_ns1__TRequestSummary(soap, a->summaryArray);
				}soap_revert(soap);
				if (soap_in_ns1__TRequestSummary(soap, "summaryArray", a->summaryArray, "ns1:TRequestSummary"))
				{	a->__sizesummaryArray++;
					a->summaryArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->summaryArray)
			soap_pop_block(soap, soap_blist_summaryArray);
		if (a->__sizesummaryArray)
			a->summaryArray = (struct ns1__TRequestSummary *)soap_save_block(soap, soap_blist_summaryArray, NULL, 1);
		else
		{	a->summaryArray = NULL;
			if (soap_blist_summaryArray)
				soap_end_block(soap, soap_blist_summaryArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTRequestSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTRequestSummary, 0, sizeof(struct ns1__ArrayOfTRequestSummary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizesummaryArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTRequestSummary(struct soap *soap, const struct ns1__ArrayOfTRequestSummary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTRequestSummary);
	if (soap_out_ns1__ArrayOfTRequestSummary(soap, tag?tag:"ns1:ArrayOfTRequestSummary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTRequestSummary * SOAP_FMAC4 soap_get_ns1__ArrayOfTRequestSummary(struct soap *soap, struct ns1__ArrayOfTRequestSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTRequestSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TRequestSummary(struct soap *soap, struct ns1__TRequestSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	a->status = NULL;
	a->requestType = NULL;
	a->totalNumFilesInRequest = NULL;
	a->numOfCompletedFiles = NULL;
	a->numOfWaitingFiles = NULL;
	a->numOfFailedFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TRequestSummary(struct soap *soap, const struct ns1__TRequestSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTons1__TRequestType(soap, &a->requestType);
	soap_serialize_PointerToint(soap, &a->totalNumFilesInRequest);
	soap_serialize_PointerToint(soap, &a->numOfCompletedFiles);
	soap_serialize_PointerToint(soap, &a->numOfWaitingFiles);
	soap_serialize_PointerToint(soap, &a->numOfFailedFiles);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TRequestSummary(struct soap *soap, const char *tag, int id, const struct ns1__TRequestSummary *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TRequestSummary), type))
		return soap->error;
	if (soap_out_string(soap, "requestToken", -1, &a->requestToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_PointerTons1__TRequestType(soap, "requestType", -1, &a->requestType, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "totalNumFilesInRequest", -1, &a->totalNumFilesInRequest, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "numOfCompletedFiles", -1, &a->numOfCompletedFiles, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "numOfWaitingFiles", -1, &a->numOfWaitingFiles, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "numOfFailedFiles", -1, &a->numOfFailedFiles, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TRequestSummary * SOAP_FMAC4 soap_in_ns1__TRequestSummary(struct soap *soap, const char *tag, struct ns1__TRequestSummary *a, const char *type)
{
	size_t soap_flag_requestToken = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_requestType = 1;
	size_t soap_flag_totalNumFilesInRequest = 1;
	size_t soap_flag_numOfCompletedFiles = 1;
	size_t soap_flag_numOfWaitingFiles = 1;
	size_t soap_flag_numOfFailedFiles = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TRequestSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TRequestSummary, sizeof(struct ns1__TRequestSummary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TRequestSummary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "status", &a->status, "ns1:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_requestType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TRequestType(soap, "requestType", &a->requestType, "ns1:TRequestType"))
				{	soap_flag_requestType--;
					continue;
				}
			if (soap_flag_totalNumFilesInRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "totalNumFilesInRequest", &a->totalNumFilesInRequest, "xsd:int"))
				{	soap_flag_totalNumFilesInRequest--;
					continue;
				}
			if (soap_flag_numOfCompletedFiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numOfCompletedFiles", &a->numOfCompletedFiles, "xsd:int"))
				{	soap_flag_numOfCompletedFiles--;
					continue;
				}
			if (soap_flag_numOfWaitingFiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numOfWaitingFiles", &a->numOfWaitingFiles, "xsd:int"))
				{	soap_flag_numOfWaitingFiles--;
					continue;
				}
			if (soap_flag_numOfFailedFiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numOfFailedFiles", &a->numOfFailedFiles, "xsd:int"))
				{	soap_flag_numOfFailedFiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TRequestSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TRequestSummary, 0, sizeof(struct ns1__TRequestSummary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TRequestSummary(struct soap *soap, const struct ns1__TRequestSummary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TRequestSummary);
	if (soap_out_ns1__TRequestSummary(soap, tag?tag:"ns1:TRequestSummary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TRequestSummary * SOAP_FMAC4 soap_get_ns1__TRequestSummary(struct soap *soap, struct ns1__TRequestSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TRequestSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTCopyRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTCopyRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestatusArray = 0;
	a->statusArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTCopyRequestFileStatus(struct soap *soap, const struct ns1__ArrayOfTCopyRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
		{
			soap_embedded(soap, a->statusArray + i, SOAP_TYPE_ns1__TCopyRequestFileStatus);
			soap_serialize_ns1__TCopyRequestFileStatus(soap, a->statusArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTCopyRequestFileStatus(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTCopyRequestFileStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTCopyRequestFileStatus), type))
		return soap->error;
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
			if (soap_out_ns1__TCopyRequestFileStatus(soap, "statusArray", -1, a->statusArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTCopyRequestFileStatus * SOAP_FMAC4 soap_in_ns1__ArrayOfTCopyRequestFileStatus(struct soap *soap, const char *tag, struct ns1__ArrayOfTCopyRequestFileStatus *a, const char *type)
{
	struct soap_blist *soap_blist_statusArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTCopyRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTCopyRequestFileStatus, sizeof(struct ns1__ArrayOfTCopyRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTCopyRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "statusArray", 1, NULL))
			{	if (a->statusArray == NULL)
				{	if (soap_blist_statusArray == NULL)
						soap_blist_statusArray = soap_new_block(soap);
					a->statusArray = (struct ns1__TCopyRequestFileStatus *)soap_push_block(soap, soap_blist_statusArray, sizeof(struct ns1__TCopyRequestFileStatus));
					if (a->statusArray == NULL)
						return NULL;
					soap_default_ns1__TCopyRequestFileStatus(soap, a->statusArray);
				}soap_revert(soap);
				if (soap_in_ns1__TCopyRequestFileStatus(soap, "statusArray", a->statusArray, "ns1:TCopyRequestFileStatus"))
				{	a->__sizestatusArray++;
					a->statusArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->statusArray)
			soap_pop_block(soap, soap_blist_statusArray);
		if (a->__sizestatusArray)
			a->statusArray = (struct ns1__TCopyRequestFileStatus *)soap_save_block(soap, soap_blist_statusArray, NULL, 1);
		else
		{	a->statusArray = NULL;
			if (soap_blist_statusArray)
				soap_end_block(soap, soap_blist_statusArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTCopyRequestFileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTCopyRequestFileStatus, 0, sizeof(struct ns1__ArrayOfTCopyRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizestatusArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTCopyRequestFileStatus(struct soap *soap, const struct ns1__ArrayOfTCopyRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTCopyRequestFileStatus);
	if (soap_out_ns1__ArrayOfTCopyRequestFileStatus(soap, tag?tag:"ns1:ArrayOfTCopyRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTCopyRequestFileStatus * SOAP_FMAC4 soap_get_ns1__ArrayOfTCopyRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTCopyRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTCopyRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TCopyRequestFileStatus(struct soap *soap, struct ns1__TCopyRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->sourceSURL);
	soap_default_xsd__anyURI(soap, &a->targetSURL);
	a->status = NULL;
	a->fileSize = NULL;
	a->estimatedWaitTime = NULL;
	a->remainingFileLifetime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TCopyRequestFileStatus(struct soap *soap, const struct ns1__TCopyRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->sourceSURL);
	soap_serialize_xsd__anyURI(soap, &a->targetSURL);
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTounsignedLONG64(soap, &a->fileSize);
	soap_serialize_PointerToint(soap, &a->estimatedWaitTime);
	soap_serialize_PointerToint(soap, &a->remainingFileLifetime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TCopyRequestFileStatus(struct soap *soap, const char *tag, int id, const struct ns1__TCopyRequestFileStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TCopyRequestFileStatus), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "sourceSURL", -1, &a->sourceSURL, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "targetSURL", -1, &a->targetSURL, ""))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "fileSize", -1, &a->fileSize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "estimatedWaitTime", -1, &a->estimatedWaitTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingFileLifetime", -1, &a->remainingFileLifetime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TCopyRequestFileStatus * SOAP_FMAC4 soap_in_ns1__TCopyRequestFileStatus(struct soap *soap, const char *tag, struct ns1__TCopyRequestFileStatus *a, const char *type)
{
	size_t soap_flag_sourceSURL = 1;
	size_t soap_flag_targetSURL = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_fileSize = 1;
	size_t soap_flag_estimatedWaitTime = 1;
	size_t soap_flag_remainingFileLifetime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TCopyRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TCopyRequestFileStatus, sizeof(struct ns1__TCopyRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TCopyRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "sourceSURL", &a->sourceSURL, "xsd:anyURI"))
				{	soap_flag_sourceSURL--;
					continue;
				}
			if (soap_flag_targetSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "targetSURL", &a->targetSURL, "xsd:anyURI"))
				{	soap_flag_targetSURL--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "status", &a->status, "ns1:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_fileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "fileSize", &a->fileSize, "xsd:unsignedLong"))
				{	soap_flag_fileSize--;
					continue;
				}
			if (soap_flag_estimatedWaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedWaitTime", &a->estimatedWaitTime, "xsd:int"))
				{	soap_flag_estimatedWaitTime--;
					continue;
				}
			if (soap_flag_remainingFileLifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingFileLifetime", &a->remainingFileLifetime, "xsd:int"))
				{	soap_flag_remainingFileLifetime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TCopyRequestFileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TCopyRequestFileStatus, 0, sizeof(struct ns1__TCopyRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceSURL > 0 || soap_flag_targetSURL > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TCopyRequestFileStatus(struct soap *soap, const struct ns1__TCopyRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TCopyRequestFileStatus);
	if (soap_out_ns1__TCopyRequestFileStatus(soap, tag?tag:"ns1:TCopyRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TCopyRequestFileStatus * SOAP_FMAC4 soap_get_ns1__TCopyRequestFileStatus(struct soap *soap, struct ns1__TCopyRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TCopyRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTPutRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTPutRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestatusArray = 0;
	a->statusArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTPutRequestFileStatus(struct soap *soap, const struct ns1__ArrayOfTPutRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
		{
			soap_embedded(soap, a->statusArray + i, SOAP_TYPE_ns1__TPutRequestFileStatus);
			soap_serialize_ns1__TPutRequestFileStatus(soap, a->statusArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTPutRequestFileStatus(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTPutRequestFileStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTPutRequestFileStatus), type))
		return soap->error;
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
			if (soap_out_ns1__TPutRequestFileStatus(soap, "statusArray", -1, a->statusArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTPutRequestFileStatus * SOAP_FMAC4 soap_in_ns1__ArrayOfTPutRequestFileStatus(struct soap *soap, const char *tag, struct ns1__ArrayOfTPutRequestFileStatus *a, const char *type)
{
	struct soap_blist *soap_blist_statusArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTPutRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTPutRequestFileStatus, sizeof(struct ns1__ArrayOfTPutRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTPutRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "statusArray", 1, NULL))
			{	if (a->statusArray == NULL)
				{	if (soap_blist_statusArray == NULL)
						soap_blist_statusArray = soap_new_block(soap);
					a->statusArray = (struct ns1__TPutRequestFileStatus *)soap_push_block(soap, soap_blist_statusArray, sizeof(struct ns1__TPutRequestFileStatus));
					if (a->statusArray == NULL)
						return NULL;
					soap_default_ns1__TPutRequestFileStatus(soap, a->statusArray);
				}soap_revert(soap);
				if (soap_in_ns1__TPutRequestFileStatus(soap, "statusArray", a->statusArray, "ns1:TPutRequestFileStatus"))
				{	a->__sizestatusArray++;
					a->statusArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->statusArray)
			soap_pop_block(soap, soap_blist_statusArray);
		if (a->__sizestatusArray)
			a->statusArray = (struct ns1__TPutRequestFileStatus *)soap_save_block(soap, soap_blist_statusArray, NULL, 1);
		else
		{	a->statusArray = NULL;
			if (soap_blist_statusArray)
				soap_end_block(soap, soap_blist_statusArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTPutRequestFileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTPutRequestFileStatus, 0, sizeof(struct ns1__ArrayOfTPutRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizestatusArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTPutRequestFileStatus(struct soap *soap, const struct ns1__ArrayOfTPutRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTPutRequestFileStatus);
	if (soap_out_ns1__ArrayOfTPutRequestFileStatus(soap, tag?tag:"ns1:ArrayOfTPutRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTPutRequestFileStatus * SOAP_FMAC4 soap_get_ns1__ArrayOfTPutRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTPutRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTPutRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TPutRequestFileStatus(struct soap *soap, struct ns1__TPutRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->SURL);
	a->status = NULL;
	a->fileSize = NULL;
	a->estimatedWaitTime = NULL;
	a->remainingPinLifetime = NULL;
	a->remainingFileLifetime = NULL;
	soap_default_xsd__anyURI(soap, &a->transferURL);
	a->transferProtocolInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TPutRequestFileStatus(struct soap *soap, const struct ns1__TPutRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->SURL);
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTounsignedLONG64(soap, &a->fileSize);
	soap_serialize_PointerToint(soap, &a->estimatedWaitTime);
	soap_serialize_PointerToint(soap, &a->remainingPinLifetime);
	soap_serialize_PointerToint(soap, &a->remainingFileLifetime);
	soap_serialize_xsd__anyURI(soap, &a->transferURL);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->transferProtocolInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TPutRequestFileStatus(struct soap *soap, const char *tag, int id, const struct ns1__TPutRequestFileStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TPutRequestFileStatus), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "SURL", -1, &a->SURL, ""))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "fileSize", -1, &a->fileSize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "estimatedWaitTime", -1, &a->estimatedWaitTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingPinLifetime", -1, &a->remainingPinLifetime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingFileLifetime", -1, &a->remainingFileLifetime, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "transferURL", -1, &a->transferURL, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "transferProtocolInfo", -1, &a->transferProtocolInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TPutRequestFileStatus * SOAP_FMAC4 soap_in_ns1__TPutRequestFileStatus(struct soap *soap, const char *tag, struct ns1__TPutRequestFileStatus *a, const char *type)
{
	size_t soap_flag_SURL = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_fileSize = 1;
	size_t soap_flag_estimatedWaitTime = 1;
	size_t soap_flag_remainingPinLifetime = 1;
	size_t soap_flag_remainingFileLifetime = 1;
	size_t soap_flag_transferURL = 1;
	size_t soap_flag_transferProtocolInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TPutRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TPutRequestFileStatus, sizeof(struct ns1__TPutRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TPutRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "SURL", &a->SURL, "xsd:anyURI"))
				{	soap_flag_SURL--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "status", &a->status, "ns1:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_fileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "fileSize", &a->fileSize, "xsd:unsignedLong"))
				{	soap_flag_fileSize--;
					continue;
				}
			if (soap_flag_estimatedWaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedWaitTime", &a->estimatedWaitTime, "xsd:int"))
				{	soap_flag_estimatedWaitTime--;
					continue;
				}
			if (soap_flag_remainingPinLifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingPinLifetime", &a->remainingPinLifetime, "xsd:int"))
				{	soap_flag_remainingPinLifetime--;
					continue;
				}
			if (soap_flag_remainingFileLifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingFileLifetime", &a->remainingFileLifetime, "xsd:int"))
				{	soap_flag_remainingFileLifetime--;
					continue;
				}
			if (soap_flag_transferURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "transferURL", &a->transferURL, "xsd:anyURI"))
				{	soap_flag_transferURL--;
					continue;
				}
			if (soap_flag_transferProtocolInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "transferProtocolInfo", &a->transferProtocolInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_transferProtocolInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TPutRequestFileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TPutRequestFileStatus, 0, sizeof(struct ns1__TPutRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SURL > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TPutRequestFileStatus(struct soap *soap, const struct ns1__TPutRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TPutRequestFileStatus);
	if (soap_out_ns1__TPutRequestFileStatus(soap, tag?tag:"ns1:TPutRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TPutRequestFileStatus * SOAP_FMAC4 soap_get_ns1__TPutRequestFileStatus(struct soap *soap, struct ns1__TPutRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TPutRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTBringOnlineRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestatusArray = 0;
	a->statusArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, const struct ns1__ArrayOfTBringOnlineRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
		{
			soap_embedded(soap, a->statusArray + i, SOAP_TYPE_ns1__TBringOnlineRequestFileStatus);
			soap_serialize_ns1__TBringOnlineRequestFileStatus(soap, a->statusArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTBringOnlineRequestFileStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTBringOnlineRequestFileStatus), type))
		return soap->error;
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
			if (soap_out_ns1__TBringOnlineRequestFileStatus(soap, "statusArray", -1, a->statusArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTBringOnlineRequestFileStatus * SOAP_FMAC4 soap_in_ns1__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, const char *tag, struct ns1__ArrayOfTBringOnlineRequestFileStatus *a, const char *type)
{
	struct soap_blist *soap_blist_statusArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTBringOnlineRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTBringOnlineRequestFileStatus, sizeof(struct ns1__ArrayOfTBringOnlineRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTBringOnlineRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "statusArray", 1, NULL))
			{	if (a->statusArray == NULL)
				{	if (soap_blist_statusArray == NULL)
						soap_blist_statusArray = soap_new_block(soap);
					a->statusArray = (struct ns1__TBringOnlineRequestFileStatus *)soap_push_block(soap, soap_blist_statusArray, sizeof(struct ns1__TBringOnlineRequestFileStatus));
					if (a->statusArray == NULL)
						return NULL;
					soap_default_ns1__TBringOnlineRequestFileStatus(soap, a->statusArray);
				}soap_revert(soap);
				if (soap_in_ns1__TBringOnlineRequestFileStatus(soap, "statusArray", a->statusArray, "ns1:TBringOnlineRequestFileStatus"))
				{	a->__sizestatusArray++;
					a->statusArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->statusArray)
			soap_pop_block(soap, soap_blist_statusArray);
		if (a->__sizestatusArray)
			a->statusArray = (struct ns1__TBringOnlineRequestFileStatus *)soap_save_block(soap, soap_blist_statusArray, NULL, 1);
		else
		{	a->statusArray = NULL;
			if (soap_blist_statusArray)
				soap_end_block(soap, soap_blist_statusArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTBringOnlineRequestFileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTBringOnlineRequestFileStatus, 0, sizeof(struct ns1__ArrayOfTBringOnlineRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizestatusArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, const struct ns1__ArrayOfTBringOnlineRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTBringOnlineRequestFileStatus);
	if (soap_out_ns1__ArrayOfTBringOnlineRequestFileStatus(soap, tag?tag:"ns1:ArrayOfTBringOnlineRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTBringOnlineRequestFileStatus * SOAP_FMAC4 soap_get_ns1__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTBringOnlineRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTBringOnlineRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TBringOnlineRequestFileStatus(struct soap *soap, struct ns1__TBringOnlineRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->sourceSURL);
	a->status = NULL;
	a->fileSize = NULL;
	a->estimatedWaitTime = NULL;
	a->remainingPinTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TBringOnlineRequestFileStatus(struct soap *soap, const struct ns1__TBringOnlineRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->sourceSURL);
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTounsignedLONG64(soap, &a->fileSize);
	soap_serialize_PointerToint(soap, &a->estimatedWaitTime);
	soap_serialize_PointerToint(soap, &a->remainingPinTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TBringOnlineRequestFileStatus(struct soap *soap, const char *tag, int id, const struct ns1__TBringOnlineRequestFileStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TBringOnlineRequestFileStatus), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "sourceSURL", -1, &a->sourceSURL, ""))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "fileSize", -1, &a->fileSize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "estimatedWaitTime", -1, &a->estimatedWaitTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingPinTime", -1, &a->remainingPinTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TBringOnlineRequestFileStatus * SOAP_FMAC4 soap_in_ns1__TBringOnlineRequestFileStatus(struct soap *soap, const char *tag, struct ns1__TBringOnlineRequestFileStatus *a, const char *type)
{
	size_t soap_flag_sourceSURL = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_fileSize = 1;
	size_t soap_flag_estimatedWaitTime = 1;
	size_t soap_flag_remainingPinTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TBringOnlineRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TBringOnlineRequestFileStatus, sizeof(struct ns1__TBringOnlineRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TBringOnlineRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "sourceSURL", &a->sourceSURL, "xsd:anyURI"))
				{	soap_flag_sourceSURL--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "status", &a->status, "ns1:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_fileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "fileSize", &a->fileSize, "xsd:unsignedLong"))
				{	soap_flag_fileSize--;
					continue;
				}
			if (soap_flag_estimatedWaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedWaitTime", &a->estimatedWaitTime, "xsd:int"))
				{	soap_flag_estimatedWaitTime--;
					continue;
				}
			if (soap_flag_remainingPinTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingPinTime", &a->remainingPinTime, "xsd:int"))
				{	soap_flag_remainingPinTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TBringOnlineRequestFileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TBringOnlineRequestFileStatus, 0, sizeof(struct ns1__TBringOnlineRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceSURL > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TBringOnlineRequestFileStatus(struct soap *soap, const struct ns1__TBringOnlineRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TBringOnlineRequestFileStatus);
	if (soap_out_ns1__TBringOnlineRequestFileStatus(soap, tag?tag:"ns1:TBringOnlineRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TBringOnlineRequestFileStatus * SOAP_FMAC4 soap_get_ns1__TBringOnlineRequestFileStatus(struct soap *soap, struct ns1__TBringOnlineRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TBringOnlineRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTGetRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTGetRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestatusArray = 0;
	a->statusArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTGetRequestFileStatus(struct soap *soap, const struct ns1__ArrayOfTGetRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
		{
			soap_embedded(soap, a->statusArray + i, SOAP_TYPE_ns1__TGetRequestFileStatus);
			soap_serialize_ns1__TGetRequestFileStatus(soap, a->statusArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTGetRequestFileStatus(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTGetRequestFileStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTGetRequestFileStatus), type))
		return soap->error;
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
			if (soap_out_ns1__TGetRequestFileStatus(soap, "statusArray", -1, a->statusArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTGetRequestFileStatus * SOAP_FMAC4 soap_in_ns1__ArrayOfTGetRequestFileStatus(struct soap *soap, const char *tag, struct ns1__ArrayOfTGetRequestFileStatus *a, const char *type)
{
	struct soap_blist *soap_blist_statusArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTGetRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTGetRequestFileStatus, sizeof(struct ns1__ArrayOfTGetRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTGetRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "statusArray", 1, NULL))
			{	if (a->statusArray == NULL)
				{	if (soap_blist_statusArray == NULL)
						soap_blist_statusArray = soap_new_block(soap);
					a->statusArray = (struct ns1__TGetRequestFileStatus *)soap_push_block(soap, soap_blist_statusArray, sizeof(struct ns1__TGetRequestFileStatus));
					if (a->statusArray == NULL)
						return NULL;
					soap_default_ns1__TGetRequestFileStatus(soap, a->statusArray);
				}soap_revert(soap);
				if (soap_in_ns1__TGetRequestFileStatus(soap, "statusArray", a->statusArray, "ns1:TGetRequestFileStatus"))
				{	a->__sizestatusArray++;
					a->statusArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->statusArray)
			soap_pop_block(soap, soap_blist_statusArray);
		if (a->__sizestatusArray)
			a->statusArray = (struct ns1__TGetRequestFileStatus *)soap_save_block(soap, soap_blist_statusArray, NULL, 1);
		else
		{	a->statusArray = NULL;
			if (soap_blist_statusArray)
				soap_end_block(soap, soap_blist_statusArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTGetRequestFileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTGetRequestFileStatus, 0, sizeof(struct ns1__ArrayOfTGetRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizestatusArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTGetRequestFileStatus(struct soap *soap, const struct ns1__ArrayOfTGetRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTGetRequestFileStatus);
	if (soap_out_ns1__ArrayOfTGetRequestFileStatus(soap, tag?tag:"ns1:ArrayOfTGetRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTGetRequestFileStatus * SOAP_FMAC4 soap_get_ns1__ArrayOfTGetRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTGetRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTGetRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TGetRequestFileStatus(struct soap *soap, struct ns1__TGetRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->sourceSURL);
	a->fileSize = NULL;
	a->status = NULL;
	a->estimatedWaitTime = NULL;
	a->remainingPinTime = NULL;
	soap_default_xsd__anyURI(soap, &a->transferURL);
	a->transferProtocolInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TGetRequestFileStatus(struct soap *soap, const struct ns1__TGetRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->sourceSURL);
	soap_serialize_PointerTounsignedLONG64(soap, &a->fileSize);
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->status);
	soap_serialize_PointerToint(soap, &a->estimatedWaitTime);
	soap_serialize_PointerToint(soap, &a->remainingPinTime);
	soap_serialize_xsd__anyURI(soap, &a->transferURL);
	soap_serialize_PointerTons1__ArrayOfTExtraInfo(soap, &a->transferProtocolInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TGetRequestFileStatus(struct soap *soap, const char *tag, int id, const struct ns1__TGetRequestFileStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TGetRequestFileStatus), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "sourceSURL", -1, &a->sourceSURL, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "fileSize", -1, &a->fileSize, ""))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "estimatedWaitTime", -1, &a->estimatedWaitTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "remainingPinTime", -1, &a->remainingPinTime, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "transferURL", -1, &a->transferURL, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, "transferProtocolInfo", -1, &a->transferProtocolInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TGetRequestFileStatus * SOAP_FMAC4 soap_in_ns1__TGetRequestFileStatus(struct soap *soap, const char *tag, struct ns1__TGetRequestFileStatus *a, const char *type)
{
	size_t soap_flag_sourceSURL = 1;
	size_t soap_flag_fileSize = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_estimatedWaitTime = 1;
	size_t soap_flag_remainingPinTime = 1;
	size_t soap_flag_transferURL = 1;
	size_t soap_flag_transferProtocolInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TGetRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TGetRequestFileStatus, sizeof(struct ns1__TGetRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TGetRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "sourceSURL", &a->sourceSURL, "xsd:anyURI"))
				{	soap_flag_sourceSURL--;
					continue;
				}
			if (soap_flag_fileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "fileSize", &a->fileSize, "xsd:unsignedLong"))
				{	soap_flag_fileSize--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "status", &a->status, "ns1:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_estimatedWaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedWaitTime", &a->estimatedWaitTime, "xsd:int"))
				{	soap_flag_estimatedWaitTime--;
					continue;
				}
			if (soap_flag_remainingPinTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingPinTime", &a->remainingPinTime, "xsd:int"))
				{	soap_flag_remainingPinTime--;
					continue;
				}
			if (soap_flag_transferURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "transferURL", &a->transferURL, "xsd:anyURI"))
				{	soap_flag_transferURL--;
					continue;
				}
			if (soap_flag_transferProtocolInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTExtraInfo(soap, "transferProtocolInfo", &a->transferProtocolInfo, "ns1:ArrayOfTExtraInfo"))
				{	soap_flag_transferProtocolInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TGetRequestFileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TGetRequestFileStatus, 0, sizeof(struct ns1__TGetRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceSURL > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TGetRequestFileStatus(struct soap *soap, const struct ns1__TGetRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TGetRequestFileStatus);
	if (soap_out_ns1__TGetRequestFileStatus(soap, tag?tag:"ns1:TGetRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TGetRequestFileStatus * SOAP_FMAC4 soap_get_ns1__TGetRequestFileStatus(struct soap *soap, struct ns1__TGetRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TGetRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTCopyFileRequest(struct soap *soap, struct ns1__ArrayOfTCopyFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizerequestArray = 0;
	a->requestArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTCopyFileRequest(struct soap *soap, const struct ns1__ArrayOfTCopyFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->requestArray)
	{	int i;
		for (i = 0; i < a->__sizerequestArray; i++)
		{
			soap_embedded(soap, a->requestArray + i, SOAP_TYPE_ns1__TCopyFileRequest);
			soap_serialize_ns1__TCopyFileRequest(soap, a->requestArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTCopyFileRequest(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTCopyFileRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTCopyFileRequest), type))
		return soap->error;
	if (a->requestArray)
	{	int i;
		for (i = 0; i < a->__sizerequestArray; i++)
			if (soap_out_ns1__TCopyFileRequest(soap, "requestArray", -1, a->requestArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTCopyFileRequest * SOAP_FMAC4 soap_in_ns1__ArrayOfTCopyFileRequest(struct soap *soap, const char *tag, struct ns1__ArrayOfTCopyFileRequest *a, const char *type)
{
	struct soap_blist *soap_blist_requestArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTCopyFileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTCopyFileRequest, sizeof(struct ns1__ArrayOfTCopyFileRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTCopyFileRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "requestArray", 1, NULL))
			{	if (a->requestArray == NULL)
				{	if (soap_blist_requestArray == NULL)
						soap_blist_requestArray = soap_new_block(soap);
					a->requestArray = (struct ns1__TCopyFileRequest *)soap_push_block(soap, soap_blist_requestArray, sizeof(struct ns1__TCopyFileRequest));
					if (a->requestArray == NULL)
						return NULL;
					soap_default_ns1__TCopyFileRequest(soap, a->requestArray);
				}soap_revert(soap);
				if (soap_in_ns1__TCopyFileRequest(soap, "requestArray", a->requestArray, "ns1:TCopyFileRequest"))
				{	a->__sizerequestArray++;
					a->requestArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->requestArray)
			soap_pop_block(soap, soap_blist_requestArray);
		if (a->__sizerequestArray)
			a->requestArray = (struct ns1__TCopyFileRequest *)soap_save_block(soap, soap_blist_requestArray, NULL, 1);
		else
		{	a->requestArray = NULL;
			if (soap_blist_requestArray)
				soap_end_block(soap, soap_blist_requestArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTCopyFileRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTCopyFileRequest, 0, sizeof(struct ns1__ArrayOfTCopyFileRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizerequestArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTCopyFileRequest(struct soap *soap, const struct ns1__ArrayOfTCopyFileRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTCopyFileRequest);
	if (soap_out_ns1__ArrayOfTCopyFileRequest(soap, tag?tag:"ns1:ArrayOfTCopyFileRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTCopyFileRequest * SOAP_FMAC4 soap_get_ns1__ArrayOfTCopyFileRequest(struct soap *soap, struct ns1__ArrayOfTCopyFileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTCopyFileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TCopyFileRequest(struct soap *soap, struct ns1__TCopyFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->sourceSURL);
	soap_default_xsd__anyURI(soap, &a->targetSURL);
	a->dirOption = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TCopyFileRequest(struct soap *soap, const struct ns1__TCopyFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->sourceSURL);
	soap_serialize_xsd__anyURI(soap, &a->targetSURL);
	soap_serialize_PointerTons1__TDirOption(soap, &a->dirOption);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TCopyFileRequest(struct soap *soap, const char *tag, int id, const struct ns1__TCopyFileRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TCopyFileRequest), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "sourceSURL", -1, &a->sourceSURL, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "targetSURL", -1, &a->targetSURL, ""))
		return soap->error;
	if (soap_out_PointerTons1__TDirOption(soap, "dirOption", -1, &a->dirOption, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TCopyFileRequest * SOAP_FMAC4 soap_in_ns1__TCopyFileRequest(struct soap *soap, const char *tag, struct ns1__TCopyFileRequest *a, const char *type)
{
	size_t soap_flag_sourceSURL = 1;
	size_t soap_flag_targetSURL = 1;
	size_t soap_flag_dirOption = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TCopyFileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TCopyFileRequest, sizeof(struct ns1__TCopyFileRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TCopyFileRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "sourceSURL", &a->sourceSURL, "xsd:anyURI"))
				{	soap_flag_sourceSURL--;
					continue;
				}
			if (soap_flag_targetSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "targetSURL", &a->targetSURL, "xsd:anyURI"))
				{	soap_flag_targetSURL--;
					continue;
				}
			if (soap_flag_dirOption && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TDirOption(soap, "dirOption", &a->dirOption, "ns1:TDirOption"))
				{	soap_flag_dirOption--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TCopyFileRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TCopyFileRequest, 0, sizeof(struct ns1__TCopyFileRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceSURL > 0 || soap_flag_targetSURL > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TCopyFileRequest(struct soap *soap, const struct ns1__TCopyFileRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TCopyFileRequest);
	if (soap_out_ns1__TCopyFileRequest(soap, tag?tag:"ns1:TCopyFileRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TCopyFileRequest * SOAP_FMAC4 soap_get_ns1__TCopyFileRequest(struct soap *soap, struct ns1__TCopyFileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TCopyFileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTPutFileRequest(struct soap *soap, struct ns1__ArrayOfTPutFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizerequestArray = 0;
	a->requestArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTPutFileRequest(struct soap *soap, const struct ns1__ArrayOfTPutFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->requestArray)
	{	int i;
		for (i = 0; i < a->__sizerequestArray; i++)
		{
			soap_embedded(soap, a->requestArray + i, SOAP_TYPE_ns1__TPutFileRequest);
			soap_serialize_ns1__TPutFileRequest(soap, a->requestArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTPutFileRequest(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTPutFileRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTPutFileRequest), type))
		return soap->error;
	if (a->requestArray)
	{	int i;
		for (i = 0; i < a->__sizerequestArray; i++)
			if (soap_out_ns1__TPutFileRequest(soap, "requestArray", -1, a->requestArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTPutFileRequest * SOAP_FMAC4 soap_in_ns1__ArrayOfTPutFileRequest(struct soap *soap, const char *tag, struct ns1__ArrayOfTPutFileRequest *a, const char *type)
{
	struct soap_blist *soap_blist_requestArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTPutFileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTPutFileRequest, sizeof(struct ns1__ArrayOfTPutFileRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTPutFileRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "requestArray", 1, NULL))
			{	if (a->requestArray == NULL)
				{	if (soap_blist_requestArray == NULL)
						soap_blist_requestArray = soap_new_block(soap);
					a->requestArray = (struct ns1__TPutFileRequest *)soap_push_block(soap, soap_blist_requestArray, sizeof(struct ns1__TPutFileRequest));
					if (a->requestArray == NULL)
						return NULL;
					soap_default_ns1__TPutFileRequest(soap, a->requestArray);
				}soap_revert(soap);
				if (soap_in_ns1__TPutFileRequest(soap, "requestArray", a->requestArray, "ns1:TPutFileRequest"))
				{	a->__sizerequestArray++;
					a->requestArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->requestArray)
			soap_pop_block(soap, soap_blist_requestArray);
		if (a->__sizerequestArray)
			a->requestArray = (struct ns1__TPutFileRequest *)soap_save_block(soap, soap_blist_requestArray, NULL, 1);
		else
		{	a->requestArray = NULL;
			if (soap_blist_requestArray)
				soap_end_block(soap, soap_blist_requestArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTPutFileRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTPutFileRequest, 0, sizeof(struct ns1__ArrayOfTPutFileRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizerequestArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTPutFileRequest(struct soap *soap, const struct ns1__ArrayOfTPutFileRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTPutFileRequest);
	if (soap_out_ns1__ArrayOfTPutFileRequest(soap, tag?tag:"ns1:ArrayOfTPutFileRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTPutFileRequest * SOAP_FMAC4 soap_get_ns1__ArrayOfTPutFileRequest(struct soap *soap, struct ns1__ArrayOfTPutFileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTPutFileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TPutFileRequest(struct soap *soap, struct ns1__TPutFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->targetSURL);
	a->expectedFileSize = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TPutFileRequest(struct soap *soap, const struct ns1__TPutFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->targetSURL);
	soap_serialize_PointerTounsignedLONG64(soap, &a->expectedFileSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TPutFileRequest(struct soap *soap, const char *tag, int id, const struct ns1__TPutFileRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TPutFileRequest), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "targetSURL", -1, &a->targetSURL, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "expectedFileSize", -1, &a->expectedFileSize, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TPutFileRequest * SOAP_FMAC4 soap_in_ns1__TPutFileRequest(struct soap *soap, const char *tag, struct ns1__TPutFileRequest *a, const char *type)
{
	size_t soap_flag_targetSURL = 1;
	size_t soap_flag_expectedFileSize = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TPutFileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TPutFileRequest, sizeof(struct ns1__TPutFileRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TPutFileRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_targetSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "targetSURL", &a->targetSURL, "xsd:anyURI"))
				{	soap_flag_targetSURL--;
					continue;
				}
			if (soap_flag_expectedFileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "expectedFileSize", &a->expectedFileSize, "xsd:unsignedLong"))
				{	soap_flag_expectedFileSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TPutFileRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TPutFileRequest, 0, sizeof(struct ns1__TPutFileRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TPutFileRequest(struct soap *soap, const struct ns1__TPutFileRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TPutFileRequest);
	if (soap_out_ns1__TPutFileRequest(soap, tag?tag:"ns1:TPutFileRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TPutFileRequest * SOAP_FMAC4 soap_get_ns1__TPutFileRequest(struct soap *soap, struct ns1__TPutFileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TPutFileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTGetFileRequest(struct soap *soap, struct ns1__ArrayOfTGetFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizerequestArray = 0;
	a->requestArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTGetFileRequest(struct soap *soap, const struct ns1__ArrayOfTGetFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->requestArray)
	{	int i;
		for (i = 0; i < a->__sizerequestArray; i++)
		{
			soap_embedded(soap, a->requestArray + i, SOAP_TYPE_ns1__TGetFileRequest);
			soap_serialize_ns1__TGetFileRequest(soap, a->requestArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTGetFileRequest(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTGetFileRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTGetFileRequest), type))
		return soap->error;
	if (a->requestArray)
	{	int i;
		for (i = 0; i < a->__sizerequestArray; i++)
			if (soap_out_ns1__TGetFileRequest(soap, "requestArray", -1, a->requestArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTGetFileRequest * SOAP_FMAC4 soap_in_ns1__ArrayOfTGetFileRequest(struct soap *soap, const char *tag, struct ns1__ArrayOfTGetFileRequest *a, const char *type)
{
	struct soap_blist *soap_blist_requestArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTGetFileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTGetFileRequest, sizeof(struct ns1__ArrayOfTGetFileRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTGetFileRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "requestArray", 1, NULL))
			{	if (a->requestArray == NULL)
				{	if (soap_blist_requestArray == NULL)
						soap_blist_requestArray = soap_new_block(soap);
					a->requestArray = (struct ns1__TGetFileRequest *)soap_push_block(soap, soap_blist_requestArray, sizeof(struct ns1__TGetFileRequest));
					if (a->requestArray == NULL)
						return NULL;
					soap_default_ns1__TGetFileRequest(soap, a->requestArray);
				}soap_revert(soap);
				if (soap_in_ns1__TGetFileRequest(soap, "requestArray", a->requestArray, "ns1:TGetFileRequest"))
				{	a->__sizerequestArray++;
					a->requestArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->requestArray)
			soap_pop_block(soap, soap_blist_requestArray);
		if (a->__sizerequestArray)
			a->requestArray = (struct ns1__TGetFileRequest *)soap_save_block(soap, soap_blist_requestArray, NULL, 1);
		else
		{	a->requestArray = NULL;
			if (soap_blist_requestArray)
				soap_end_block(soap, soap_blist_requestArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTGetFileRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTGetFileRequest, 0, sizeof(struct ns1__ArrayOfTGetFileRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizerequestArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTGetFileRequest(struct soap *soap, const struct ns1__ArrayOfTGetFileRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTGetFileRequest);
	if (soap_out_ns1__ArrayOfTGetFileRequest(soap, tag?tag:"ns1:ArrayOfTGetFileRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTGetFileRequest * SOAP_FMAC4 soap_get_ns1__ArrayOfTGetFileRequest(struct soap *soap, struct ns1__ArrayOfTGetFileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTGetFileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TGetFileRequest(struct soap *soap, struct ns1__TGetFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->sourceSURL);
	a->dirOption = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TGetFileRequest(struct soap *soap, const struct ns1__TGetFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->sourceSURL);
	soap_serialize_PointerTons1__TDirOption(soap, &a->dirOption);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TGetFileRequest(struct soap *soap, const char *tag, int id, const struct ns1__TGetFileRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TGetFileRequest), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "sourceSURL", -1, &a->sourceSURL, ""))
		return soap->error;
	if (soap_out_PointerTons1__TDirOption(soap, "dirOption", -1, &a->dirOption, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TGetFileRequest * SOAP_FMAC4 soap_in_ns1__TGetFileRequest(struct soap *soap, const char *tag, struct ns1__TGetFileRequest *a, const char *type)
{
	size_t soap_flag_sourceSURL = 1;
	size_t soap_flag_dirOption = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TGetFileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TGetFileRequest, sizeof(struct ns1__TGetFileRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TGetFileRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "sourceSURL", &a->sourceSURL, "xsd:anyURI"))
				{	soap_flag_sourceSURL--;
					continue;
				}
			if (soap_flag_dirOption && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TDirOption(soap, "dirOption", &a->dirOption, "ns1:TDirOption"))
				{	soap_flag_dirOption--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TGetFileRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TGetFileRequest, 0, sizeof(struct ns1__TGetFileRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceSURL > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TGetFileRequest(struct soap *soap, const struct ns1__TGetFileRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TGetFileRequest);
	if (soap_out_ns1__TGetFileRequest(soap, tag?tag:"ns1:TGetFileRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TGetFileRequest * SOAP_FMAC4 soap_get_ns1__TGetFileRequest(struct soap *soap, struct ns1__TGetFileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TGetFileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TTransferParameters(struct soap *soap, struct ns1__TTransferParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->accessPattern = NULL;
	a->connectionType = NULL;
	a->arrayOfClientNetworks = NULL;
	a->arrayOfTransferProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TTransferParameters(struct soap *soap, const struct ns1__TTransferParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TAccessPattern(soap, &a->accessPattern);
	soap_serialize_PointerTons1__TConnectionType(soap, &a->connectionType);
	soap_serialize_PointerTons1__ArrayOfString(soap, &a->arrayOfClientNetworks);
	soap_serialize_PointerTons1__ArrayOfString(soap, &a->arrayOfTransferProtocols);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TTransferParameters(struct soap *soap, const char *tag, int id, const struct ns1__TTransferParameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TTransferParameters), type))
		return soap->error;
	if (soap_out_PointerTons1__TAccessPattern(soap, "accessPattern", -1, &a->accessPattern, ""))
		return soap->error;
	if (soap_out_PointerTons1__TConnectionType(soap, "connectionType", -1, &a->connectionType, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "arrayOfClientNetworks", -1, &a->arrayOfClientNetworks, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "arrayOfTransferProtocols", -1, &a->arrayOfTransferProtocols, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TTransferParameters * SOAP_FMAC4 soap_in_ns1__TTransferParameters(struct soap *soap, const char *tag, struct ns1__TTransferParameters *a, const char *type)
{
	size_t soap_flag_accessPattern = 1;
	size_t soap_flag_connectionType = 1;
	size_t soap_flag_arrayOfClientNetworks = 1;
	size_t soap_flag_arrayOfTransferProtocols = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TTransferParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TTransferParameters, sizeof(struct ns1__TTransferParameters), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TTransferParameters(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessPattern && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TAccessPattern(soap, "accessPattern", &a->accessPattern, "ns1:TAccessPattern"))
				{	soap_flag_accessPattern--;
					continue;
				}
			if (soap_flag_connectionType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TConnectionType(soap, "connectionType", &a->connectionType, "ns1:TConnectionType"))
				{	soap_flag_connectionType--;
					continue;
				}
			if (soap_flag_arrayOfClientNetworks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "arrayOfClientNetworks", &a->arrayOfClientNetworks, "ns1:ArrayOfString"))
				{	soap_flag_arrayOfClientNetworks--;
					continue;
				}
			if (soap_flag_arrayOfTransferProtocols && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "arrayOfTransferProtocols", &a->arrayOfTransferProtocols, "ns1:ArrayOfString"))
				{	soap_flag_arrayOfTransferProtocols--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TTransferParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TTransferParameters, 0, sizeof(struct ns1__TTransferParameters), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TTransferParameters(struct soap *soap, const struct ns1__TTransferParameters *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TTransferParameters);
	if (soap_out_ns1__TTransferParameters(soap, tag?tag:"ns1:TTransferParameters", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TTransferParameters * SOAP_FMAC4 soap_get_ns1__TTransferParameters(struct soap *soap, struct ns1__TTransferParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TTransferParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfAnyURI(struct soap *soap, struct ns1__ArrayOfAnyURI *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeurlArray = 0;
	a->urlArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfAnyURI(struct soap *soap, const struct ns1__ArrayOfAnyURI *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->urlArray)
	{	int i;
		for (i = 0; i < a->__sizeurlArray; i++)
		{
			soap_serialize_xsd__anyURI(soap, a->urlArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfAnyURI(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfAnyURI *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfAnyURI), type))
		return soap->error;
	if (a->urlArray)
	{	int i;
		for (i = 0; i < a->__sizeurlArray; i++)
			if (soap_out_xsd__anyURI(soap, "urlArray", -1, a->urlArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfAnyURI * SOAP_FMAC4 soap_in_ns1__ArrayOfAnyURI(struct soap *soap, const char *tag, struct ns1__ArrayOfAnyURI *a, const char *type)
{
	struct soap_blist *soap_blist_urlArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfAnyURI *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfAnyURI, sizeof(struct ns1__ArrayOfAnyURI), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfAnyURI(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "urlArray", 1, NULL))
			{	if (a->urlArray == NULL)
				{	if (soap_blist_urlArray == NULL)
						soap_blist_urlArray = soap_new_block(soap);
					a->urlArray = (char **)soap_push_block(soap, soap_blist_urlArray, sizeof(char *));
					if (a->urlArray == NULL)
						return NULL;
					*a->urlArray = NULL;
				}soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "urlArray", a->urlArray, "xsd:anyURI"))
				{	a->__sizeurlArray++;
					a->urlArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->urlArray)
			soap_pop_block(soap, soap_blist_urlArray);
		if (a->__sizeurlArray)
			a->urlArray = (char **)soap_save_block(soap, soap_blist_urlArray, NULL, 1);
		else
		{	a->urlArray = NULL;
			if (soap_blist_urlArray)
				soap_end_block(soap, soap_blist_urlArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfAnyURI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfAnyURI, 0, sizeof(struct ns1__ArrayOfAnyURI), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeurlArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfAnyURI(struct soap *soap, const struct ns1__ArrayOfAnyURI *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfAnyURI);
	if (soap_out_ns1__ArrayOfAnyURI(soap, tag?tag:"ns1:ArrayOfAnyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfAnyURI * SOAP_FMAC4 soap_get_ns1__ArrayOfAnyURI(struct soap *soap, struct ns1__ArrayOfAnyURI *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfAnyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTExtraInfo(struct soap *soap, struct ns1__ArrayOfTExtraInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeextraInfoArray = 0;
	a->extraInfoArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTExtraInfo(struct soap *soap, const struct ns1__ArrayOfTExtraInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->extraInfoArray)
	{	int i;
		for (i = 0; i < a->__sizeextraInfoArray; i++)
		{
			soap_embedded(soap, a->extraInfoArray + i, SOAP_TYPE_ns1__TExtraInfo);
			soap_serialize_ns1__TExtraInfo(soap, a->extraInfoArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTExtraInfo(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTExtraInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTExtraInfo), type))
		return soap->error;
	if (a->extraInfoArray)
	{	int i;
		for (i = 0; i < a->__sizeextraInfoArray; i++)
			if (soap_out_ns1__TExtraInfo(soap, "extraInfoArray", -1, a->extraInfoArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTExtraInfo * SOAP_FMAC4 soap_in_ns1__ArrayOfTExtraInfo(struct soap *soap, const char *tag, struct ns1__ArrayOfTExtraInfo *a, const char *type)
{
	struct soap_blist *soap_blist_extraInfoArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTExtraInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTExtraInfo, sizeof(struct ns1__ArrayOfTExtraInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTExtraInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "extraInfoArray", 1, NULL))
			{	if (a->extraInfoArray == NULL)
				{	if (soap_blist_extraInfoArray == NULL)
						soap_blist_extraInfoArray = soap_new_block(soap);
					a->extraInfoArray = (struct ns1__TExtraInfo *)soap_push_block(soap, soap_blist_extraInfoArray, sizeof(struct ns1__TExtraInfo));
					if (a->extraInfoArray == NULL)
						return NULL;
					soap_default_ns1__TExtraInfo(soap, a->extraInfoArray);
				}soap_revert(soap);
				if (soap_in_ns1__TExtraInfo(soap, "extraInfoArray", a->extraInfoArray, "ns1:TExtraInfo"))
				{	a->__sizeextraInfoArray++;
					a->extraInfoArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->extraInfoArray)
			soap_pop_block(soap, soap_blist_extraInfoArray);
		if (a->__sizeextraInfoArray)
			a->extraInfoArray = (struct ns1__TExtraInfo *)soap_save_block(soap, soap_blist_extraInfoArray, NULL, 1);
		else
		{	a->extraInfoArray = NULL;
			if (soap_blist_extraInfoArray)
				soap_end_block(soap, soap_blist_extraInfoArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTExtraInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTExtraInfo, 0, sizeof(struct ns1__ArrayOfTExtraInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeextraInfoArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTExtraInfo(struct soap *soap, const struct ns1__ArrayOfTExtraInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTExtraInfo);
	if (soap_out_ns1__ArrayOfTExtraInfo(soap, tag?tag:"ns1:ArrayOfTExtraInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTExtraInfo * SOAP_FMAC4 soap_get_ns1__ArrayOfTExtraInfo(struct soap *soap, struct ns1__ArrayOfTExtraInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTExtraInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TExtraInfo(struct soap *soap, struct ns1__TExtraInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TExtraInfo(struct soap *soap, const struct ns1__TExtraInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->key);
	soap_serialize_string(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TExtraInfo(struct soap *soap, const char *tag, int id, const struct ns1__TExtraInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TExtraInfo), type))
		return soap->error;
	if (soap_out_string(soap, "key", -1, &a->key, ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TExtraInfo * SOAP_FMAC4 soap_in_ns1__TExtraInfo(struct soap *soap, const char *tag, struct ns1__TExtraInfo *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TExtraInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TExtraInfo, sizeof(struct ns1__TExtraInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TExtraInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "key", &a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TExtraInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TExtraInfo, 0, sizeof(struct ns1__TExtraInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TExtraInfo(struct soap *soap, const struct ns1__TExtraInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TExtraInfo);
	if (soap_out_ns1__TExtraInfo(soap, tag?tag:"ns1:TExtraInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TExtraInfo * SOAP_FMAC4 soap_get_ns1__TExtraInfo(struct soap *soap, struct ns1__TExtraInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TExtraInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TDirOption(struct soap *soap, struct ns1__TDirOption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->isSourceADirectory);
	a->allLevelRecursive = NULL;
	a->numOfLevels = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TDirOption(struct soap *soap, const struct ns1__TDirOption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->isSourceADirectory, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerToxsd__boolean(soap, &a->allLevelRecursive);
	soap_serialize_PointerToint(soap, &a->numOfLevels);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TDirOption(struct soap *soap, const char *tag, int id, const struct ns1__TDirOption *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TDirOption), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "isSourceADirectory", -1, &a->isSourceADirectory, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "allLevelRecursive", -1, &a->allLevelRecursive, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "numOfLevels", -1, &a->numOfLevels, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TDirOption * SOAP_FMAC4 soap_in_ns1__TDirOption(struct soap *soap, const char *tag, struct ns1__TDirOption *a, const char *type)
{
	size_t soap_flag_isSourceADirectory = 1;
	size_t soap_flag_allLevelRecursive = 1;
	size_t soap_flag_numOfLevels = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TDirOption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TDirOption, sizeof(struct ns1__TDirOption), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TDirOption(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_isSourceADirectory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "isSourceADirectory", &a->isSourceADirectory, "xsd:boolean"))
				{	soap_flag_isSourceADirectory--;
					continue;
				}
			if (soap_flag_allLevelRecursive && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "allLevelRecursive", &a->allLevelRecursive, "xsd:boolean"))
				{	soap_flag_allLevelRecursive--;
					continue;
				}
			if (soap_flag_numOfLevels && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numOfLevels", &a->numOfLevels, "xsd:int"))
				{	soap_flag_numOfLevels--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TDirOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TDirOption, 0, sizeof(struct ns1__TDirOption), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isSourceADirectory > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TDirOption(struct soap *soap, const struct ns1__TDirOption *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TDirOption);
	if (soap_out_ns1__TDirOption(soap, tag?tag:"ns1:TDirOption", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TDirOption * SOAP_FMAC4 soap_get_ns1__TDirOption(struct soap *soap, struct ns1__TDirOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TDirOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTMetaDataSpace(struct soap *soap, struct ns1__ArrayOfTMetaDataSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizespaceDataArray = 0;
	a->spaceDataArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTMetaDataSpace(struct soap *soap, const struct ns1__ArrayOfTMetaDataSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->spaceDataArray)
	{	int i;
		for (i = 0; i < a->__sizespaceDataArray; i++)
		{
			soap_embedded(soap, a->spaceDataArray + i, SOAP_TYPE_ns1__TMetaDataSpace);
			soap_serialize_ns1__TMetaDataSpace(soap, a->spaceDataArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTMetaDataSpace(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTMetaDataSpace *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTMetaDataSpace), type))
		return soap->error;
	if (a->spaceDataArray)
	{	int i;
		for (i = 0; i < a->__sizespaceDataArray; i++)
			if (soap_out_ns1__TMetaDataSpace(soap, "spaceDataArray", -1, a->spaceDataArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTMetaDataSpace * SOAP_FMAC4 soap_in_ns1__ArrayOfTMetaDataSpace(struct soap *soap, const char *tag, struct ns1__ArrayOfTMetaDataSpace *a, const char *type)
{
	struct soap_blist *soap_blist_spaceDataArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTMetaDataSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTMetaDataSpace, sizeof(struct ns1__ArrayOfTMetaDataSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTMetaDataSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "spaceDataArray", 1, NULL))
			{	if (a->spaceDataArray == NULL)
				{	if (soap_blist_spaceDataArray == NULL)
						soap_blist_spaceDataArray = soap_new_block(soap);
					a->spaceDataArray = (struct ns1__TMetaDataSpace *)soap_push_block(soap, soap_blist_spaceDataArray, sizeof(struct ns1__TMetaDataSpace));
					if (a->spaceDataArray == NULL)
						return NULL;
					soap_default_ns1__TMetaDataSpace(soap, a->spaceDataArray);
				}soap_revert(soap);
				if (soap_in_ns1__TMetaDataSpace(soap, "spaceDataArray", a->spaceDataArray, "ns1:TMetaDataSpace"))
				{	a->__sizespaceDataArray++;
					a->spaceDataArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->spaceDataArray)
			soap_pop_block(soap, soap_blist_spaceDataArray);
		if (a->__sizespaceDataArray)
			a->spaceDataArray = (struct ns1__TMetaDataSpace *)soap_save_block(soap, soap_blist_spaceDataArray, NULL, 1);
		else
		{	a->spaceDataArray = NULL;
			if (soap_blist_spaceDataArray)
				soap_end_block(soap, soap_blist_spaceDataArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTMetaDataSpace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTMetaDataSpace, 0, sizeof(struct ns1__ArrayOfTMetaDataSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizespaceDataArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTMetaDataSpace(struct soap *soap, const struct ns1__ArrayOfTMetaDataSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTMetaDataSpace);
	if (soap_out_ns1__ArrayOfTMetaDataSpace(soap, tag?tag:"ns1:ArrayOfTMetaDataSpace", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTMetaDataSpace * SOAP_FMAC4 soap_get_ns1__ArrayOfTMetaDataSpace(struct soap *soap, struct ns1__ArrayOfTMetaDataSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTMetaDataSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TMetaDataSpace(struct soap *soap, struct ns1__TMetaDataSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->spaceToken);
	a->status = NULL;
	a->retentionPolicyInfo = NULL;
	soap_default_string(soap, &a->owner);
	a->totalSize = NULL;
	a->guaranteedSize = NULL;
	a->unusedSize = NULL;
	a->lifetimeAssigned = NULL;
	a->lifetimeLeft = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TMetaDataSpace(struct soap *soap, const struct ns1__TMetaDataSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->spaceToken);
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTons1__TRetentionPolicyInfo(soap, &a->retentionPolicyInfo);
	soap_serialize_string(soap, &a->owner);
	soap_serialize_PointerTounsignedLONG64(soap, &a->totalSize);
	soap_serialize_PointerTounsignedLONG64(soap, &a->guaranteedSize);
	soap_serialize_PointerTounsignedLONG64(soap, &a->unusedSize);
	soap_serialize_PointerToint(soap, &a->lifetimeAssigned);
	soap_serialize_PointerToint(soap, &a->lifetimeLeft);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TMetaDataSpace(struct soap *soap, const char *tag, int id, const struct ns1__TMetaDataSpace *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TMetaDataSpace), type))
		return soap->error;
	if (soap_out_string(soap, "spaceToken", -1, &a->spaceToken, ""))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_PointerTons1__TRetentionPolicyInfo(soap, "retentionPolicyInfo", -1, &a->retentionPolicyInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "owner", -1, &a->owner, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "totalSize", -1, &a->totalSize, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "guaranteedSize", -1, &a->guaranteedSize, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "unusedSize", -1, &a->unusedSize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "lifetimeAssigned", -1, &a->lifetimeAssigned, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "lifetimeLeft", -1, &a->lifetimeLeft, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TMetaDataSpace * SOAP_FMAC4 soap_in_ns1__TMetaDataSpace(struct soap *soap, const char *tag, struct ns1__TMetaDataSpace *a, const char *type)
{
	size_t soap_flag_spaceToken = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_retentionPolicyInfo = 1;
	size_t soap_flag_owner = 1;
	size_t soap_flag_totalSize = 1;
	size_t soap_flag_guaranteedSize = 1;
	size_t soap_flag_unusedSize = 1;
	size_t soap_flag_lifetimeAssigned = 1;
	size_t soap_flag_lifetimeLeft = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TMetaDataSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TMetaDataSpace, sizeof(struct ns1__TMetaDataSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TMetaDataSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "status", &a->status, "ns1:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_retentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TRetentionPolicyInfo(soap, "retentionPolicyInfo", &a->retentionPolicyInfo, "ns1:TRetentionPolicyInfo"))
				{	soap_flag_retentionPolicyInfo--;
					continue;
				}
			if (soap_flag_owner && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "owner", &a->owner, "xsd:string"))
				{	soap_flag_owner--;
					continue;
				}
			if (soap_flag_totalSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "totalSize", &a->totalSize, "xsd:unsignedLong"))
				{	soap_flag_totalSize--;
					continue;
				}
			if (soap_flag_guaranteedSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "guaranteedSize", &a->guaranteedSize, "xsd:unsignedLong"))
				{	soap_flag_guaranteedSize--;
					continue;
				}
			if (soap_flag_unusedSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "unusedSize", &a->unusedSize, "xsd:unsignedLong"))
				{	soap_flag_unusedSize--;
					continue;
				}
			if (soap_flag_lifetimeAssigned && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeAssigned", &a->lifetimeAssigned, "xsd:int"))
				{	soap_flag_lifetimeAssigned--;
					continue;
				}
			if (soap_flag_lifetimeLeft && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeLeft", &a->lifetimeLeft, "xsd:int"))
				{	soap_flag_lifetimeLeft--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TMetaDataSpace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TMetaDataSpace, 0, sizeof(struct ns1__TMetaDataSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_spaceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TMetaDataSpace(struct soap *soap, const struct ns1__TMetaDataSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TMetaDataSpace);
	if (soap_out_ns1__TMetaDataSpace(soap, tag?tag:"ns1:TMetaDataSpace", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TMetaDataSpace * SOAP_FMAC4 soap_get_ns1__TMetaDataSpace(struct soap *soap, struct ns1__TMetaDataSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TMetaDataSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTMetaDataPathDetail(struct soap *soap, struct ns1__ArrayOfTMetaDataPathDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizepathDetailArray = 0;
	a->pathDetailArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTMetaDataPathDetail(struct soap *soap, const struct ns1__ArrayOfTMetaDataPathDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->pathDetailArray)
	{	int i;
		for (i = 0; i < a->__sizepathDetailArray; i++)
		{
			soap_embedded(soap, a->pathDetailArray + i, SOAP_TYPE_ns1__TMetaDataPathDetail);
			soap_serialize_ns1__TMetaDataPathDetail(soap, a->pathDetailArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTMetaDataPathDetail(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTMetaDataPathDetail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTMetaDataPathDetail), type))
		return soap->error;
	if (a->pathDetailArray)
	{	int i;
		for (i = 0; i < a->__sizepathDetailArray; i++)
			if (soap_out_ns1__TMetaDataPathDetail(soap, "pathDetailArray", -1, a->pathDetailArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTMetaDataPathDetail * SOAP_FMAC4 soap_in_ns1__ArrayOfTMetaDataPathDetail(struct soap *soap, const char *tag, struct ns1__ArrayOfTMetaDataPathDetail *a, const char *type)
{
	struct soap_blist *soap_blist_pathDetailArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTMetaDataPathDetail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTMetaDataPathDetail, sizeof(struct ns1__ArrayOfTMetaDataPathDetail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTMetaDataPathDetail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "pathDetailArray", 1, NULL))
			{	if (a->pathDetailArray == NULL)
				{	if (soap_blist_pathDetailArray == NULL)
						soap_blist_pathDetailArray = soap_new_block(soap);
					a->pathDetailArray = (struct ns1__TMetaDataPathDetail *)soap_push_block(soap, soap_blist_pathDetailArray, sizeof(struct ns1__TMetaDataPathDetail));
					if (a->pathDetailArray == NULL)
						return NULL;
					soap_default_ns1__TMetaDataPathDetail(soap, a->pathDetailArray);
				}soap_revert(soap);
				if (soap_in_ns1__TMetaDataPathDetail(soap, "pathDetailArray", a->pathDetailArray, "ns1:TMetaDataPathDetail"))
				{	a->__sizepathDetailArray++;
					a->pathDetailArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->pathDetailArray)
			soap_pop_block(soap, soap_blist_pathDetailArray);
		if (a->__sizepathDetailArray)
			a->pathDetailArray = (struct ns1__TMetaDataPathDetail *)soap_save_block(soap, soap_blist_pathDetailArray, NULL, 1);
		else
		{	a->pathDetailArray = NULL;
			if (soap_blist_pathDetailArray)
				soap_end_block(soap, soap_blist_pathDetailArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTMetaDataPathDetail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTMetaDataPathDetail, 0, sizeof(struct ns1__ArrayOfTMetaDataPathDetail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizepathDetailArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTMetaDataPathDetail(struct soap *soap, const struct ns1__ArrayOfTMetaDataPathDetail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTMetaDataPathDetail);
	if (soap_out_ns1__ArrayOfTMetaDataPathDetail(soap, tag?tag:"ns1:ArrayOfTMetaDataPathDetail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTMetaDataPathDetail * SOAP_FMAC4 soap_get_ns1__ArrayOfTMetaDataPathDetail(struct soap *soap, struct ns1__ArrayOfTMetaDataPathDetail *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTMetaDataPathDetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TMetaDataPathDetail(struct soap *soap, struct ns1__TMetaDataPathDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->path);
	a->status = NULL;
	a->size = NULL;
	a->createdAtTime = NULL;
	a->lastModificationTime = NULL;
	a->fileStorageType = NULL;
	a->retentionPolicyInfo = NULL;
	a->fileLocality = NULL;
	a->arrayOfSpaceTokens = NULL;
	a->type = NULL;
	a->lifetimeAssigned = NULL;
	a->lifetimeLeft = NULL;
	a->ownerPermission = NULL;
	a->groupPermission = NULL;
	a->otherPermission = NULL;
	soap_default_string(soap, &a->checkSumType);
	soap_default_string(soap, &a->checkSumValue);
	a->arrayOfSubPaths = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TMetaDataPathDetail(struct soap *soap, const struct ns1__TMetaDataPathDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->path);
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTounsignedLONG64(soap, &a->size);
	soap_serialize_PointerTotime(soap, &a->createdAtTime);
	soap_serialize_PointerTotime(soap, &a->lastModificationTime);
	soap_serialize_PointerTons1__TFileStorageType(soap, &a->fileStorageType);
	soap_serialize_PointerTons1__TRetentionPolicyInfo(soap, &a->retentionPolicyInfo);
	soap_serialize_PointerTons1__TFileLocality(soap, &a->fileLocality);
	soap_serialize_PointerTons1__ArrayOfString(soap, &a->arrayOfSpaceTokens);
	soap_serialize_PointerTons1__TFileType(soap, &a->type);
	soap_serialize_PointerToint(soap, &a->lifetimeAssigned);
	soap_serialize_PointerToint(soap, &a->lifetimeLeft);
	soap_serialize_PointerTons1__TUserPermission(soap, &a->ownerPermission);
	soap_serialize_PointerTons1__TGroupPermission(soap, &a->groupPermission);
	soap_serialize_PointerTons1__TPermissionMode(soap, &a->otherPermission);
	soap_serialize_string(soap, &a->checkSumType);
	soap_serialize_string(soap, &a->checkSumValue);
	soap_serialize_PointerTons1__ArrayOfTMetaDataPathDetail(soap, &a->arrayOfSubPaths);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TMetaDataPathDetail(struct soap *soap, const char *tag, int id, const struct ns1__TMetaDataPathDetail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TMetaDataPathDetail), type))
		return soap->error;
	if (soap_out_string(soap, "path", -1, &a->path, ""))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "size", -1, &a->size, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createdAtTime", -1, &a->createdAtTime, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "lastModificationTime", -1, &a->lastModificationTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__TFileStorageType(soap, "fileStorageType", -1, &a->fileStorageType, ""))
		return soap->error;
	if (soap_out_PointerTons1__TRetentionPolicyInfo(soap, "retentionPolicyInfo", -1, &a->retentionPolicyInfo, ""))
		return soap->error;
	if (soap_out_PointerTons1__TFileLocality(soap, "fileLocality", -1, &a->fileLocality, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "arrayOfSpaceTokens", -1, &a->arrayOfSpaceTokens, ""))
		return soap->error;
	if (soap_out_PointerTons1__TFileType(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "lifetimeAssigned", -1, &a->lifetimeAssigned, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "lifetimeLeft", -1, &a->lifetimeLeft, ""))
		return soap->error;
	if (soap_out_PointerTons1__TUserPermission(soap, "ownerPermission", -1, &a->ownerPermission, ""))
		return soap->error;
	if (soap_out_PointerTons1__TGroupPermission(soap, "groupPermission", -1, &a->groupPermission, ""))
		return soap->error;
	if (soap_out_PointerTons1__TPermissionMode(soap, "otherPermission", -1, &a->otherPermission, ""))
		return soap->error;
	if (soap_out_string(soap, "checkSumType", -1, &a->checkSumType, ""))
		return soap->error;
	if (soap_out_string(soap, "checkSumValue", -1, &a->checkSumValue, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTMetaDataPathDetail(soap, "arrayOfSubPaths", -1, &a->arrayOfSubPaths, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TMetaDataPathDetail * SOAP_FMAC4 soap_in_ns1__TMetaDataPathDetail(struct soap *soap, const char *tag, struct ns1__TMetaDataPathDetail *a, const char *type)
{
	size_t soap_flag_path = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_size = 1;
	size_t soap_flag_createdAtTime = 1;
	size_t soap_flag_lastModificationTime = 1;
	size_t soap_flag_fileStorageType = 1;
	size_t soap_flag_retentionPolicyInfo = 1;
	size_t soap_flag_fileLocality = 1;
	size_t soap_flag_arrayOfSpaceTokens = 1;
	size_t soap_flag_type = 1;
	size_t soap_flag_lifetimeAssigned = 1;
	size_t soap_flag_lifetimeLeft = 1;
	size_t soap_flag_ownerPermission = 1;
	size_t soap_flag_groupPermission = 1;
	size_t soap_flag_otherPermission = 1;
	size_t soap_flag_checkSumType = 1;
	size_t soap_flag_checkSumValue = 1;
	size_t soap_flag_arrayOfSubPaths = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TMetaDataPathDetail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TMetaDataPathDetail, sizeof(struct ns1__TMetaDataPathDetail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TMetaDataPathDetail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_path && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "path", &a->path, "xsd:string"))
				{	soap_flag_path--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "status", &a->status, "ns1:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_size && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "size", &a->size, "xsd:unsignedLong"))
				{	soap_flag_size--;
					continue;
				}
			if (soap_flag_createdAtTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createdAtTime", &a->createdAtTime, "xsd:dateTime"))
				{	soap_flag_createdAtTime--;
					continue;
				}
			if (soap_flag_lastModificationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "lastModificationTime", &a->lastModificationTime, "xsd:dateTime"))
				{	soap_flag_lastModificationTime--;
					continue;
				}
			if (soap_flag_fileStorageType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TFileStorageType(soap, "fileStorageType", &a->fileStorageType, "ns1:TFileStorageType"))
				{	soap_flag_fileStorageType--;
					continue;
				}
			if (soap_flag_retentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TRetentionPolicyInfo(soap, "retentionPolicyInfo", &a->retentionPolicyInfo, "ns1:TRetentionPolicyInfo"))
				{	soap_flag_retentionPolicyInfo--;
					continue;
				}
			if (soap_flag_fileLocality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TFileLocality(soap, "fileLocality", &a->fileLocality, "ns1:TFileLocality"))
				{	soap_flag_fileLocality--;
					continue;
				}
			if (soap_flag_arrayOfSpaceTokens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "arrayOfSpaceTokens", &a->arrayOfSpaceTokens, "ns1:ArrayOfString"))
				{	soap_flag_arrayOfSpaceTokens--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TFileType(soap, "type", &a->type, "ns1:TFileType"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_lifetimeAssigned && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeAssigned", &a->lifetimeAssigned, "xsd:int"))
				{	soap_flag_lifetimeAssigned--;
					continue;
				}
			if (soap_flag_lifetimeLeft && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeLeft", &a->lifetimeLeft, "xsd:int"))
				{	soap_flag_lifetimeLeft--;
					continue;
				}
			if (soap_flag_ownerPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TUserPermission(soap, "ownerPermission", &a->ownerPermission, "ns1:TUserPermission"))
				{	soap_flag_ownerPermission--;
					continue;
				}
			if (soap_flag_groupPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TGroupPermission(soap, "groupPermission", &a->groupPermission, "ns1:TGroupPermission"))
				{	soap_flag_groupPermission--;
					continue;
				}
			if (soap_flag_otherPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TPermissionMode(soap, "otherPermission", &a->otherPermission, "ns1:TPermissionMode"))
				{	soap_flag_otherPermission--;
					continue;
				}
			if (soap_flag_checkSumType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "checkSumType", &a->checkSumType, "xsd:string"))
				{	soap_flag_checkSumType--;
					continue;
				}
			if (soap_flag_checkSumValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "checkSumValue", &a->checkSumValue, "xsd:string"))
				{	soap_flag_checkSumValue--;
					continue;
				}
			if (soap_flag_arrayOfSubPaths && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTMetaDataPathDetail(soap, "arrayOfSubPaths", &a->arrayOfSubPaths, "ns1:ArrayOfTMetaDataPathDetail"))
				{	soap_flag_arrayOfSubPaths--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TMetaDataPathDetail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TMetaDataPathDetail, 0, sizeof(struct ns1__TMetaDataPathDetail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_path > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TMetaDataPathDetail(struct soap *soap, const struct ns1__TMetaDataPathDetail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TMetaDataPathDetail);
	if (soap_out_ns1__TMetaDataPathDetail(soap, tag?tag:"ns1:TMetaDataPathDetail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TMetaDataPathDetail * SOAP_FMAC4 soap_get_ns1__TMetaDataPathDetail(struct soap *soap, struct ns1__TMetaDataPathDetail *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TMetaDataPathDetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, struct ns1__ArrayOfTSURLLifetimeReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestatusArray = 0;
	a->statusArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, const struct ns1__ArrayOfTSURLLifetimeReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
		{
			soap_embedded(soap, a->statusArray + i, SOAP_TYPE_ns1__TSURLLifetimeReturnStatus);
			soap_serialize_ns1__TSURLLifetimeReturnStatus(soap, a->statusArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTSURLLifetimeReturnStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTSURLLifetimeReturnStatus), type))
		return soap->error;
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
			if (soap_out_ns1__TSURLLifetimeReturnStatus(soap, "statusArray", -1, a->statusArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTSURLLifetimeReturnStatus * SOAP_FMAC4 soap_in_ns1__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, const char *tag, struct ns1__ArrayOfTSURLLifetimeReturnStatus *a, const char *type)
{
	struct soap_blist *soap_blist_statusArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTSURLLifetimeReturnStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTSURLLifetimeReturnStatus, sizeof(struct ns1__ArrayOfTSURLLifetimeReturnStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTSURLLifetimeReturnStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "statusArray", 1, NULL))
			{	if (a->statusArray == NULL)
				{	if (soap_blist_statusArray == NULL)
						soap_blist_statusArray = soap_new_block(soap);
					a->statusArray = (struct ns1__TSURLLifetimeReturnStatus *)soap_push_block(soap, soap_blist_statusArray, sizeof(struct ns1__TSURLLifetimeReturnStatus));
					if (a->statusArray == NULL)
						return NULL;
					soap_default_ns1__TSURLLifetimeReturnStatus(soap, a->statusArray);
				}soap_revert(soap);
				if (soap_in_ns1__TSURLLifetimeReturnStatus(soap, "statusArray", a->statusArray, "ns1:TSURLLifetimeReturnStatus"))
				{	a->__sizestatusArray++;
					a->statusArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->statusArray)
			soap_pop_block(soap, soap_blist_statusArray);
		if (a->__sizestatusArray)
			a->statusArray = (struct ns1__TSURLLifetimeReturnStatus *)soap_save_block(soap, soap_blist_statusArray, NULL, 1);
		else
		{	a->statusArray = NULL;
			if (soap_blist_statusArray)
				soap_end_block(soap, soap_blist_statusArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTSURLLifetimeReturnStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTSURLLifetimeReturnStatus, 0, sizeof(struct ns1__ArrayOfTSURLLifetimeReturnStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizestatusArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, const struct ns1__ArrayOfTSURLLifetimeReturnStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTSURLLifetimeReturnStatus);
	if (soap_out_ns1__ArrayOfTSURLLifetimeReturnStatus(soap, tag?tag:"ns1:ArrayOfTSURLLifetimeReturnStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTSURLLifetimeReturnStatus * SOAP_FMAC4 soap_get_ns1__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, struct ns1__ArrayOfTSURLLifetimeReturnStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTSURLLifetimeReturnStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TSURLLifetimeReturnStatus(struct soap *soap, struct ns1__TSURLLifetimeReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->surl);
	a->status = NULL;
	a->fileLifetime = NULL;
	a->pinLifetime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TSURLLifetimeReturnStatus(struct soap *soap, const struct ns1__TSURLLifetimeReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->surl);
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->status);
	soap_serialize_PointerToint(soap, &a->fileLifetime);
	soap_serialize_PointerToint(soap, &a->pinLifetime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TSURLLifetimeReturnStatus(struct soap *soap, const char *tag, int id, const struct ns1__TSURLLifetimeReturnStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TSURLLifetimeReturnStatus), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "surl", -1, &a->surl, ""))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "fileLifetime", -1, &a->fileLifetime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "pinLifetime", -1, &a->pinLifetime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TSURLLifetimeReturnStatus * SOAP_FMAC4 soap_in_ns1__TSURLLifetimeReturnStatus(struct soap *soap, const char *tag, struct ns1__TSURLLifetimeReturnStatus *a, const char *type)
{
	size_t soap_flag_surl = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_fileLifetime = 1;
	size_t soap_flag_pinLifetime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TSURLLifetimeReturnStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TSURLLifetimeReturnStatus, sizeof(struct ns1__TSURLLifetimeReturnStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TSURLLifetimeReturnStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_surl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "surl", &a->surl, "xsd:anyURI"))
				{	soap_flag_surl--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "status", &a->status, "ns1:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_fileLifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "fileLifetime", &a->fileLifetime, "xsd:int"))
				{	soap_flag_fileLifetime--;
					continue;
				}
			if (soap_flag_pinLifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "pinLifetime", &a->pinLifetime, "xsd:int"))
				{	soap_flag_pinLifetime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TSURLLifetimeReturnStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TSURLLifetimeReturnStatus, 0, sizeof(struct ns1__TSURLLifetimeReturnStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_surl > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TSURLLifetimeReturnStatus(struct soap *soap, const struct ns1__TSURLLifetimeReturnStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TSURLLifetimeReturnStatus);
	if (soap_out_ns1__TSURLLifetimeReturnStatus(soap, tag?tag:"ns1:TSURLLifetimeReturnStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TSURLLifetimeReturnStatus * SOAP_FMAC4 soap_get_ns1__TSURLLifetimeReturnStatus(struct soap *soap, struct ns1__TSURLLifetimeReturnStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TSURLLifetimeReturnStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTSURLReturnStatus(struct soap *soap, struct ns1__ArrayOfTSURLReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestatusArray = 0;
	a->statusArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTSURLReturnStatus(struct soap *soap, const struct ns1__ArrayOfTSURLReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
		{
			soap_embedded(soap, a->statusArray + i, SOAP_TYPE_ns1__TSURLReturnStatus);
			soap_serialize_ns1__TSURLReturnStatus(soap, a->statusArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTSURLReturnStatus(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTSURLReturnStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTSURLReturnStatus), type))
		return soap->error;
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
			if (soap_out_ns1__TSURLReturnStatus(soap, "statusArray", -1, a->statusArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTSURLReturnStatus * SOAP_FMAC4 soap_in_ns1__ArrayOfTSURLReturnStatus(struct soap *soap, const char *tag, struct ns1__ArrayOfTSURLReturnStatus *a, const char *type)
{
	struct soap_blist *soap_blist_statusArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTSURLReturnStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTSURLReturnStatus, sizeof(struct ns1__ArrayOfTSURLReturnStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTSURLReturnStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "statusArray", 1, NULL))
			{	if (a->statusArray == NULL)
				{	if (soap_blist_statusArray == NULL)
						soap_blist_statusArray = soap_new_block(soap);
					a->statusArray = (struct ns1__TSURLReturnStatus *)soap_push_block(soap, soap_blist_statusArray, sizeof(struct ns1__TSURLReturnStatus));
					if (a->statusArray == NULL)
						return NULL;
					soap_default_ns1__TSURLReturnStatus(soap, a->statusArray);
				}soap_revert(soap);
				if (soap_in_ns1__TSURLReturnStatus(soap, "statusArray", a->statusArray, "ns1:TSURLReturnStatus"))
				{	a->__sizestatusArray++;
					a->statusArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->statusArray)
			soap_pop_block(soap, soap_blist_statusArray);
		if (a->__sizestatusArray)
			a->statusArray = (struct ns1__TSURLReturnStatus *)soap_save_block(soap, soap_blist_statusArray, NULL, 1);
		else
		{	a->statusArray = NULL;
			if (soap_blist_statusArray)
				soap_end_block(soap, soap_blist_statusArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTSURLReturnStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTSURLReturnStatus, 0, sizeof(struct ns1__ArrayOfTSURLReturnStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizestatusArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTSURLReturnStatus(struct soap *soap, const struct ns1__ArrayOfTSURLReturnStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTSURLReturnStatus);
	if (soap_out_ns1__ArrayOfTSURLReturnStatus(soap, tag?tag:"ns1:ArrayOfTSURLReturnStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTSURLReturnStatus * SOAP_FMAC4 soap_get_ns1__ArrayOfTSURLReturnStatus(struct soap *soap, struct ns1__ArrayOfTSURLReturnStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTSURLReturnStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TSURLReturnStatus(struct soap *soap, struct ns1__TSURLReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->surl);
	a->status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TSURLReturnStatus(struct soap *soap, const struct ns1__TSURLReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->surl);
	soap_serialize_PointerTons1__TReturnStatus(soap, &a->status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TSURLReturnStatus(struct soap *soap, const char *tag, int id, const struct ns1__TSURLReturnStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TSURLReturnStatus), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "surl", -1, &a->surl, ""))
		return soap->error;
	if (soap_out_PointerTons1__TReturnStatus(soap, "status", -1, &a->status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TSURLReturnStatus * SOAP_FMAC4 soap_in_ns1__TSURLReturnStatus(struct soap *soap, const char *tag, struct ns1__TSURLReturnStatus *a, const char *type)
{
	size_t soap_flag_surl = 1;
	size_t soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TSURLReturnStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TSURLReturnStatus, sizeof(struct ns1__TSURLReturnStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TSURLReturnStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_surl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "surl", &a->surl, "xsd:anyURI"))
				{	soap_flag_surl--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TReturnStatus(soap, "status", &a->status, "ns1:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TSURLReturnStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TSURLReturnStatus, 0, sizeof(struct ns1__TSURLReturnStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_surl > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TSURLReturnStatus(struct soap *soap, const struct ns1__TSURLReturnStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TSURLReturnStatus);
	if (soap_out_ns1__TSURLReturnStatus(soap, tag?tag:"ns1:TSURLReturnStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TSURLReturnStatus * SOAP_FMAC4 soap_get_ns1__TSURLReturnStatus(struct soap *soap, struct ns1__TSURLReturnStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TSURLReturnStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TReturnStatus(struct soap *soap, struct ns1__TReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__TStatusCode(soap, &a->statusCode);
	soap_default_string(soap, &a->explanation);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TReturnStatus(struct soap *soap, const struct ns1__TReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->explanation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TReturnStatus(struct soap *soap, const char *tag, int id, const struct ns1__TReturnStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TReturnStatus), type))
		return soap->error;
	if (soap_out_ns1__TStatusCode(soap, "statusCode", -1, &a->statusCode, ""))
		return soap->error;
	if (soap_out_string(soap, "explanation", -1, &a->explanation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TReturnStatus * SOAP_FMAC4 soap_in_ns1__TReturnStatus(struct soap *soap, const char *tag, struct ns1__TReturnStatus *a, const char *type)
{
	size_t soap_flag_statusCode = 1;
	size_t soap_flag_explanation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TReturnStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TReturnStatus, sizeof(struct ns1__TReturnStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TReturnStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__TStatusCode(soap, "statusCode", &a->statusCode, "ns1:TStatusCode"))
				{	soap_flag_statusCode--;
					continue;
				}
			if (soap_flag_explanation && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "explanation", &a->explanation, "xsd:string"))
				{	soap_flag_explanation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TReturnStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TReturnStatus, 0, sizeof(struct ns1__TReturnStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_statusCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TReturnStatus(struct soap *soap, const struct ns1__TReturnStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TReturnStatus);
	if (soap_out_ns1__TReturnStatus(soap, tag?tag:"ns1:TReturnStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TReturnStatus * SOAP_FMAC4 soap_get_ns1__TReturnStatus(struct soap *soap, struct ns1__TReturnStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TReturnStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfString(struct soap *soap, struct ns1__ArrayOfString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestringArray = 0;
	a->stringArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfString(struct soap *soap, const struct ns1__ArrayOfString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->stringArray)
	{	int i;
		for (i = 0; i < a->__sizestringArray; i++)
		{
			soap_serialize_string(soap, a->stringArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfString(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfString), type))
		return soap->error;
	if (a->stringArray)
	{	int i;
		for (i = 0; i < a->__sizestringArray; i++)
			if (soap_out_string(soap, "stringArray", -1, a->stringArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfString * SOAP_FMAC4 soap_in_ns1__ArrayOfString(struct soap *soap, const char *tag, struct ns1__ArrayOfString *a, const char *type)
{
	struct soap_blist *soap_blist_stringArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfString *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfString, sizeof(struct ns1__ArrayOfString), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfString(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "stringArray", 1, NULL))
			{	if (a->stringArray == NULL)
				{	if (soap_blist_stringArray == NULL)
						soap_blist_stringArray = soap_new_block(soap);
					a->stringArray = (char **)soap_push_block(soap, soap_blist_stringArray, sizeof(char *));
					if (a->stringArray == NULL)
						return NULL;
					*a->stringArray = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "stringArray", a->stringArray, "xsd:string"))
				{	a->__sizestringArray++;
					a->stringArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->stringArray)
			soap_pop_block(soap, soap_blist_stringArray);
		if (a->__sizestringArray)
			a->stringArray = (char **)soap_save_block(soap, soap_blist_stringArray, NULL, 1);
		else
		{	a->stringArray = NULL;
			if (soap_blist_stringArray)
				soap_end_block(soap, soap_blist_stringArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfString, 0, sizeof(struct ns1__ArrayOfString), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizestringArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfString(struct soap *soap, const struct ns1__ArrayOfString *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfString);
	if (soap_out_ns1__ArrayOfString(soap, tag?tag:"ns1:ArrayOfString", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfString * SOAP_FMAC4 soap_get_ns1__ArrayOfString(struct soap *soap, struct ns1__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfUnsignedLong(struct soap *soap, struct ns1__ArrayOfUnsignedLong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeunsignedLongArray = 0;
	a->unsignedLongArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfUnsignedLong(struct soap *soap, const struct ns1__ArrayOfUnsignedLong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->unsignedLongArray)
	{	int i;
		for (i = 0; i < a->__sizeunsignedLongArray; i++)
		{
			soap_embedded(soap, a->unsignedLongArray + i, SOAP_TYPE_unsignedLONG64);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfUnsignedLong(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfUnsignedLong *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfUnsignedLong), type))
		return soap->error;
	if (a->unsignedLongArray)
	{	int i;
		for (i = 0; i < a->__sizeunsignedLongArray; i++)
			if (soap_out_unsignedLONG64(soap, "unsignedLongArray", -1, a->unsignedLongArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfUnsignedLong * SOAP_FMAC4 soap_in_ns1__ArrayOfUnsignedLong(struct soap *soap, const char *tag, struct ns1__ArrayOfUnsignedLong *a, const char *type)
{
	struct soap_blist *soap_blist_unsignedLongArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfUnsignedLong *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfUnsignedLong, sizeof(struct ns1__ArrayOfUnsignedLong), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfUnsignedLong(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "unsignedLongArray", 1, NULL))
			{	if (a->unsignedLongArray == NULL)
				{	if (soap_blist_unsignedLongArray == NULL)
						soap_blist_unsignedLongArray = soap_new_block(soap);
					a->unsignedLongArray = (ULONG64 *)soap_push_block(soap, soap_blist_unsignedLongArray, sizeof(ULONG64));
					if (a->unsignedLongArray == NULL)
						return NULL;
					soap_default_unsignedLONG64(soap, a->unsignedLongArray);
				}soap_revert(soap);
				if (soap_in_unsignedLONG64(soap, "unsignedLongArray", a->unsignedLongArray, "xsd:unsignedLong"))
				{	a->__sizeunsignedLongArray++;
					a->unsignedLongArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->unsignedLongArray)
			soap_pop_block(soap, soap_blist_unsignedLongArray);
		if (a->__sizeunsignedLongArray)
			a->unsignedLongArray = (ULONG64 *)soap_save_block(soap, soap_blist_unsignedLongArray, NULL, 1);
		else
		{	a->unsignedLongArray = NULL;
			if (soap_blist_unsignedLongArray)
				soap_end_block(soap, soap_blist_unsignedLongArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfUnsignedLong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfUnsignedLong, 0, sizeof(struct ns1__ArrayOfUnsignedLong), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeunsignedLongArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfUnsignedLong(struct soap *soap, const struct ns1__ArrayOfUnsignedLong *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfUnsignedLong);
	if (soap_out_ns1__ArrayOfUnsignedLong(soap, tag?tag:"ns1:ArrayOfUnsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfUnsignedLong * SOAP_FMAC4 soap_get_ns1__ArrayOfUnsignedLong(struct soap *soap, struct ns1__ArrayOfUnsignedLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfUnsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTGroupPermission(struct soap *soap, struct ns1__ArrayOfTGroupPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizegroupPermissionArray = 0;
	a->groupPermissionArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTGroupPermission(struct soap *soap, const struct ns1__ArrayOfTGroupPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->groupPermissionArray)
	{	int i;
		for (i = 0; i < a->__sizegroupPermissionArray; i++)
		{
			soap_embedded(soap, a->groupPermissionArray + i, SOAP_TYPE_ns1__TGroupPermission);
			soap_serialize_ns1__TGroupPermission(soap, a->groupPermissionArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTGroupPermission(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTGroupPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTGroupPermission), type))
		return soap->error;
	if (a->groupPermissionArray)
	{	int i;
		for (i = 0; i < a->__sizegroupPermissionArray; i++)
			if (soap_out_ns1__TGroupPermission(soap, "groupPermissionArray", -1, a->groupPermissionArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTGroupPermission * SOAP_FMAC4 soap_in_ns1__ArrayOfTGroupPermission(struct soap *soap, const char *tag, struct ns1__ArrayOfTGroupPermission *a, const char *type)
{
	struct soap_blist *soap_blist_groupPermissionArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTGroupPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTGroupPermission, sizeof(struct ns1__ArrayOfTGroupPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTGroupPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "groupPermissionArray", 1, NULL))
			{	if (a->groupPermissionArray == NULL)
				{	if (soap_blist_groupPermissionArray == NULL)
						soap_blist_groupPermissionArray = soap_new_block(soap);
					a->groupPermissionArray = (struct ns1__TGroupPermission *)soap_push_block(soap, soap_blist_groupPermissionArray, sizeof(struct ns1__TGroupPermission));
					if (a->groupPermissionArray == NULL)
						return NULL;
					soap_default_ns1__TGroupPermission(soap, a->groupPermissionArray);
				}soap_revert(soap);
				if (soap_in_ns1__TGroupPermission(soap, "groupPermissionArray", a->groupPermissionArray, "ns1:TGroupPermission"))
				{	a->__sizegroupPermissionArray++;
					a->groupPermissionArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->groupPermissionArray)
			soap_pop_block(soap, soap_blist_groupPermissionArray);
		if (a->__sizegroupPermissionArray)
			a->groupPermissionArray = (struct ns1__TGroupPermission *)soap_save_block(soap, soap_blist_groupPermissionArray, NULL, 1);
		else
		{	a->groupPermissionArray = NULL;
			if (soap_blist_groupPermissionArray)
				soap_end_block(soap, soap_blist_groupPermissionArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTGroupPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTGroupPermission, 0, sizeof(struct ns1__ArrayOfTGroupPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizegroupPermissionArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTGroupPermission(struct soap *soap, const struct ns1__ArrayOfTGroupPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTGroupPermission);
	if (soap_out_ns1__ArrayOfTGroupPermission(soap, tag?tag:"ns1:ArrayOfTGroupPermission", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTGroupPermission * SOAP_FMAC4 soap_get_ns1__ArrayOfTGroupPermission(struct soap *soap, struct ns1__ArrayOfTGroupPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTGroupPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TGroupPermission(struct soap *soap, struct ns1__TGroupPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->groupID);
	soap_default_ns1__TPermissionMode(soap, &a->mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TGroupPermission(struct soap *soap, const struct ns1__TGroupPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->groupID);
	soap_embedded(soap, &a->mode, SOAP_TYPE_ns1__TPermissionMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TGroupPermission(struct soap *soap, const char *tag, int id, const struct ns1__TGroupPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TGroupPermission), type))
		return soap->error;
	if (soap_out_string(soap, "groupID", -1, &a->groupID, ""))
		return soap->error;
	if (soap_out_ns1__TPermissionMode(soap, "mode", -1, &a->mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TGroupPermission * SOAP_FMAC4 soap_in_ns1__TGroupPermission(struct soap *soap, const char *tag, struct ns1__TGroupPermission *a, const char *type)
{
	size_t soap_flag_groupID = 1;
	size_t soap_flag_mode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TGroupPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TGroupPermission, sizeof(struct ns1__TGroupPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TGroupPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "groupID", &a->groupID, "xsd:string"))
				{	soap_flag_groupID--;
					continue;
				}
			if (soap_flag_mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__TPermissionMode(soap, "mode", &a->mode, "ns1:TPermissionMode"))
				{	soap_flag_mode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TGroupPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TGroupPermission, 0, sizeof(struct ns1__TGroupPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupID > 0 || soap_flag_mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TGroupPermission(struct soap *soap, const struct ns1__TGroupPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TGroupPermission);
	if (soap_out_ns1__TGroupPermission(soap, tag?tag:"ns1:TGroupPermission", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TGroupPermission * SOAP_FMAC4 soap_get_ns1__TGroupPermission(struct soap *soap, struct ns1__TGroupPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TGroupPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTUserPermission(struct soap *soap, struct ns1__ArrayOfTUserPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeuserPermissionArray = 0;
	a->userPermissionArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTUserPermission(struct soap *soap, const struct ns1__ArrayOfTUserPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->userPermissionArray)
	{	int i;
		for (i = 0; i < a->__sizeuserPermissionArray; i++)
		{
			soap_embedded(soap, a->userPermissionArray + i, SOAP_TYPE_ns1__TUserPermission);
			soap_serialize_ns1__TUserPermission(soap, a->userPermissionArray + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTUserPermission(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTUserPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTUserPermission), type))
		return soap->error;
	if (a->userPermissionArray)
	{	int i;
		for (i = 0; i < a->__sizeuserPermissionArray; i++)
			if (soap_out_ns1__TUserPermission(soap, "userPermissionArray", -1, a->userPermissionArray + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTUserPermission * SOAP_FMAC4 soap_in_ns1__ArrayOfTUserPermission(struct soap *soap, const char *tag, struct ns1__ArrayOfTUserPermission *a, const char *type)
{
	struct soap_blist *soap_blist_userPermissionArray = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTUserPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTUserPermission, sizeof(struct ns1__ArrayOfTUserPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTUserPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "userPermissionArray", 1, NULL))
			{	if (a->userPermissionArray == NULL)
				{	if (soap_blist_userPermissionArray == NULL)
						soap_blist_userPermissionArray = soap_new_block(soap);
					a->userPermissionArray = (struct ns1__TUserPermission *)soap_push_block(soap, soap_blist_userPermissionArray, sizeof(struct ns1__TUserPermission));
					if (a->userPermissionArray == NULL)
						return NULL;
					soap_default_ns1__TUserPermission(soap, a->userPermissionArray);
				}soap_revert(soap);
				if (soap_in_ns1__TUserPermission(soap, "userPermissionArray", a->userPermissionArray, "ns1:TUserPermission"))
				{	a->__sizeuserPermissionArray++;
					a->userPermissionArray = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->userPermissionArray)
			soap_pop_block(soap, soap_blist_userPermissionArray);
		if (a->__sizeuserPermissionArray)
			a->userPermissionArray = (struct ns1__TUserPermission *)soap_save_block(soap, soap_blist_userPermissionArray, NULL, 1);
		else
		{	a->userPermissionArray = NULL;
			if (soap_blist_userPermissionArray)
				soap_end_block(soap, soap_blist_userPermissionArray);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTUserPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTUserPermission, 0, sizeof(struct ns1__ArrayOfTUserPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeuserPermissionArray < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTUserPermission(struct soap *soap, const struct ns1__ArrayOfTUserPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTUserPermission);
	if (soap_out_ns1__ArrayOfTUserPermission(soap, tag?tag:"ns1:ArrayOfTUserPermission", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTUserPermission * SOAP_FMAC4 soap_get_ns1__ArrayOfTUserPermission(struct soap *soap, struct ns1__ArrayOfTUserPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTUserPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TUserPermission(struct soap *soap, struct ns1__TUserPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->userID);
	soap_default_ns1__TPermissionMode(soap, &a->mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TUserPermission(struct soap *soap, const struct ns1__TUserPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->userID);
	soap_embedded(soap, &a->mode, SOAP_TYPE_ns1__TPermissionMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TUserPermission(struct soap *soap, const char *tag, int id, const struct ns1__TUserPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TUserPermission), type))
		return soap->error;
	if (soap_out_string(soap, "userID", -1, &a->userID, ""))
		return soap->error;
	if (soap_out_ns1__TPermissionMode(soap, "mode", -1, &a->mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TUserPermission * SOAP_FMAC4 soap_in_ns1__TUserPermission(struct soap *soap, const char *tag, struct ns1__TUserPermission *a, const char *type)
{
	size_t soap_flag_userID = 1;
	size_t soap_flag_mode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TUserPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TUserPermission, sizeof(struct ns1__TUserPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TUserPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userID", &a->userID, "xsd:string"))
				{	soap_flag_userID--;
					continue;
				}
			if (soap_flag_mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__TPermissionMode(soap, "mode", &a->mode, "ns1:TPermissionMode"))
				{	soap_flag_mode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TUserPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TUserPermission, 0, sizeof(struct ns1__TUserPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userID > 0 || soap_flag_mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TUserPermission(struct soap *soap, const struct ns1__TUserPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TUserPermission);
	if (soap_out_ns1__TUserPermission(soap, tag?tag:"ns1:TUserPermission", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TUserPermission * SOAP_FMAC4 soap_get_ns1__TUserPermission(struct soap *soap, struct ns1__TUserPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TUserPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TRetentionPolicyInfo(struct soap *soap, struct ns1__TRetentionPolicyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__TRetentionPolicy(soap, &a->retentionPolicy);
	a->accessLatency = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TRetentionPolicyInfo(struct soap *soap, const struct ns1__TRetentionPolicyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TAccessLatency(soap, &a->accessLatency);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TRetentionPolicyInfo(struct soap *soap, const char *tag, int id, const struct ns1__TRetentionPolicyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TRetentionPolicyInfo), type))
		return soap->error;
	if (soap_out_ns1__TRetentionPolicy(soap, "retentionPolicy", -1, &a->retentionPolicy, ""))
		return soap->error;
	if (soap_out_PointerTons1__TAccessLatency(soap, "accessLatency", -1, &a->accessLatency, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TRetentionPolicyInfo * SOAP_FMAC4 soap_in_ns1__TRetentionPolicyInfo(struct soap *soap, const char *tag, struct ns1__TRetentionPolicyInfo *a, const char *type)
{
	size_t soap_flag_retentionPolicy = 1;
	size_t soap_flag_accessLatency = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TRetentionPolicyInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TRetentionPolicyInfo, sizeof(struct ns1__TRetentionPolicyInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TRetentionPolicyInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_retentionPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__TRetentionPolicy(soap, "retentionPolicy", &a->retentionPolicy, "ns1:TRetentionPolicy"))
				{	soap_flag_retentionPolicy--;
					continue;
				}
			if (soap_flag_accessLatency && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TAccessLatency(soap, "accessLatency", &a->accessLatency, "ns1:TAccessLatency"))
				{	soap_flag_accessLatency--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TRetentionPolicyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TRetentionPolicyInfo, 0, sizeof(struct ns1__TRetentionPolicyInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_retentionPolicy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TRetentionPolicyInfo(struct soap *soap, const struct ns1__TRetentionPolicyInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TRetentionPolicyInfo);
	if (soap_out_ns1__TRetentionPolicyInfo(soap, tag?tag:"ns1:TRetentionPolicyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TRetentionPolicyInfo * SOAP_FMAC4 soap_get_ns1__TRetentionPolicyInfo(struct soap *soap, struct ns1__TRetentionPolicyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TRetentionPolicyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPingResponse_(struct soap *soap, struct ns1__srmPingResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPingResponse_))
		soap_serialize_ns1__srmPingResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPingResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmPingResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPingResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPingResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPingResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmPingResponse_(struct soap *soap, const char *tag, struct ns1__srmPingResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPingResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmPingResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPingResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPingResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPingResponse_, sizeof(struct ns1__srmPingResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPingResponse_(struct soap *soap, struct ns1__srmPingResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPingResponse_);
	if (soap_out_PointerTons1__srmPingResponse_(soap, tag?tag:"ns1:srmPingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPingResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmPingResponse_(struct soap *soap, struct ns1__srmPingResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPingResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPingRequest(struct soap *soap, struct ns1__srmPingRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPingRequest))
		soap_serialize_ns1__srmPingRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPingRequest(struct soap *soap, const char *tag, int id, struct ns1__srmPingRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPingRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPingRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPingRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmPingRequest(struct soap *soap, const char *tag, struct ns1__srmPingRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPingRequest **)soap_malloc(soap, sizeof(struct ns1__srmPingRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPingRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPingRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPingRequest, sizeof(struct ns1__srmPingRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPingRequest(struct soap *soap, struct ns1__srmPingRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPingRequest);
	if (soap_out_PointerTons1__srmPingRequest(soap, tag?tag:"ns1:srmPingRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPingRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmPingRequest(struct soap *soap, struct ns1__srmPingRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPingRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPingResponse(struct soap *soap, struct ns1__srmPingResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPingResponse))
		soap_serialize_ns1__srmPingResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPingResponse(struct soap *soap, const char *tag, int id, struct ns1__srmPingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPingResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPingResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmPingResponse(struct soap *soap, const char *tag, struct ns1__srmPingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPingResponse **)soap_malloc(soap, sizeof(struct ns1__srmPingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPingResponse, sizeof(struct ns1__srmPingResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPingResponse(struct soap *soap, struct ns1__srmPingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPingResponse);
	if (soap_out_PointerTons1__srmPingResponse(soap, tag?tag:"ns1:srmPingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPingResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmPingResponse(struct soap *soap, struct ns1__srmPingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetTransferProtocolsResponse_(struct soap *soap, struct ns1__srmGetTransferProtocolsResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse_))
		soap_serialize_ns1__srmGetTransferProtocolsResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetTransferProtocolsResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmGetTransferProtocolsResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetTransferProtocolsResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocolsResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmGetTransferProtocolsResponse_(struct soap *soap, const char *tag, struct ns1__srmGetTransferProtocolsResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetTransferProtocolsResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmGetTransferProtocolsResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetTransferProtocolsResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetTransferProtocolsResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse_, sizeof(struct ns1__srmGetTransferProtocolsResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetTransferProtocolsResponse_(struct soap *soap, struct ns1__srmGetTransferProtocolsResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetTransferProtocolsResponse_);
	if (soap_out_PointerTons1__srmGetTransferProtocolsResponse_(soap, tag?tag:"ns1:srmGetTransferProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocolsResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmGetTransferProtocolsResponse_(struct soap *soap, struct ns1__srmGetTransferProtocolsResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetTransferProtocolsResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetTransferProtocolsRequest(struct soap *soap, struct ns1__srmGetTransferProtocolsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetTransferProtocolsRequest))
		soap_serialize_ns1__srmGetTransferProtocolsRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetTransferProtocolsRequest(struct soap *soap, const char *tag, int id, struct ns1__srmGetTransferProtocolsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetTransferProtocolsRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetTransferProtocolsRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocolsRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmGetTransferProtocolsRequest(struct soap *soap, const char *tag, struct ns1__srmGetTransferProtocolsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetTransferProtocolsRequest **)soap_malloc(soap, sizeof(struct ns1__srmGetTransferProtocolsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetTransferProtocolsRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetTransferProtocolsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetTransferProtocolsRequest, sizeof(struct ns1__srmGetTransferProtocolsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetTransferProtocolsRequest(struct soap *soap, struct ns1__srmGetTransferProtocolsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetTransferProtocolsRequest);
	if (soap_out_PointerTons1__srmGetTransferProtocolsRequest(soap, tag?tag:"ns1:srmGetTransferProtocolsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocolsRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmGetTransferProtocolsRequest(struct soap *soap, struct ns1__srmGetTransferProtocolsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetTransferProtocolsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetTransferProtocolsResponse(struct soap *soap, struct ns1__srmGetTransferProtocolsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse))
		soap_serialize_ns1__srmGetTransferProtocolsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetTransferProtocolsResponse(struct soap *soap, const char *tag, int id, struct ns1__srmGetTransferProtocolsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetTransferProtocolsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocolsResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmGetTransferProtocolsResponse(struct soap *soap, const char *tag, struct ns1__srmGetTransferProtocolsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetTransferProtocolsResponse **)soap_malloc(soap, sizeof(struct ns1__srmGetTransferProtocolsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetTransferProtocolsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetTransferProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetTransferProtocolsResponse, sizeof(struct ns1__srmGetTransferProtocolsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetTransferProtocolsResponse(struct soap *soap, struct ns1__srmGetTransferProtocolsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetTransferProtocolsResponse);
	if (soap_out_PointerTons1__srmGetTransferProtocolsResponse(soap, tag?tag:"ns1:srmGetTransferProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetTransferProtocolsResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmGetTransferProtocolsResponse(struct soap *soap, struct ns1__srmGetTransferProtocolsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetTransferProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetRequestTokensResponse_(struct soap *soap, struct ns1__srmGetRequestTokensResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetRequestTokensResponse_))
		soap_serialize_ns1__srmGetRequestTokensResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetRequestTokensResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmGetRequestTokensResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetRequestTokensResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetRequestTokensResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokensResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmGetRequestTokensResponse_(struct soap *soap, const char *tag, struct ns1__srmGetRequestTokensResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetRequestTokensResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmGetRequestTokensResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetRequestTokensResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestTokensResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetRequestTokensResponse_, sizeof(struct ns1__srmGetRequestTokensResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetRequestTokensResponse_(struct soap *soap, struct ns1__srmGetRequestTokensResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetRequestTokensResponse_);
	if (soap_out_PointerTons1__srmGetRequestTokensResponse_(soap, tag?tag:"ns1:srmGetRequestTokensResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokensResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmGetRequestTokensResponse_(struct soap *soap, struct ns1__srmGetRequestTokensResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetRequestTokensResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetRequestTokensRequest(struct soap *soap, struct ns1__srmGetRequestTokensRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetRequestTokensRequest))
		soap_serialize_ns1__srmGetRequestTokensRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetRequestTokensRequest(struct soap *soap, const char *tag, int id, struct ns1__srmGetRequestTokensRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetRequestTokensRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetRequestTokensRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokensRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmGetRequestTokensRequest(struct soap *soap, const char *tag, struct ns1__srmGetRequestTokensRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetRequestTokensRequest **)soap_malloc(soap, sizeof(struct ns1__srmGetRequestTokensRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetRequestTokensRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestTokensRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetRequestTokensRequest, sizeof(struct ns1__srmGetRequestTokensRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetRequestTokensRequest(struct soap *soap, struct ns1__srmGetRequestTokensRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetRequestTokensRequest);
	if (soap_out_PointerTons1__srmGetRequestTokensRequest(soap, tag?tag:"ns1:srmGetRequestTokensRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokensRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmGetRequestTokensRequest(struct soap *soap, struct ns1__srmGetRequestTokensRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetRequestTokensRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetRequestTokensResponse(struct soap *soap, struct ns1__srmGetRequestTokensResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetRequestTokensResponse))
		soap_serialize_ns1__srmGetRequestTokensResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetRequestTokensResponse(struct soap *soap, const char *tag, int id, struct ns1__srmGetRequestTokensResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetRequestTokensResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetRequestTokensResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokensResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmGetRequestTokensResponse(struct soap *soap, const char *tag, struct ns1__srmGetRequestTokensResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetRequestTokensResponse **)soap_malloc(soap, sizeof(struct ns1__srmGetRequestTokensResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetRequestTokensResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestTokensResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetRequestTokensResponse, sizeof(struct ns1__srmGetRequestTokensResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetRequestTokensResponse(struct soap *soap, struct ns1__srmGetRequestTokensResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetRequestTokensResponse);
	if (soap_out_PointerTons1__srmGetRequestTokensResponse(soap, tag?tag:"ns1:srmGetRequestTokensResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestTokensResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmGetRequestTokensResponse(struct soap *soap, struct ns1__srmGetRequestTokensResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetRequestTokensResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmExtendFileLifeTimeResponse_(struct soap *soap, struct ns1__srmExtendFileLifeTimeResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse_))
		soap_serialize_ns1__srmExtendFileLifeTimeResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmExtendFileLifeTimeResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmExtendFileLifeTimeResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmExtendFileLifeTimeResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmExtendFileLifeTimeResponse_(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmExtendFileLifeTimeResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmExtendFileLifeTimeResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmExtendFileLifeTimeResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse_, sizeof(struct ns1__srmExtendFileLifeTimeResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmExtendFileLifeTimeResponse_(struct soap *soap, struct ns1__srmExtendFileLifeTimeResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeResponse_);
	if (soap_out_PointerTons1__srmExtendFileLifeTimeResponse_(soap, tag?tag:"ns1:srmExtendFileLifeTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmExtendFileLifeTimeResponse_(struct soap *soap, struct ns1__srmExtendFileLifeTimeResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmExtendFileLifeTimeResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmExtendFileLifeTimeRequest(struct soap *soap, struct ns1__srmExtendFileLifeTimeRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmExtendFileLifeTimeRequest))
		soap_serialize_ns1__srmExtendFileLifeTimeRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmExtendFileLifeTimeRequest(struct soap *soap, const char *tag, int id, struct ns1__srmExtendFileLifeTimeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmExtendFileLifeTimeRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmExtendFileLifeTimeRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmExtendFileLifeTimeRequest(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmExtendFileLifeTimeRequest **)soap_malloc(soap, sizeof(struct ns1__srmExtendFileLifeTimeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmExtendFileLifeTimeRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmExtendFileLifeTimeRequest, sizeof(struct ns1__srmExtendFileLifeTimeRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmExtendFileLifeTimeRequest(struct soap *soap, struct ns1__srmExtendFileLifeTimeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeRequest);
	if (soap_out_PointerTons1__srmExtendFileLifeTimeRequest(soap, tag?tag:"ns1:srmExtendFileLifeTimeRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmExtendFileLifeTimeRequest(struct soap *soap, struct ns1__srmExtendFileLifeTimeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmExtendFileLifeTimeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmExtendFileLifeTimeResponse(struct soap *soap, struct ns1__srmExtendFileLifeTimeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse))
		soap_serialize_ns1__srmExtendFileLifeTimeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmExtendFileLifeTimeResponse(struct soap *soap, const char *tag, int id, struct ns1__srmExtendFileLifeTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmExtendFileLifeTimeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmExtendFileLifeTimeResponse(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmExtendFileLifeTimeResponse **)soap_malloc(soap, sizeof(struct ns1__srmExtendFileLifeTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmExtendFileLifeTimeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmExtendFileLifeTimeResponse, sizeof(struct ns1__srmExtendFileLifeTimeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmExtendFileLifeTimeResponse(struct soap *soap, struct ns1__srmExtendFileLifeTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeResponse);
	if (soap_out_PointerTons1__srmExtendFileLifeTimeResponse(soap, tag?tag:"ns1:srmExtendFileLifeTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmExtendFileLifeTimeResponse(struct soap *soap, struct ns1__srmExtendFileLifeTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmExtendFileLifeTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetRequestSummaryResponse_(struct soap *soap, struct ns1__srmGetRequestSummaryResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetRequestSummaryResponse_))
		soap_serialize_ns1__srmGetRequestSummaryResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetRequestSummaryResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmGetRequestSummaryResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetRequestSummaryResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetRequestSummaryResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummaryResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmGetRequestSummaryResponse_(struct soap *soap, const char *tag, struct ns1__srmGetRequestSummaryResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetRequestSummaryResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmGetRequestSummaryResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetRequestSummaryResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestSummaryResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetRequestSummaryResponse_, sizeof(struct ns1__srmGetRequestSummaryResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetRequestSummaryResponse_(struct soap *soap, struct ns1__srmGetRequestSummaryResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetRequestSummaryResponse_);
	if (soap_out_PointerTons1__srmGetRequestSummaryResponse_(soap, tag?tag:"ns1:srmGetRequestSummaryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummaryResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmGetRequestSummaryResponse_(struct soap *soap, struct ns1__srmGetRequestSummaryResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetRequestSummaryResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetRequestSummaryRequest(struct soap *soap, struct ns1__srmGetRequestSummaryRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetRequestSummaryRequest))
		soap_serialize_ns1__srmGetRequestSummaryRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetRequestSummaryRequest(struct soap *soap, const char *tag, int id, struct ns1__srmGetRequestSummaryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetRequestSummaryRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetRequestSummaryRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummaryRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmGetRequestSummaryRequest(struct soap *soap, const char *tag, struct ns1__srmGetRequestSummaryRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetRequestSummaryRequest **)soap_malloc(soap, sizeof(struct ns1__srmGetRequestSummaryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetRequestSummaryRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestSummaryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetRequestSummaryRequest, sizeof(struct ns1__srmGetRequestSummaryRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetRequestSummaryRequest(struct soap *soap, struct ns1__srmGetRequestSummaryRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetRequestSummaryRequest);
	if (soap_out_PointerTons1__srmGetRequestSummaryRequest(soap, tag?tag:"ns1:srmGetRequestSummaryRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummaryRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmGetRequestSummaryRequest(struct soap *soap, struct ns1__srmGetRequestSummaryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetRequestSummaryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetRequestSummaryResponse(struct soap *soap, struct ns1__srmGetRequestSummaryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetRequestSummaryResponse))
		soap_serialize_ns1__srmGetRequestSummaryResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetRequestSummaryResponse(struct soap *soap, const char *tag, int id, struct ns1__srmGetRequestSummaryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetRequestSummaryResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetRequestSummaryResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummaryResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmGetRequestSummaryResponse(struct soap *soap, const char *tag, struct ns1__srmGetRequestSummaryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetRequestSummaryResponse **)soap_malloc(soap, sizeof(struct ns1__srmGetRequestSummaryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetRequestSummaryResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetRequestSummaryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetRequestSummaryResponse, sizeof(struct ns1__srmGetRequestSummaryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetRequestSummaryResponse(struct soap *soap, struct ns1__srmGetRequestSummaryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetRequestSummaryResponse);
	if (soap_out_PointerTons1__srmGetRequestSummaryResponse(soap, tag?tag:"ns1:srmGetRequestSummaryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetRequestSummaryResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmGetRequestSummaryResponse(struct soap *soap, struct ns1__srmGetRequestSummaryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetRequestSummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmResumeRequestResponse_(struct soap *soap, struct ns1__srmResumeRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmResumeRequestResponse_))
		soap_serialize_ns1__srmResumeRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmResumeRequestResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmResumeRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmResumeRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmResumeRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmResumeRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmResumeRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmResumeRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmResumeRequestResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmResumeRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmResumeRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmResumeRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmResumeRequestResponse_, sizeof(struct ns1__srmResumeRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmResumeRequestResponse_(struct soap *soap, struct ns1__srmResumeRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmResumeRequestResponse_);
	if (soap_out_PointerTons1__srmResumeRequestResponse_(soap, tag?tag:"ns1:srmResumeRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmResumeRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmResumeRequestResponse_(struct soap *soap, struct ns1__srmResumeRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmResumeRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmResumeRequestRequest(struct soap *soap, struct ns1__srmResumeRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmResumeRequestRequest))
		soap_serialize_ns1__srmResumeRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmResumeRequestRequest(struct soap *soap, const char *tag, int id, struct ns1__srmResumeRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmResumeRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmResumeRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmResumeRequestRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmResumeRequestRequest(struct soap *soap, const char *tag, struct ns1__srmResumeRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmResumeRequestRequest **)soap_malloc(soap, sizeof(struct ns1__srmResumeRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmResumeRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmResumeRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmResumeRequestRequest, sizeof(struct ns1__srmResumeRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmResumeRequestRequest(struct soap *soap, struct ns1__srmResumeRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmResumeRequestRequest);
	if (soap_out_PointerTons1__srmResumeRequestRequest(soap, tag?tag:"ns1:srmResumeRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmResumeRequestRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmResumeRequestRequest(struct soap *soap, struct ns1__srmResumeRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmResumeRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmResumeRequestResponse(struct soap *soap, struct ns1__srmResumeRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmResumeRequestResponse))
		soap_serialize_ns1__srmResumeRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmResumeRequestResponse(struct soap *soap, const char *tag, int id, struct ns1__srmResumeRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmResumeRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmResumeRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmResumeRequestResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmResumeRequestResponse(struct soap *soap, const char *tag, struct ns1__srmResumeRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmResumeRequestResponse **)soap_malloc(soap, sizeof(struct ns1__srmResumeRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmResumeRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmResumeRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmResumeRequestResponse, sizeof(struct ns1__srmResumeRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmResumeRequestResponse(struct soap *soap, struct ns1__srmResumeRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmResumeRequestResponse);
	if (soap_out_PointerTons1__srmResumeRequestResponse(soap, tag?tag:"ns1:srmResumeRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmResumeRequestResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmResumeRequestResponse(struct soap *soap, struct ns1__srmResumeRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmResumeRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmSuspendRequestResponse_(struct soap *soap, struct ns1__srmSuspendRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmSuspendRequestResponse_))
		soap_serialize_ns1__srmSuspendRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmSuspendRequestResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmSuspendRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmSuspendRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmSuspendRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmSuspendRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmSuspendRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmSuspendRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmSuspendRequestResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmSuspendRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmSuspendRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSuspendRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmSuspendRequestResponse_, sizeof(struct ns1__srmSuspendRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmSuspendRequestResponse_(struct soap *soap, struct ns1__srmSuspendRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmSuspendRequestResponse_);
	if (soap_out_PointerTons1__srmSuspendRequestResponse_(soap, tag?tag:"ns1:srmSuspendRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSuspendRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmSuspendRequestResponse_(struct soap *soap, struct ns1__srmSuspendRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmSuspendRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmSuspendRequestRequest(struct soap *soap, struct ns1__srmSuspendRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmSuspendRequestRequest))
		soap_serialize_ns1__srmSuspendRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmSuspendRequestRequest(struct soap *soap, const char *tag, int id, struct ns1__srmSuspendRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmSuspendRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmSuspendRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmSuspendRequestRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmSuspendRequestRequest(struct soap *soap, const char *tag, struct ns1__srmSuspendRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmSuspendRequestRequest **)soap_malloc(soap, sizeof(struct ns1__srmSuspendRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmSuspendRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSuspendRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmSuspendRequestRequest, sizeof(struct ns1__srmSuspendRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmSuspendRequestRequest(struct soap *soap, struct ns1__srmSuspendRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmSuspendRequestRequest);
	if (soap_out_PointerTons1__srmSuspendRequestRequest(soap, tag?tag:"ns1:srmSuspendRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSuspendRequestRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmSuspendRequestRequest(struct soap *soap, struct ns1__srmSuspendRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmSuspendRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmSuspendRequestResponse(struct soap *soap, struct ns1__srmSuspendRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmSuspendRequestResponse))
		soap_serialize_ns1__srmSuspendRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmSuspendRequestResponse(struct soap *soap, const char *tag, int id, struct ns1__srmSuspendRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmSuspendRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmSuspendRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmSuspendRequestResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmSuspendRequestResponse(struct soap *soap, const char *tag, struct ns1__srmSuspendRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmSuspendRequestResponse **)soap_malloc(soap, sizeof(struct ns1__srmSuspendRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmSuspendRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSuspendRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmSuspendRequestResponse, sizeof(struct ns1__srmSuspendRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmSuspendRequestResponse(struct soap *soap, struct ns1__srmSuspendRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmSuspendRequestResponse);
	if (soap_out_PointerTons1__srmSuspendRequestResponse(soap, tag?tag:"ns1:srmSuspendRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSuspendRequestResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmSuspendRequestResponse(struct soap *soap, struct ns1__srmSuspendRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmSuspendRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmAbortFilesResponse_(struct soap *soap, struct ns1__srmAbortFilesResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmAbortFilesResponse_))
		soap_serialize_ns1__srmAbortFilesResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmAbortFilesResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmAbortFilesResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmAbortFilesResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmAbortFilesResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmAbortFilesResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmAbortFilesResponse_(struct soap *soap, const char *tag, struct ns1__srmAbortFilesResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmAbortFilesResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmAbortFilesResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmAbortFilesResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortFilesResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmAbortFilesResponse_, sizeof(struct ns1__srmAbortFilesResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmAbortFilesResponse_(struct soap *soap, struct ns1__srmAbortFilesResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmAbortFilesResponse_);
	if (soap_out_PointerTons1__srmAbortFilesResponse_(soap, tag?tag:"ns1:srmAbortFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortFilesResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmAbortFilesResponse_(struct soap *soap, struct ns1__srmAbortFilesResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmAbortFilesResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmAbortFilesRequest(struct soap *soap, struct ns1__srmAbortFilesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmAbortFilesRequest))
		soap_serialize_ns1__srmAbortFilesRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmAbortFilesRequest(struct soap *soap, const char *tag, int id, struct ns1__srmAbortFilesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmAbortFilesRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmAbortFilesRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmAbortFilesRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmAbortFilesRequest(struct soap *soap, const char *tag, struct ns1__srmAbortFilesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmAbortFilesRequest **)soap_malloc(soap, sizeof(struct ns1__srmAbortFilesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmAbortFilesRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortFilesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmAbortFilesRequest, sizeof(struct ns1__srmAbortFilesRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmAbortFilesRequest(struct soap *soap, struct ns1__srmAbortFilesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmAbortFilesRequest);
	if (soap_out_PointerTons1__srmAbortFilesRequest(soap, tag?tag:"ns1:srmAbortFilesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortFilesRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmAbortFilesRequest(struct soap *soap, struct ns1__srmAbortFilesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmAbortFilesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmAbortFilesResponse(struct soap *soap, struct ns1__srmAbortFilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmAbortFilesResponse))
		soap_serialize_ns1__srmAbortFilesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmAbortFilesResponse(struct soap *soap, const char *tag, int id, struct ns1__srmAbortFilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmAbortFilesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmAbortFilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmAbortFilesResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmAbortFilesResponse(struct soap *soap, const char *tag, struct ns1__srmAbortFilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmAbortFilesResponse **)soap_malloc(soap, sizeof(struct ns1__srmAbortFilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmAbortFilesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortFilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmAbortFilesResponse, sizeof(struct ns1__srmAbortFilesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmAbortFilesResponse(struct soap *soap, struct ns1__srmAbortFilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmAbortFilesResponse);
	if (soap_out_PointerTons1__srmAbortFilesResponse(soap, tag?tag:"ns1:srmAbortFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortFilesResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmAbortFilesResponse(struct soap *soap, struct ns1__srmAbortFilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmAbortFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmAbortRequestResponse_(struct soap *soap, struct ns1__srmAbortRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmAbortRequestResponse_))
		soap_serialize_ns1__srmAbortRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmAbortRequestResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmAbortRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmAbortRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmAbortRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmAbortRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmAbortRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmAbortRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmAbortRequestResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmAbortRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmAbortRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmAbortRequestResponse_, sizeof(struct ns1__srmAbortRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmAbortRequestResponse_(struct soap *soap, struct ns1__srmAbortRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmAbortRequestResponse_);
	if (soap_out_PointerTons1__srmAbortRequestResponse_(soap, tag?tag:"ns1:srmAbortRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmAbortRequestResponse_(struct soap *soap, struct ns1__srmAbortRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmAbortRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmAbortRequestRequest(struct soap *soap, struct ns1__srmAbortRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmAbortRequestRequest))
		soap_serialize_ns1__srmAbortRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmAbortRequestRequest(struct soap *soap, const char *tag, int id, struct ns1__srmAbortRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmAbortRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmAbortRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmAbortRequestRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmAbortRequestRequest(struct soap *soap, const char *tag, struct ns1__srmAbortRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmAbortRequestRequest **)soap_malloc(soap, sizeof(struct ns1__srmAbortRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmAbortRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmAbortRequestRequest, sizeof(struct ns1__srmAbortRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmAbortRequestRequest(struct soap *soap, struct ns1__srmAbortRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmAbortRequestRequest);
	if (soap_out_PointerTons1__srmAbortRequestRequest(soap, tag?tag:"ns1:srmAbortRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortRequestRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmAbortRequestRequest(struct soap *soap, struct ns1__srmAbortRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmAbortRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmAbortRequestResponse(struct soap *soap, struct ns1__srmAbortRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmAbortRequestResponse))
		soap_serialize_ns1__srmAbortRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmAbortRequestResponse(struct soap *soap, const char *tag, int id, struct ns1__srmAbortRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmAbortRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmAbortRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmAbortRequestResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmAbortRequestResponse(struct soap *soap, const char *tag, struct ns1__srmAbortRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmAbortRequestResponse **)soap_malloc(soap, sizeof(struct ns1__srmAbortRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmAbortRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmAbortRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmAbortRequestResponse, sizeof(struct ns1__srmAbortRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmAbortRequestResponse(struct soap *soap, struct ns1__srmAbortRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmAbortRequestResponse);
	if (soap_out_PointerTons1__srmAbortRequestResponse(soap, tag?tag:"ns1:srmAbortRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmAbortRequestResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmAbortRequestResponse(struct soap *soap, struct ns1__srmAbortRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmAbortRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPutDoneResponse_(struct soap *soap, struct ns1__srmPutDoneResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPutDoneResponse_))
		soap_serialize_ns1__srmPutDoneResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPutDoneResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmPutDoneResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPutDoneResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPutDoneResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPutDoneResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmPutDoneResponse_(struct soap *soap, const char *tag, struct ns1__srmPutDoneResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPutDoneResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmPutDoneResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPutDoneResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPutDoneResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPutDoneResponse_, sizeof(struct ns1__srmPutDoneResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPutDoneResponse_(struct soap *soap, struct ns1__srmPutDoneResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPutDoneResponse_);
	if (soap_out_PointerTons1__srmPutDoneResponse_(soap, tag?tag:"ns1:srmPutDoneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPutDoneResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmPutDoneResponse_(struct soap *soap, struct ns1__srmPutDoneResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPutDoneResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPutDoneRequest(struct soap *soap, struct ns1__srmPutDoneRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPutDoneRequest))
		soap_serialize_ns1__srmPutDoneRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPutDoneRequest(struct soap *soap, const char *tag, int id, struct ns1__srmPutDoneRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPutDoneRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPutDoneRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPutDoneRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmPutDoneRequest(struct soap *soap, const char *tag, struct ns1__srmPutDoneRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPutDoneRequest **)soap_malloc(soap, sizeof(struct ns1__srmPutDoneRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPutDoneRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPutDoneRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPutDoneRequest, sizeof(struct ns1__srmPutDoneRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPutDoneRequest(struct soap *soap, struct ns1__srmPutDoneRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPutDoneRequest);
	if (soap_out_PointerTons1__srmPutDoneRequest(soap, tag?tag:"ns1:srmPutDoneRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPutDoneRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmPutDoneRequest(struct soap *soap, struct ns1__srmPutDoneRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPutDoneRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPutDoneResponse(struct soap *soap, struct ns1__srmPutDoneResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPutDoneResponse))
		soap_serialize_ns1__srmPutDoneResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPutDoneResponse(struct soap *soap, const char *tag, int id, struct ns1__srmPutDoneResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPutDoneResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPutDoneResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPutDoneResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmPutDoneResponse(struct soap *soap, const char *tag, struct ns1__srmPutDoneResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPutDoneResponse **)soap_malloc(soap, sizeof(struct ns1__srmPutDoneResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPutDoneResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPutDoneResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPutDoneResponse, sizeof(struct ns1__srmPutDoneResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPutDoneResponse(struct soap *soap, struct ns1__srmPutDoneResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPutDoneResponse);
	if (soap_out_PointerTons1__srmPutDoneResponse(soap, tag?tag:"ns1:srmPutDoneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPutDoneResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmPutDoneResponse(struct soap *soap, struct ns1__srmPutDoneResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPutDoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmReleaseFilesResponse_(struct soap *soap, struct ns1__srmReleaseFilesResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmReleaseFilesResponse_))
		soap_serialize_ns1__srmReleaseFilesResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmReleaseFilesResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmReleaseFilesResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmReleaseFilesResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmReleaseFilesResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmReleaseFilesResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmReleaseFilesResponse_(struct soap *soap, const char *tag, struct ns1__srmReleaseFilesResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmReleaseFilesResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmReleaseFilesResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmReleaseFilesResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseFilesResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmReleaseFilesResponse_, sizeof(struct ns1__srmReleaseFilesResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmReleaseFilesResponse_(struct soap *soap, struct ns1__srmReleaseFilesResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmReleaseFilesResponse_);
	if (soap_out_PointerTons1__srmReleaseFilesResponse_(soap, tag?tag:"ns1:srmReleaseFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseFilesResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmReleaseFilesResponse_(struct soap *soap, struct ns1__srmReleaseFilesResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmReleaseFilesResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmReleaseFilesRequest(struct soap *soap, struct ns1__srmReleaseFilesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmReleaseFilesRequest))
		soap_serialize_ns1__srmReleaseFilesRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmReleaseFilesRequest(struct soap *soap, const char *tag, int id, struct ns1__srmReleaseFilesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmReleaseFilesRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmReleaseFilesRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmReleaseFilesRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmReleaseFilesRequest(struct soap *soap, const char *tag, struct ns1__srmReleaseFilesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmReleaseFilesRequest **)soap_malloc(soap, sizeof(struct ns1__srmReleaseFilesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmReleaseFilesRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseFilesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmReleaseFilesRequest, sizeof(struct ns1__srmReleaseFilesRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmReleaseFilesRequest(struct soap *soap, struct ns1__srmReleaseFilesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmReleaseFilesRequest);
	if (soap_out_PointerTons1__srmReleaseFilesRequest(soap, tag?tag:"ns1:srmReleaseFilesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseFilesRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmReleaseFilesRequest(struct soap *soap, struct ns1__srmReleaseFilesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmReleaseFilesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmReleaseFilesResponse(struct soap *soap, struct ns1__srmReleaseFilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmReleaseFilesResponse))
		soap_serialize_ns1__srmReleaseFilesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmReleaseFilesResponse(struct soap *soap, const char *tag, int id, struct ns1__srmReleaseFilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmReleaseFilesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmReleaseFilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmReleaseFilesResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmReleaseFilesResponse(struct soap *soap, const char *tag, struct ns1__srmReleaseFilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmReleaseFilesResponse **)soap_malloc(soap, sizeof(struct ns1__srmReleaseFilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmReleaseFilesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseFilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmReleaseFilesResponse, sizeof(struct ns1__srmReleaseFilesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmReleaseFilesResponse(struct soap *soap, struct ns1__srmReleaseFilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmReleaseFilesResponse);
	if (soap_out_PointerTons1__srmReleaseFilesResponse(soap, tag?tag:"ns1:srmReleaseFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseFilesResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmReleaseFilesResponse(struct soap *soap, struct ns1__srmReleaseFilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmReleaseFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfCopyRequestResponse_(struct soap *soap, struct ns1__srmStatusOfCopyRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse_))
		soap_serialize_ns1__srmStatusOfCopyRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfCopyRequestResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfCopyRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfCopyRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfCopyRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfCopyRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfCopyRequestResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfCopyRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfCopyRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfCopyRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse_, sizeof(struct ns1__srmStatusOfCopyRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfCopyRequestResponse_(struct soap *soap, struct ns1__srmStatusOfCopyRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfCopyRequestResponse_);
	if (soap_out_PointerTons1__srmStatusOfCopyRequestResponse_(soap, tag?tag:"ns1:srmStatusOfCopyRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfCopyRequestResponse_(struct soap *soap, struct ns1__srmStatusOfCopyRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfCopyRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfCopyRequestRequest(struct soap *soap, struct ns1__srmStatusOfCopyRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfCopyRequestRequest))
		soap_serialize_ns1__srmStatusOfCopyRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfCopyRequestRequest(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfCopyRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfCopyRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfCopyRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequestRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfCopyRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfCopyRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfCopyRequestRequest **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfCopyRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfCopyRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfCopyRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfCopyRequestRequest, sizeof(struct ns1__srmStatusOfCopyRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfCopyRequestRequest(struct soap *soap, struct ns1__srmStatusOfCopyRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfCopyRequestRequest);
	if (soap_out_PointerTons1__srmStatusOfCopyRequestRequest(soap, tag?tag:"ns1:srmStatusOfCopyRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequestRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfCopyRequestRequest(struct soap *soap, struct ns1__srmStatusOfCopyRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfCopyRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfCopyRequestResponse(struct soap *soap, struct ns1__srmStatusOfCopyRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse))
		soap_serialize_ns1__srmStatusOfCopyRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfCopyRequestResponse(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfCopyRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfCopyRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequestResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfCopyRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfCopyRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfCopyRequestResponse **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfCopyRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfCopyRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfCopyRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfCopyRequestResponse, sizeof(struct ns1__srmStatusOfCopyRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfCopyRequestResponse(struct soap *soap, struct ns1__srmStatusOfCopyRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfCopyRequestResponse);
	if (soap_out_PointerTons1__srmStatusOfCopyRequestResponse(soap, tag?tag:"ns1:srmStatusOfCopyRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfCopyRequestResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfCopyRequestResponse(struct soap *soap, struct ns1__srmStatusOfCopyRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfCopyRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmCopyResponse_(struct soap *soap, struct ns1__srmCopyResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmCopyResponse_))
		soap_serialize_ns1__srmCopyResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmCopyResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmCopyResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmCopyResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmCopyResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmCopyResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmCopyResponse_(struct soap *soap, const char *tag, struct ns1__srmCopyResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmCopyResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmCopyResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmCopyResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCopyResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmCopyResponse_, sizeof(struct ns1__srmCopyResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmCopyResponse_(struct soap *soap, struct ns1__srmCopyResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmCopyResponse_);
	if (soap_out_PointerTons1__srmCopyResponse_(soap, tag?tag:"ns1:srmCopyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCopyResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmCopyResponse_(struct soap *soap, struct ns1__srmCopyResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmCopyResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmCopyRequest(struct soap *soap, struct ns1__srmCopyRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmCopyRequest))
		soap_serialize_ns1__srmCopyRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmCopyRequest(struct soap *soap, const char *tag, int id, struct ns1__srmCopyRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmCopyRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmCopyRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmCopyRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmCopyRequest(struct soap *soap, const char *tag, struct ns1__srmCopyRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmCopyRequest **)soap_malloc(soap, sizeof(struct ns1__srmCopyRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmCopyRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCopyRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmCopyRequest, sizeof(struct ns1__srmCopyRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmCopyRequest(struct soap *soap, struct ns1__srmCopyRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmCopyRequest);
	if (soap_out_PointerTons1__srmCopyRequest(soap, tag?tag:"ns1:srmCopyRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCopyRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmCopyRequest(struct soap *soap, struct ns1__srmCopyRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmCopyRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmCopyResponse(struct soap *soap, struct ns1__srmCopyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmCopyResponse))
		soap_serialize_ns1__srmCopyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmCopyResponse(struct soap *soap, const char *tag, int id, struct ns1__srmCopyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmCopyResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmCopyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmCopyResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmCopyResponse(struct soap *soap, const char *tag, struct ns1__srmCopyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmCopyResponse **)soap_malloc(soap, sizeof(struct ns1__srmCopyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmCopyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCopyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmCopyResponse, sizeof(struct ns1__srmCopyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmCopyResponse(struct soap *soap, struct ns1__srmCopyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmCopyResponse);
	if (soap_out_PointerTons1__srmCopyResponse(soap, tag?tag:"ns1:srmCopyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCopyResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmCopyResponse(struct soap *soap, struct ns1__srmCopyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmCopyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfPutRequestResponse_(struct soap *soap, struct ns1__srmStatusOfPutRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse_))
		soap_serialize_ns1__srmStatusOfPutRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfPutRequestResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfPutRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfPutRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfPutRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfPutRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfPutRequestResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfPutRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfPutRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfPutRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse_, sizeof(struct ns1__srmStatusOfPutRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfPutRequestResponse_(struct soap *soap, struct ns1__srmStatusOfPutRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfPutRequestResponse_);
	if (soap_out_PointerTons1__srmStatusOfPutRequestResponse_(soap, tag?tag:"ns1:srmStatusOfPutRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfPutRequestResponse_(struct soap *soap, struct ns1__srmStatusOfPutRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfPutRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfPutRequestRequest(struct soap *soap, struct ns1__srmStatusOfPutRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfPutRequestRequest))
		soap_serialize_ns1__srmStatusOfPutRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfPutRequestRequest(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfPutRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfPutRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfPutRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequestRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfPutRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfPutRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfPutRequestRequest **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfPutRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfPutRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfPutRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfPutRequestRequest, sizeof(struct ns1__srmStatusOfPutRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfPutRequestRequest(struct soap *soap, struct ns1__srmStatusOfPutRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfPutRequestRequest);
	if (soap_out_PointerTons1__srmStatusOfPutRequestRequest(soap, tag?tag:"ns1:srmStatusOfPutRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequestRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfPutRequestRequest(struct soap *soap, struct ns1__srmStatusOfPutRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfPutRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfPutRequestResponse(struct soap *soap, struct ns1__srmStatusOfPutRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse))
		soap_serialize_ns1__srmStatusOfPutRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfPutRequestResponse(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfPutRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfPutRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequestResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfPutRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfPutRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfPutRequestResponse **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfPutRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfPutRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfPutRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfPutRequestResponse, sizeof(struct ns1__srmStatusOfPutRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfPutRequestResponse(struct soap *soap, struct ns1__srmStatusOfPutRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfPutRequestResponse);
	if (soap_out_PointerTons1__srmStatusOfPutRequestResponse(soap, tag?tag:"ns1:srmStatusOfPutRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfPutRequestResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfPutRequestResponse(struct soap *soap, struct ns1__srmStatusOfPutRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfPutRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPrepareToPutResponse_(struct soap *soap, struct ns1__srmPrepareToPutResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPrepareToPutResponse_))
		soap_serialize_ns1__srmPrepareToPutResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPrepareToPutResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmPrepareToPutResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPrepareToPutResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPrepareToPutResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPrepareToPutResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmPrepareToPutResponse_(struct soap *soap, const char *tag, struct ns1__srmPrepareToPutResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPrepareToPutResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmPrepareToPutResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPrepareToPutResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToPutResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPrepareToPutResponse_, sizeof(struct ns1__srmPrepareToPutResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPrepareToPutResponse_(struct soap *soap, struct ns1__srmPrepareToPutResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPrepareToPutResponse_);
	if (soap_out_PointerTons1__srmPrepareToPutResponse_(soap, tag?tag:"ns1:srmPrepareToPutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToPutResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmPrepareToPutResponse_(struct soap *soap, struct ns1__srmPrepareToPutResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPrepareToPutResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPrepareToPutRequest(struct soap *soap, struct ns1__srmPrepareToPutRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPrepareToPutRequest))
		soap_serialize_ns1__srmPrepareToPutRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPrepareToPutRequest(struct soap *soap, const char *tag, int id, struct ns1__srmPrepareToPutRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPrepareToPutRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPrepareToPutRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPrepareToPutRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmPrepareToPutRequest(struct soap *soap, const char *tag, struct ns1__srmPrepareToPutRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPrepareToPutRequest **)soap_malloc(soap, sizeof(struct ns1__srmPrepareToPutRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPrepareToPutRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToPutRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPrepareToPutRequest, sizeof(struct ns1__srmPrepareToPutRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPrepareToPutRequest(struct soap *soap, struct ns1__srmPrepareToPutRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPrepareToPutRequest);
	if (soap_out_PointerTons1__srmPrepareToPutRequest(soap, tag?tag:"ns1:srmPrepareToPutRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToPutRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmPrepareToPutRequest(struct soap *soap, struct ns1__srmPrepareToPutRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPrepareToPutRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPrepareToPutResponse(struct soap *soap, struct ns1__srmPrepareToPutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPrepareToPutResponse))
		soap_serialize_ns1__srmPrepareToPutResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPrepareToPutResponse(struct soap *soap, const char *tag, int id, struct ns1__srmPrepareToPutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPrepareToPutResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPrepareToPutResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPrepareToPutResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmPrepareToPutResponse(struct soap *soap, const char *tag, struct ns1__srmPrepareToPutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPrepareToPutResponse **)soap_malloc(soap, sizeof(struct ns1__srmPrepareToPutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPrepareToPutResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToPutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPrepareToPutResponse, sizeof(struct ns1__srmPrepareToPutResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPrepareToPutResponse(struct soap *soap, struct ns1__srmPrepareToPutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPrepareToPutResponse);
	if (soap_out_PointerTons1__srmPrepareToPutResponse(soap, tag?tag:"ns1:srmPrepareToPutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToPutResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmPrepareToPutResponse(struct soap *soap, struct ns1__srmPrepareToPutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPrepareToPutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse_))
		soap_serialize_ns1__srmStatusOfBringOnlineRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfBringOnlineRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfBringOnlineRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfBringOnlineRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfBringOnlineRequestResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfBringOnlineRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfBringOnlineRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfBringOnlineRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse_, sizeof(struct ns1__srmStatusOfBringOnlineRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfBringOnlineRequestResponse_);
	if (soap_out_PointerTons1__srmStatusOfBringOnlineRequestResponse_(soap, tag?tag:"ns1:srmStatusOfBringOnlineRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfBringOnlineRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfBringOnlineRequestRequest(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestRequest))
		soap_serialize_ns1__srmStatusOfBringOnlineRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfBringOnlineRequestRequest(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfBringOnlineRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfBringOnlineRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequestRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfBringOnlineRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfBringOnlineRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfBringOnlineRequestRequest **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfBringOnlineRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfBringOnlineRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfBringOnlineRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestRequest, sizeof(struct ns1__srmStatusOfBringOnlineRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfBringOnlineRequestRequest(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfBringOnlineRequestRequest);
	if (soap_out_PointerTons1__srmStatusOfBringOnlineRequestRequest(soap, tag?tag:"ns1:srmStatusOfBringOnlineRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequestRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfBringOnlineRequestRequest(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfBringOnlineRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfBringOnlineRequestResponse(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse))
		soap_serialize_ns1__srmStatusOfBringOnlineRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfBringOnlineRequestResponse(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfBringOnlineRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfBringOnlineRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequestResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfBringOnlineRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfBringOnlineRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfBringOnlineRequestResponse **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfBringOnlineRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfBringOnlineRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfBringOnlineRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfBringOnlineRequestResponse, sizeof(struct ns1__srmStatusOfBringOnlineRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfBringOnlineRequestResponse(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfBringOnlineRequestResponse);
	if (soap_out_PointerTons1__srmStatusOfBringOnlineRequestResponse(soap, tag?tag:"ns1:srmStatusOfBringOnlineRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfBringOnlineRequestResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfBringOnlineRequestResponse(struct soap *soap, struct ns1__srmStatusOfBringOnlineRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfBringOnlineRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmBringOnlineResponse_(struct soap *soap, struct ns1__srmBringOnlineResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmBringOnlineResponse_))
		soap_serialize_ns1__srmBringOnlineResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmBringOnlineResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmBringOnlineResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmBringOnlineResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmBringOnlineResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmBringOnlineResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmBringOnlineResponse_(struct soap *soap, const char *tag, struct ns1__srmBringOnlineResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmBringOnlineResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmBringOnlineResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmBringOnlineResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmBringOnlineResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmBringOnlineResponse_, sizeof(struct ns1__srmBringOnlineResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmBringOnlineResponse_(struct soap *soap, struct ns1__srmBringOnlineResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmBringOnlineResponse_);
	if (soap_out_PointerTons1__srmBringOnlineResponse_(soap, tag?tag:"ns1:srmBringOnlineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmBringOnlineResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmBringOnlineResponse_(struct soap *soap, struct ns1__srmBringOnlineResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmBringOnlineResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmBringOnlineRequest(struct soap *soap, struct ns1__srmBringOnlineRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmBringOnlineRequest))
		soap_serialize_ns1__srmBringOnlineRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmBringOnlineRequest(struct soap *soap, const char *tag, int id, struct ns1__srmBringOnlineRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmBringOnlineRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmBringOnlineRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmBringOnlineRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmBringOnlineRequest(struct soap *soap, const char *tag, struct ns1__srmBringOnlineRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmBringOnlineRequest **)soap_malloc(soap, sizeof(struct ns1__srmBringOnlineRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmBringOnlineRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmBringOnlineRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmBringOnlineRequest, sizeof(struct ns1__srmBringOnlineRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmBringOnlineRequest(struct soap *soap, struct ns1__srmBringOnlineRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmBringOnlineRequest);
	if (soap_out_PointerTons1__srmBringOnlineRequest(soap, tag?tag:"ns1:srmBringOnlineRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmBringOnlineRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmBringOnlineRequest(struct soap *soap, struct ns1__srmBringOnlineRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmBringOnlineRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmBringOnlineResponse(struct soap *soap, struct ns1__srmBringOnlineResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmBringOnlineResponse))
		soap_serialize_ns1__srmBringOnlineResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmBringOnlineResponse(struct soap *soap, const char *tag, int id, struct ns1__srmBringOnlineResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmBringOnlineResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmBringOnlineResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmBringOnlineResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmBringOnlineResponse(struct soap *soap, const char *tag, struct ns1__srmBringOnlineResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmBringOnlineResponse **)soap_malloc(soap, sizeof(struct ns1__srmBringOnlineResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmBringOnlineResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmBringOnlineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmBringOnlineResponse, sizeof(struct ns1__srmBringOnlineResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmBringOnlineResponse(struct soap *soap, struct ns1__srmBringOnlineResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmBringOnlineResponse);
	if (soap_out_PointerTons1__srmBringOnlineResponse(soap, tag?tag:"ns1:srmBringOnlineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmBringOnlineResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmBringOnlineResponse(struct soap *soap, struct ns1__srmBringOnlineResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmBringOnlineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfGetRequestResponse_(struct soap *soap, struct ns1__srmStatusOfGetRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse_))
		soap_serialize_ns1__srmStatusOfGetRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfGetRequestResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfGetRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfGetRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfGetRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfGetRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfGetRequestResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfGetRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfGetRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfGetRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse_, sizeof(struct ns1__srmStatusOfGetRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfGetRequestResponse_(struct soap *soap, struct ns1__srmStatusOfGetRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfGetRequestResponse_);
	if (soap_out_PointerTons1__srmStatusOfGetRequestResponse_(soap, tag?tag:"ns1:srmStatusOfGetRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfGetRequestResponse_(struct soap *soap, struct ns1__srmStatusOfGetRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfGetRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfGetRequestRequest(struct soap *soap, struct ns1__srmStatusOfGetRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfGetRequestRequest))
		soap_serialize_ns1__srmStatusOfGetRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfGetRequestRequest(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfGetRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfGetRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfGetRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequestRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfGetRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfGetRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfGetRequestRequest **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfGetRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfGetRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfGetRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfGetRequestRequest, sizeof(struct ns1__srmStatusOfGetRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfGetRequestRequest(struct soap *soap, struct ns1__srmStatusOfGetRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfGetRequestRequest);
	if (soap_out_PointerTons1__srmStatusOfGetRequestRequest(soap, tag?tag:"ns1:srmStatusOfGetRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequestRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfGetRequestRequest(struct soap *soap, struct ns1__srmStatusOfGetRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfGetRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfGetRequestResponse(struct soap *soap, struct ns1__srmStatusOfGetRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse))
		soap_serialize_ns1__srmStatusOfGetRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfGetRequestResponse(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfGetRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfGetRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequestResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfGetRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfGetRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfGetRequestResponse **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfGetRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfGetRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfGetRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfGetRequestResponse, sizeof(struct ns1__srmStatusOfGetRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfGetRequestResponse(struct soap *soap, struct ns1__srmStatusOfGetRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfGetRequestResponse);
	if (soap_out_PointerTons1__srmStatusOfGetRequestResponse(soap, tag?tag:"ns1:srmStatusOfGetRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfGetRequestResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfGetRequestResponse(struct soap *soap, struct ns1__srmStatusOfGetRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfGetRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPrepareToGetResponse_(struct soap *soap, struct ns1__srmPrepareToGetResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPrepareToGetResponse_))
		soap_serialize_ns1__srmPrepareToGetResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPrepareToGetResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmPrepareToGetResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPrepareToGetResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPrepareToGetResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPrepareToGetResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmPrepareToGetResponse_(struct soap *soap, const char *tag, struct ns1__srmPrepareToGetResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPrepareToGetResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmPrepareToGetResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPrepareToGetResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToGetResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPrepareToGetResponse_, sizeof(struct ns1__srmPrepareToGetResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPrepareToGetResponse_(struct soap *soap, struct ns1__srmPrepareToGetResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPrepareToGetResponse_);
	if (soap_out_PointerTons1__srmPrepareToGetResponse_(soap, tag?tag:"ns1:srmPrepareToGetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToGetResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmPrepareToGetResponse_(struct soap *soap, struct ns1__srmPrepareToGetResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPrepareToGetResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPrepareToGetRequest(struct soap *soap, struct ns1__srmPrepareToGetRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPrepareToGetRequest))
		soap_serialize_ns1__srmPrepareToGetRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPrepareToGetRequest(struct soap *soap, const char *tag, int id, struct ns1__srmPrepareToGetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPrepareToGetRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPrepareToGetRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPrepareToGetRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmPrepareToGetRequest(struct soap *soap, const char *tag, struct ns1__srmPrepareToGetRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPrepareToGetRequest **)soap_malloc(soap, sizeof(struct ns1__srmPrepareToGetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPrepareToGetRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToGetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPrepareToGetRequest, sizeof(struct ns1__srmPrepareToGetRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPrepareToGetRequest(struct soap *soap, struct ns1__srmPrepareToGetRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPrepareToGetRequest);
	if (soap_out_PointerTons1__srmPrepareToGetRequest(soap, tag?tag:"ns1:srmPrepareToGetRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToGetRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmPrepareToGetRequest(struct soap *soap, struct ns1__srmPrepareToGetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPrepareToGetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPrepareToGetResponse(struct soap *soap, struct ns1__srmPrepareToGetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPrepareToGetResponse))
		soap_serialize_ns1__srmPrepareToGetResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPrepareToGetResponse(struct soap *soap, const char *tag, int id, struct ns1__srmPrepareToGetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPrepareToGetResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPrepareToGetResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPrepareToGetResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmPrepareToGetResponse(struct soap *soap, const char *tag, struct ns1__srmPrepareToGetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPrepareToGetResponse **)soap_malloc(soap, sizeof(struct ns1__srmPrepareToGetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPrepareToGetResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPrepareToGetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPrepareToGetResponse, sizeof(struct ns1__srmPrepareToGetResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPrepareToGetResponse(struct soap *soap, struct ns1__srmPrepareToGetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPrepareToGetResponse);
	if (soap_out_PointerTons1__srmPrepareToGetResponse(soap, tag?tag:"ns1:srmPrepareToGetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPrepareToGetResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmPrepareToGetResponse(struct soap *soap, struct ns1__srmPrepareToGetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPrepareToGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmMvResponse_(struct soap *soap, struct ns1__srmMvResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmMvResponse_))
		soap_serialize_ns1__srmMvResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmMvResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmMvResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmMvResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmMvResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmMvResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmMvResponse_(struct soap *soap, const char *tag, struct ns1__srmMvResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmMvResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmMvResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmMvResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMvResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmMvResponse_, sizeof(struct ns1__srmMvResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmMvResponse_(struct soap *soap, struct ns1__srmMvResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmMvResponse_);
	if (soap_out_PointerTons1__srmMvResponse_(soap, tag?tag:"ns1:srmMvResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMvResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmMvResponse_(struct soap *soap, struct ns1__srmMvResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmMvResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmMvRequest(struct soap *soap, struct ns1__srmMvRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmMvRequest))
		soap_serialize_ns1__srmMvRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmMvRequest(struct soap *soap, const char *tag, int id, struct ns1__srmMvRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmMvRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmMvRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmMvRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmMvRequest(struct soap *soap, const char *tag, struct ns1__srmMvRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmMvRequest **)soap_malloc(soap, sizeof(struct ns1__srmMvRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmMvRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMvRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmMvRequest, sizeof(struct ns1__srmMvRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmMvRequest(struct soap *soap, struct ns1__srmMvRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmMvRequest);
	if (soap_out_PointerTons1__srmMvRequest(soap, tag?tag:"ns1:srmMvRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMvRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmMvRequest(struct soap *soap, struct ns1__srmMvRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmMvRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmMvResponse(struct soap *soap, struct ns1__srmMvResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmMvResponse))
		soap_serialize_ns1__srmMvResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmMvResponse(struct soap *soap, const char *tag, int id, struct ns1__srmMvResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmMvResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmMvResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmMvResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmMvResponse(struct soap *soap, const char *tag, struct ns1__srmMvResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmMvResponse **)soap_malloc(soap, sizeof(struct ns1__srmMvResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmMvResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMvResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmMvResponse, sizeof(struct ns1__srmMvResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmMvResponse(struct soap *soap, struct ns1__srmMvResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmMvResponse);
	if (soap_out_PointerTons1__srmMvResponse(soap, tag?tag:"ns1:srmMvResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMvResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmMvResponse(struct soap *soap, struct ns1__srmMvResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmMvResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfLsRequestResponse_(struct soap *soap, struct ns1__srmStatusOfLsRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse_))
		soap_serialize_ns1__srmStatusOfLsRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfLsRequestResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfLsRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfLsRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfLsRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfLsRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfLsRequestResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfLsRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfLsRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfLsRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse_, sizeof(struct ns1__srmStatusOfLsRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfLsRequestResponse_(struct soap *soap, struct ns1__srmStatusOfLsRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfLsRequestResponse_);
	if (soap_out_PointerTons1__srmStatusOfLsRequestResponse_(soap, tag?tag:"ns1:srmStatusOfLsRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfLsRequestResponse_(struct soap *soap, struct ns1__srmStatusOfLsRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfLsRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfLsRequestRequest(struct soap *soap, struct ns1__srmStatusOfLsRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfLsRequestRequest))
		soap_serialize_ns1__srmStatusOfLsRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfLsRequestRequest(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfLsRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfLsRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfLsRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequestRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfLsRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfLsRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfLsRequestRequest **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfLsRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfLsRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfLsRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfLsRequestRequest, sizeof(struct ns1__srmStatusOfLsRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfLsRequestRequest(struct soap *soap, struct ns1__srmStatusOfLsRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfLsRequestRequest);
	if (soap_out_PointerTons1__srmStatusOfLsRequestRequest(soap, tag?tag:"ns1:srmStatusOfLsRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequestRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfLsRequestRequest(struct soap *soap, struct ns1__srmStatusOfLsRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfLsRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfLsRequestResponse(struct soap *soap, struct ns1__srmStatusOfLsRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse))
		soap_serialize_ns1__srmStatusOfLsRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfLsRequestResponse(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfLsRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfLsRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequestResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfLsRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfLsRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfLsRequestResponse **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfLsRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfLsRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfLsRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfLsRequestResponse, sizeof(struct ns1__srmStatusOfLsRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfLsRequestResponse(struct soap *soap, struct ns1__srmStatusOfLsRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfLsRequestResponse);
	if (soap_out_PointerTons1__srmStatusOfLsRequestResponse(soap, tag?tag:"ns1:srmStatusOfLsRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfLsRequestResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfLsRequestResponse(struct soap *soap, struct ns1__srmStatusOfLsRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfLsRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmLsResponse_(struct soap *soap, struct ns1__srmLsResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmLsResponse_))
		soap_serialize_ns1__srmLsResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmLsResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmLsResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmLsResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmLsResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmLsResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmLsResponse_(struct soap *soap, const char *tag, struct ns1__srmLsResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmLsResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmLsResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmLsResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmLsResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmLsResponse_, sizeof(struct ns1__srmLsResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmLsResponse_(struct soap *soap, struct ns1__srmLsResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmLsResponse_);
	if (soap_out_PointerTons1__srmLsResponse_(soap, tag?tag:"ns1:srmLsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmLsResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmLsResponse_(struct soap *soap, struct ns1__srmLsResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmLsResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmLsRequest(struct soap *soap, struct ns1__srmLsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmLsRequest))
		soap_serialize_ns1__srmLsRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmLsRequest(struct soap *soap, const char *tag, int id, struct ns1__srmLsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmLsRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmLsRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmLsRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmLsRequest(struct soap *soap, const char *tag, struct ns1__srmLsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmLsRequest **)soap_malloc(soap, sizeof(struct ns1__srmLsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmLsRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmLsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmLsRequest, sizeof(struct ns1__srmLsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmLsRequest(struct soap *soap, struct ns1__srmLsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmLsRequest);
	if (soap_out_PointerTons1__srmLsRequest(soap, tag?tag:"ns1:srmLsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmLsRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmLsRequest(struct soap *soap, struct ns1__srmLsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmLsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmLsResponse(struct soap *soap, struct ns1__srmLsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmLsResponse))
		soap_serialize_ns1__srmLsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmLsResponse(struct soap *soap, const char *tag, int id, struct ns1__srmLsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmLsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmLsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmLsResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmLsResponse(struct soap *soap, const char *tag, struct ns1__srmLsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmLsResponse **)soap_malloc(soap, sizeof(struct ns1__srmLsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmLsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmLsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmLsResponse, sizeof(struct ns1__srmLsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmLsResponse(struct soap *soap, struct ns1__srmLsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmLsResponse);
	if (soap_out_PointerTons1__srmLsResponse(soap, tag?tag:"ns1:srmLsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmLsResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmLsResponse(struct soap *soap, struct ns1__srmLsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmLsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmRmResponse_(struct soap *soap, struct ns1__srmRmResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmRmResponse_))
		soap_serialize_ns1__srmRmResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmRmResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmRmResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmRmResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmRmResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmRmResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmRmResponse_(struct soap *soap, const char *tag, struct ns1__srmRmResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmRmResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmRmResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmRmResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmRmResponse_, sizeof(struct ns1__srmRmResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmRmResponse_(struct soap *soap, struct ns1__srmRmResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmRmResponse_);
	if (soap_out_PointerTons1__srmRmResponse_(soap, tag?tag:"ns1:srmRmResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmRmResponse_(struct soap *soap, struct ns1__srmRmResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmRmResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmRmRequest(struct soap *soap, struct ns1__srmRmRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmRmRequest))
		soap_serialize_ns1__srmRmRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmRmRequest(struct soap *soap, const char *tag, int id, struct ns1__srmRmRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmRmRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmRmRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmRmRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmRmRequest(struct soap *soap, const char *tag, struct ns1__srmRmRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmRmRequest **)soap_malloc(soap, sizeof(struct ns1__srmRmRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmRmRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmRmRequest, sizeof(struct ns1__srmRmRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmRmRequest(struct soap *soap, struct ns1__srmRmRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmRmRequest);
	if (soap_out_PointerTons1__srmRmRequest(soap, tag?tag:"ns1:srmRmRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmRmRequest(struct soap *soap, struct ns1__srmRmRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmRmRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmRmResponse(struct soap *soap, struct ns1__srmRmResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmRmResponse))
		soap_serialize_ns1__srmRmResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmRmResponse(struct soap *soap, const char *tag, int id, struct ns1__srmRmResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmRmResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmRmResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmRmResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmRmResponse(struct soap *soap, const char *tag, struct ns1__srmRmResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmRmResponse **)soap_malloc(soap, sizeof(struct ns1__srmRmResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmRmResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmRmResponse, sizeof(struct ns1__srmRmResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmRmResponse(struct soap *soap, struct ns1__srmRmResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmRmResponse);
	if (soap_out_PointerTons1__srmRmResponse(soap, tag?tag:"ns1:srmRmResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmRmResponse(struct soap *soap, struct ns1__srmRmResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmRmResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmRmdirResponse_(struct soap *soap, struct ns1__srmRmdirResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmRmdirResponse_))
		soap_serialize_ns1__srmRmdirResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmRmdirResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmRmdirResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmRmdirResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmRmdirResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmRmdirResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmRmdirResponse_(struct soap *soap, const char *tag, struct ns1__srmRmdirResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmRmdirResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmRmdirResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmRmdirResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmdirResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmRmdirResponse_, sizeof(struct ns1__srmRmdirResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmRmdirResponse_(struct soap *soap, struct ns1__srmRmdirResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmRmdirResponse_);
	if (soap_out_PointerTons1__srmRmdirResponse_(soap, tag?tag:"ns1:srmRmdirResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmdirResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmRmdirResponse_(struct soap *soap, struct ns1__srmRmdirResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmRmdirResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmRmdirRequest(struct soap *soap, struct ns1__srmRmdirRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmRmdirRequest))
		soap_serialize_ns1__srmRmdirRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmRmdirRequest(struct soap *soap, const char *tag, int id, struct ns1__srmRmdirRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmRmdirRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmRmdirRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmRmdirRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmRmdirRequest(struct soap *soap, const char *tag, struct ns1__srmRmdirRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmRmdirRequest **)soap_malloc(soap, sizeof(struct ns1__srmRmdirRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmRmdirRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmdirRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmRmdirRequest, sizeof(struct ns1__srmRmdirRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmRmdirRequest(struct soap *soap, struct ns1__srmRmdirRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmRmdirRequest);
	if (soap_out_PointerTons1__srmRmdirRequest(soap, tag?tag:"ns1:srmRmdirRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmdirRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmRmdirRequest(struct soap *soap, struct ns1__srmRmdirRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmRmdirRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmRmdirResponse(struct soap *soap, struct ns1__srmRmdirResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmRmdirResponse))
		soap_serialize_ns1__srmRmdirResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmRmdirResponse(struct soap *soap, const char *tag, int id, struct ns1__srmRmdirResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmRmdirResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmRmdirResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmRmdirResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmRmdirResponse(struct soap *soap, const char *tag, struct ns1__srmRmdirResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmRmdirResponse **)soap_malloc(soap, sizeof(struct ns1__srmRmdirResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmRmdirResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmRmdirResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmRmdirResponse, sizeof(struct ns1__srmRmdirResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmRmdirResponse(struct soap *soap, struct ns1__srmRmdirResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmRmdirResponse);
	if (soap_out_PointerTons1__srmRmdirResponse(soap, tag?tag:"ns1:srmRmdirResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmRmdirResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmRmdirResponse(struct soap *soap, struct ns1__srmRmdirResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmRmdirResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmMkdirResponse_(struct soap *soap, struct ns1__srmMkdirResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmMkdirResponse_))
		soap_serialize_ns1__srmMkdirResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmMkdirResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmMkdirResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmMkdirResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmMkdirResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmMkdirResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmMkdirResponse_(struct soap *soap, const char *tag, struct ns1__srmMkdirResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmMkdirResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmMkdirResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmMkdirResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMkdirResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmMkdirResponse_, sizeof(struct ns1__srmMkdirResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmMkdirResponse_(struct soap *soap, struct ns1__srmMkdirResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmMkdirResponse_);
	if (soap_out_PointerTons1__srmMkdirResponse_(soap, tag?tag:"ns1:srmMkdirResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMkdirResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmMkdirResponse_(struct soap *soap, struct ns1__srmMkdirResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmMkdirResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmMkdirRequest(struct soap *soap, struct ns1__srmMkdirRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmMkdirRequest))
		soap_serialize_ns1__srmMkdirRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmMkdirRequest(struct soap *soap, const char *tag, int id, struct ns1__srmMkdirRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmMkdirRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmMkdirRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmMkdirRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmMkdirRequest(struct soap *soap, const char *tag, struct ns1__srmMkdirRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmMkdirRequest **)soap_malloc(soap, sizeof(struct ns1__srmMkdirRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmMkdirRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMkdirRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmMkdirRequest, sizeof(struct ns1__srmMkdirRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmMkdirRequest(struct soap *soap, struct ns1__srmMkdirRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmMkdirRequest);
	if (soap_out_PointerTons1__srmMkdirRequest(soap, tag?tag:"ns1:srmMkdirRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMkdirRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmMkdirRequest(struct soap *soap, struct ns1__srmMkdirRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmMkdirRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmMkdirResponse(struct soap *soap, struct ns1__srmMkdirResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmMkdirResponse))
		soap_serialize_ns1__srmMkdirResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmMkdirResponse(struct soap *soap, const char *tag, int id, struct ns1__srmMkdirResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmMkdirResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmMkdirResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmMkdirResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmMkdirResponse(struct soap *soap, const char *tag, struct ns1__srmMkdirResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmMkdirResponse **)soap_malloc(soap, sizeof(struct ns1__srmMkdirResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmMkdirResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmMkdirResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmMkdirResponse, sizeof(struct ns1__srmMkdirResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmMkdirResponse(struct soap *soap, struct ns1__srmMkdirResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmMkdirResponse);
	if (soap_out_PointerTons1__srmMkdirResponse(soap, tag?tag:"ns1:srmMkdirResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmMkdirResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmMkdirResponse(struct soap *soap, struct ns1__srmMkdirResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmMkdirResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetPermissionResponse_(struct soap *soap, struct ns1__srmGetPermissionResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetPermissionResponse_))
		soap_serialize_ns1__srmGetPermissionResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetPermissionResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmGetPermissionResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetPermissionResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetPermissionResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetPermissionResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmGetPermissionResponse_(struct soap *soap, const char *tag, struct ns1__srmGetPermissionResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetPermissionResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmGetPermissionResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetPermissionResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetPermissionResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetPermissionResponse_, sizeof(struct ns1__srmGetPermissionResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetPermissionResponse_(struct soap *soap, struct ns1__srmGetPermissionResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetPermissionResponse_);
	if (soap_out_PointerTons1__srmGetPermissionResponse_(soap, tag?tag:"ns1:srmGetPermissionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetPermissionResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmGetPermissionResponse_(struct soap *soap, struct ns1__srmGetPermissionResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetPermissionResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetPermissionRequest(struct soap *soap, struct ns1__srmGetPermissionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetPermissionRequest))
		soap_serialize_ns1__srmGetPermissionRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetPermissionRequest(struct soap *soap, const char *tag, int id, struct ns1__srmGetPermissionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetPermissionRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetPermissionRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetPermissionRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmGetPermissionRequest(struct soap *soap, const char *tag, struct ns1__srmGetPermissionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetPermissionRequest **)soap_malloc(soap, sizeof(struct ns1__srmGetPermissionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetPermissionRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetPermissionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetPermissionRequest, sizeof(struct ns1__srmGetPermissionRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetPermissionRequest(struct soap *soap, struct ns1__srmGetPermissionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetPermissionRequest);
	if (soap_out_PointerTons1__srmGetPermissionRequest(soap, tag?tag:"ns1:srmGetPermissionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetPermissionRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmGetPermissionRequest(struct soap *soap, struct ns1__srmGetPermissionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetPermissionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetPermissionResponse(struct soap *soap, struct ns1__srmGetPermissionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetPermissionResponse))
		soap_serialize_ns1__srmGetPermissionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetPermissionResponse(struct soap *soap, const char *tag, int id, struct ns1__srmGetPermissionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetPermissionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetPermissionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetPermissionResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmGetPermissionResponse(struct soap *soap, const char *tag, struct ns1__srmGetPermissionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetPermissionResponse **)soap_malloc(soap, sizeof(struct ns1__srmGetPermissionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetPermissionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetPermissionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetPermissionResponse, sizeof(struct ns1__srmGetPermissionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetPermissionResponse(struct soap *soap, struct ns1__srmGetPermissionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetPermissionResponse);
	if (soap_out_PointerTons1__srmGetPermissionResponse(soap, tag?tag:"ns1:srmGetPermissionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetPermissionResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmGetPermissionResponse(struct soap *soap, struct ns1__srmGetPermissionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmCheckPermissionResponse_(struct soap *soap, struct ns1__srmCheckPermissionResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmCheckPermissionResponse_))
		soap_serialize_ns1__srmCheckPermissionResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmCheckPermissionResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmCheckPermissionResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmCheckPermissionResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmCheckPermissionResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmCheckPermissionResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmCheckPermissionResponse_(struct soap *soap, const char *tag, struct ns1__srmCheckPermissionResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmCheckPermissionResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmCheckPermissionResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmCheckPermissionResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCheckPermissionResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmCheckPermissionResponse_, sizeof(struct ns1__srmCheckPermissionResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmCheckPermissionResponse_(struct soap *soap, struct ns1__srmCheckPermissionResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmCheckPermissionResponse_);
	if (soap_out_PointerTons1__srmCheckPermissionResponse_(soap, tag?tag:"ns1:srmCheckPermissionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCheckPermissionResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmCheckPermissionResponse_(struct soap *soap, struct ns1__srmCheckPermissionResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmCheckPermissionResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmCheckPermissionRequest(struct soap *soap, struct ns1__srmCheckPermissionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmCheckPermissionRequest))
		soap_serialize_ns1__srmCheckPermissionRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmCheckPermissionRequest(struct soap *soap, const char *tag, int id, struct ns1__srmCheckPermissionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmCheckPermissionRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmCheckPermissionRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmCheckPermissionRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmCheckPermissionRequest(struct soap *soap, const char *tag, struct ns1__srmCheckPermissionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmCheckPermissionRequest **)soap_malloc(soap, sizeof(struct ns1__srmCheckPermissionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmCheckPermissionRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCheckPermissionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmCheckPermissionRequest, sizeof(struct ns1__srmCheckPermissionRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmCheckPermissionRequest(struct soap *soap, struct ns1__srmCheckPermissionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmCheckPermissionRequest);
	if (soap_out_PointerTons1__srmCheckPermissionRequest(soap, tag?tag:"ns1:srmCheckPermissionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCheckPermissionRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmCheckPermissionRequest(struct soap *soap, struct ns1__srmCheckPermissionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmCheckPermissionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmCheckPermissionResponse(struct soap *soap, struct ns1__srmCheckPermissionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmCheckPermissionResponse))
		soap_serialize_ns1__srmCheckPermissionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmCheckPermissionResponse(struct soap *soap, const char *tag, int id, struct ns1__srmCheckPermissionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmCheckPermissionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmCheckPermissionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmCheckPermissionResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmCheckPermissionResponse(struct soap *soap, const char *tag, struct ns1__srmCheckPermissionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmCheckPermissionResponse **)soap_malloc(soap, sizeof(struct ns1__srmCheckPermissionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmCheckPermissionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmCheckPermissionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmCheckPermissionResponse, sizeof(struct ns1__srmCheckPermissionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmCheckPermissionResponse(struct soap *soap, struct ns1__srmCheckPermissionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmCheckPermissionResponse);
	if (soap_out_PointerTons1__srmCheckPermissionResponse(soap, tag?tag:"ns1:srmCheckPermissionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmCheckPermissionResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmCheckPermissionResponse(struct soap *soap, struct ns1__srmCheckPermissionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmCheckPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmSetPermissionResponse_(struct soap *soap, struct ns1__srmSetPermissionResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmSetPermissionResponse_))
		soap_serialize_ns1__srmSetPermissionResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmSetPermissionResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmSetPermissionResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmSetPermissionResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmSetPermissionResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmSetPermissionResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmSetPermissionResponse_(struct soap *soap, const char *tag, struct ns1__srmSetPermissionResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmSetPermissionResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmSetPermissionResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmSetPermissionResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSetPermissionResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmSetPermissionResponse_, sizeof(struct ns1__srmSetPermissionResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmSetPermissionResponse_(struct soap *soap, struct ns1__srmSetPermissionResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmSetPermissionResponse_);
	if (soap_out_PointerTons1__srmSetPermissionResponse_(soap, tag?tag:"ns1:srmSetPermissionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSetPermissionResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmSetPermissionResponse_(struct soap *soap, struct ns1__srmSetPermissionResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmSetPermissionResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmSetPermissionRequest(struct soap *soap, struct ns1__srmSetPermissionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmSetPermissionRequest))
		soap_serialize_ns1__srmSetPermissionRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmSetPermissionRequest(struct soap *soap, const char *tag, int id, struct ns1__srmSetPermissionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmSetPermissionRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmSetPermissionRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmSetPermissionRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmSetPermissionRequest(struct soap *soap, const char *tag, struct ns1__srmSetPermissionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmSetPermissionRequest **)soap_malloc(soap, sizeof(struct ns1__srmSetPermissionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmSetPermissionRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSetPermissionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmSetPermissionRequest, sizeof(struct ns1__srmSetPermissionRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmSetPermissionRequest(struct soap *soap, struct ns1__srmSetPermissionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmSetPermissionRequest);
	if (soap_out_PointerTons1__srmSetPermissionRequest(soap, tag?tag:"ns1:srmSetPermissionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSetPermissionRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmSetPermissionRequest(struct soap *soap, struct ns1__srmSetPermissionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmSetPermissionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmSetPermissionResponse(struct soap *soap, struct ns1__srmSetPermissionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmSetPermissionResponse))
		soap_serialize_ns1__srmSetPermissionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmSetPermissionResponse(struct soap *soap, const char *tag, int id, struct ns1__srmSetPermissionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmSetPermissionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmSetPermissionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmSetPermissionResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmSetPermissionResponse(struct soap *soap, const char *tag, struct ns1__srmSetPermissionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmSetPermissionResponse **)soap_malloc(soap, sizeof(struct ns1__srmSetPermissionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmSetPermissionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmSetPermissionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmSetPermissionResponse, sizeof(struct ns1__srmSetPermissionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmSetPermissionResponse(struct soap *soap, struct ns1__srmSetPermissionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmSetPermissionResponse);
	if (soap_out_PointerTons1__srmSetPermissionResponse(soap, tag?tag:"ns1:srmSetPermissionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmSetPermissionResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmSetPermissionResponse(struct soap *soap, struct ns1__srmSetPermissionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmSetPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetSpaceTokensResponse_(struct soap *soap, struct ns1__srmGetSpaceTokensResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetSpaceTokensResponse_))
		soap_serialize_ns1__srmGetSpaceTokensResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetSpaceTokensResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmGetSpaceTokensResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetSpaceTokensResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetSpaceTokensResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokensResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmGetSpaceTokensResponse_(struct soap *soap, const char *tag, struct ns1__srmGetSpaceTokensResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetSpaceTokensResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmGetSpaceTokensResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetSpaceTokensResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceTokensResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetSpaceTokensResponse_, sizeof(struct ns1__srmGetSpaceTokensResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetSpaceTokensResponse_(struct soap *soap, struct ns1__srmGetSpaceTokensResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetSpaceTokensResponse_);
	if (soap_out_PointerTons1__srmGetSpaceTokensResponse_(soap, tag?tag:"ns1:srmGetSpaceTokensResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokensResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmGetSpaceTokensResponse_(struct soap *soap, struct ns1__srmGetSpaceTokensResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetSpaceTokensResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetSpaceTokensRequest(struct soap *soap, struct ns1__srmGetSpaceTokensRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetSpaceTokensRequest))
		soap_serialize_ns1__srmGetSpaceTokensRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetSpaceTokensRequest(struct soap *soap, const char *tag, int id, struct ns1__srmGetSpaceTokensRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetSpaceTokensRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetSpaceTokensRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokensRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmGetSpaceTokensRequest(struct soap *soap, const char *tag, struct ns1__srmGetSpaceTokensRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetSpaceTokensRequest **)soap_malloc(soap, sizeof(struct ns1__srmGetSpaceTokensRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetSpaceTokensRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceTokensRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetSpaceTokensRequest, sizeof(struct ns1__srmGetSpaceTokensRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetSpaceTokensRequest(struct soap *soap, struct ns1__srmGetSpaceTokensRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetSpaceTokensRequest);
	if (soap_out_PointerTons1__srmGetSpaceTokensRequest(soap, tag?tag:"ns1:srmGetSpaceTokensRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokensRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmGetSpaceTokensRequest(struct soap *soap, struct ns1__srmGetSpaceTokensRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetSpaceTokensRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetSpaceTokensResponse(struct soap *soap, struct ns1__srmGetSpaceTokensResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetSpaceTokensResponse))
		soap_serialize_ns1__srmGetSpaceTokensResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetSpaceTokensResponse(struct soap *soap, const char *tag, int id, struct ns1__srmGetSpaceTokensResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetSpaceTokensResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetSpaceTokensResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokensResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmGetSpaceTokensResponse(struct soap *soap, const char *tag, struct ns1__srmGetSpaceTokensResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetSpaceTokensResponse **)soap_malloc(soap, sizeof(struct ns1__srmGetSpaceTokensResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetSpaceTokensResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceTokensResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetSpaceTokensResponse, sizeof(struct ns1__srmGetSpaceTokensResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetSpaceTokensResponse(struct soap *soap, struct ns1__srmGetSpaceTokensResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetSpaceTokensResponse);
	if (soap_out_PointerTons1__srmGetSpaceTokensResponse(soap, tag?tag:"ns1:srmGetSpaceTokensResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceTokensResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmGetSpaceTokensResponse(struct soap *soap, struct ns1__srmGetSpaceTokensResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetSpaceTokensResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPurgeFromSpaceResponse_(struct soap *soap, struct ns1__srmPurgeFromSpaceResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse_))
		soap_serialize_ns1__srmPurgeFromSpaceResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPurgeFromSpaceResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmPurgeFromSpaceResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPurgeFromSpaceResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpaceResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmPurgeFromSpaceResponse_(struct soap *soap, const char *tag, struct ns1__srmPurgeFromSpaceResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPurgeFromSpaceResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmPurgeFromSpaceResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPurgeFromSpaceResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPurgeFromSpaceResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse_, sizeof(struct ns1__srmPurgeFromSpaceResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPurgeFromSpaceResponse_(struct soap *soap, struct ns1__srmPurgeFromSpaceResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPurgeFromSpaceResponse_);
	if (soap_out_PointerTons1__srmPurgeFromSpaceResponse_(soap, tag?tag:"ns1:srmPurgeFromSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpaceResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmPurgeFromSpaceResponse_(struct soap *soap, struct ns1__srmPurgeFromSpaceResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPurgeFromSpaceResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPurgeFromSpaceRequest(struct soap *soap, struct ns1__srmPurgeFromSpaceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPurgeFromSpaceRequest))
		soap_serialize_ns1__srmPurgeFromSpaceRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPurgeFromSpaceRequest(struct soap *soap, const char *tag, int id, struct ns1__srmPurgeFromSpaceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPurgeFromSpaceRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPurgeFromSpaceRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpaceRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmPurgeFromSpaceRequest(struct soap *soap, const char *tag, struct ns1__srmPurgeFromSpaceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPurgeFromSpaceRequest **)soap_malloc(soap, sizeof(struct ns1__srmPurgeFromSpaceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPurgeFromSpaceRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPurgeFromSpaceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPurgeFromSpaceRequest, sizeof(struct ns1__srmPurgeFromSpaceRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPurgeFromSpaceRequest(struct soap *soap, struct ns1__srmPurgeFromSpaceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPurgeFromSpaceRequest);
	if (soap_out_PointerTons1__srmPurgeFromSpaceRequest(soap, tag?tag:"ns1:srmPurgeFromSpaceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpaceRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmPurgeFromSpaceRequest(struct soap *soap, struct ns1__srmPurgeFromSpaceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPurgeFromSpaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmPurgeFromSpaceResponse(struct soap *soap, struct ns1__srmPurgeFromSpaceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse))
		soap_serialize_ns1__srmPurgeFromSpaceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmPurgeFromSpaceResponse(struct soap *soap, const char *tag, int id, struct ns1__srmPurgeFromSpaceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmPurgeFromSpaceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpaceResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmPurgeFromSpaceResponse(struct soap *soap, const char *tag, struct ns1__srmPurgeFromSpaceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmPurgeFromSpaceResponse **)soap_malloc(soap, sizeof(struct ns1__srmPurgeFromSpaceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmPurgeFromSpaceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmPurgeFromSpaceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmPurgeFromSpaceResponse, sizeof(struct ns1__srmPurgeFromSpaceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmPurgeFromSpaceResponse(struct soap *soap, struct ns1__srmPurgeFromSpaceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmPurgeFromSpaceResponse);
	if (soap_out_PointerTons1__srmPurgeFromSpaceResponse(soap, tag?tag:"ns1:srmPurgeFromSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmPurgeFromSpaceResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmPurgeFromSpaceResponse(struct soap *soap, struct ns1__srmPurgeFromSpaceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmPurgeFromSpaceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse_))
		soap_serialize_ns1__srmExtendFileLifeTimeInSpaceResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpaceResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeInSpaceResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmExtendFileLifeTimeInSpaceResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeInSpaceResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse_, sizeof(struct ns1__srmExtendFileLifeTimeInSpaceResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_);
	if (soap_out_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_(soap, tag?tag:"ns1:srmExtendFileLifeTimeInSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpaceResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceRequest))
		soap_serialize_ns1__srmExtendFileLifeTimeInSpaceRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, const char *tag, int id, struct ns1__srmExtendFileLifeTimeInSpaceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmExtendFileLifeTimeInSpaceRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpaceRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeInSpaceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmExtendFileLifeTimeInSpaceRequest **)soap_malloc(soap, sizeof(struct ns1__srmExtendFileLifeTimeInSpaceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmExtendFileLifeTimeInSpaceRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeInSpaceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceRequest, sizeof(struct ns1__srmExtendFileLifeTimeInSpaceRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeInSpaceRequest);
	if (soap_out_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(soap, tag?tag:"ns1:srmExtendFileLifeTimeInSpaceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpaceRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmExtendFileLifeTimeInSpaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse))
		soap_serialize_ns1__srmExtendFileLifeTimeInSpaceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, const char *tag, int id, struct ns1__srmExtendFileLifeTimeInSpaceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmExtendFileLifeTimeInSpaceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpaceResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, const char *tag, struct ns1__srmExtendFileLifeTimeInSpaceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmExtendFileLifeTimeInSpaceResponse **)soap_malloc(soap, sizeof(struct ns1__srmExtendFileLifeTimeInSpaceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmExtendFileLifeTimeInSpaceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmExtendFileLifeTimeInSpaceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmExtendFileLifeTimeInSpaceResponse, sizeof(struct ns1__srmExtendFileLifeTimeInSpaceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmExtendFileLifeTimeInSpaceResponse);
	if (soap_out_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(soap, tag?tag:"ns1:srmExtendFileLifeTimeInSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmExtendFileLifeTimeInSpaceResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, struct ns1__srmExtendFileLifeTimeInSpaceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmExtendFileLifeTimeInSpaceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_))
		soap_serialize_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse_, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_);
	if (soap_out_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag?tag:"ns1:srmStatusOfChangeSpaceForFilesRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestRequest))
		soap_serialize_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestRequest, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest);
	if (soap_out_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag?tag:"ns1:srmStatusOfChangeSpaceForFilesRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse))
		soap_serialize_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfChangeSpaceForFilesRequestResponse, sizeof(struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse);
	if (soap_out_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag?tag:"ns1:srmStatusOfChangeSpaceForFilesRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, struct ns1__srmStatusOfChangeSpaceForFilesRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmChangeSpaceForFilesResponse_(struct soap *soap, struct ns1__srmChangeSpaceForFilesResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse_))
		soap_serialize_ns1__srmChangeSpaceForFilesResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmChangeSpaceForFilesResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmChangeSpaceForFilesResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmChangeSpaceForFilesResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFilesResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmChangeSpaceForFilesResponse_(struct soap *soap, const char *tag, struct ns1__srmChangeSpaceForFilesResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmChangeSpaceForFilesResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmChangeSpaceForFilesResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmChangeSpaceForFilesResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmChangeSpaceForFilesResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse_, sizeof(struct ns1__srmChangeSpaceForFilesResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmChangeSpaceForFilesResponse_(struct soap *soap, struct ns1__srmChangeSpaceForFilesResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmChangeSpaceForFilesResponse_);
	if (soap_out_PointerTons1__srmChangeSpaceForFilesResponse_(soap, tag?tag:"ns1:srmChangeSpaceForFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFilesResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmChangeSpaceForFilesResponse_(struct soap *soap, struct ns1__srmChangeSpaceForFilesResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmChangeSpaceForFilesResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmChangeSpaceForFilesRequest(struct soap *soap, struct ns1__srmChangeSpaceForFilesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmChangeSpaceForFilesRequest))
		soap_serialize_ns1__srmChangeSpaceForFilesRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmChangeSpaceForFilesRequest(struct soap *soap, const char *tag, int id, struct ns1__srmChangeSpaceForFilesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmChangeSpaceForFilesRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmChangeSpaceForFilesRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFilesRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmChangeSpaceForFilesRequest(struct soap *soap, const char *tag, struct ns1__srmChangeSpaceForFilesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmChangeSpaceForFilesRequest **)soap_malloc(soap, sizeof(struct ns1__srmChangeSpaceForFilesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmChangeSpaceForFilesRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmChangeSpaceForFilesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmChangeSpaceForFilesRequest, sizeof(struct ns1__srmChangeSpaceForFilesRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmChangeSpaceForFilesRequest(struct soap *soap, struct ns1__srmChangeSpaceForFilesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmChangeSpaceForFilesRequest);
	if (soap_out_PointerTons1__srmChangeSpaceForFilesRequest(soap, tag?tag:"ns1:srmChangeSpaceForFilesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFilesRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmChangeSpaceForFilesRequest(struct soap *soap, struct ns1__srmChangeSpaceForFilesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmChangeSpaceForFilesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmChangeSpaceForFilesResponse(struct soap *soap, struct ns1__srmChangeSpaceForFilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse))
		soap_serialize_ns1__srmChangeSpaceForFilesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmChangeSpaceForFilesResponse(struct soap *soap, const char *tag, int id, struct ns1__srmChangeSpaceForFilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmChangeSpaceForFilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFilesResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmChangeSpaceForFilesResponse(struct soap *soap, const char *tag, struct ns1__srmChangeSpaceForFilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmChangeSpaceForFilesResponse **)soap_malloc(soap, sizeof(struct ns1__srmChangeSpaceForFilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmChangeSpaceForFilesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmChangeSpaceForFilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmChangeSpaceForFilesResponse, sizeof(struct ns1__srmChangeSpaceForFilesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmChangeSpaceForFilesResponse(struct soap *soap, struct ns1__srmChangeSpaceForFilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmChangeSpaceForFilesResponse);
	if (soap_out_PointerTons1__srmChangeSpaceForFilesResponse(soap, tag?tag:"ns1:srmChangeSpaceForFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmChangeSpaceForFilesResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmChangeSpaceForFilesResponse(struct soap *soap, struct ns1__srmChangeSpaceForFilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmChangeSpaceForFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetSpaceMetaDataResponse_(struct soap *soap, struct ns1__srmGetSpaceMetaDataResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse_))
		soap_serialize_ns1__srmGetSpaceMetaDataResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetSpaceMetaDataResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmGetSpaceMetaDataResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetSpaceMetaDataResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaDataResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmGetSpaceMetaDataResponse_(struct soap *soap, const char *tag, struct ns1__srmGetSpaceMetaDataResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetSpaceMetaDataResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmGetSpaceMetaDataResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetSpaceMetaDataResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceMetaDataResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse_, sizeof(struct ns1__srmGetSpaceMetaDataResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetSpaceMetaDataResponse_(struct soap *soap, struct ns1__srmGetSpaceMetaDataResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetSpaceMetaDataResponse_);
	if (soap_out_PointerTons1__srmGetSpaceMetaDataResponse_(soap, tag?tag:"ns1:srmGetSpaceMetaDataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaDataResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmGetSpaceMetaDataResponse_(struct soap *soap, struct ns1__srmGetSpaceMetaDataResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetSpaceMetaDataResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetSpaceMetaDataRequest(struct soap *soap, struct ns1__srmGetSpaceMetaDataRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetSpaceMetaDataRequest))
		soap_serialize_ns1__srmGetSpaceMetaDataRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetSpaceMetaDataRequest(struct soap *soap, const char *tag, int id, struct ns1__srmGetSpaceMetaDataRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetSpaceMetaDataRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetSpaceMetaDataRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaDataRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmGetSpaceMetaDataRequest(struct soap *soap, const char *tag, struct ns1__srmGetSpaceMetaDataRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetSpaceMetaDataRequest **)soap_malloc(soap, sizeof(struct ns1__srmGetSpaceMetaDataRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetSpaceMetaDataRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceMetaDataRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetSpaceMetaDataRequest, sizeof(struct ns1__srmGetSpaceMetaDataRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetSpaceMetaDataRequest(struct soap *soap, struct ns1__srmGetSpaceMetaDataRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetSpaceMetaDataRequest);
	if (soap_out_PointerTons1__srmGetSpaceMetaDataRequest(soap, tag?tag:"ns1:srmGetSpaceMetaDataRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaDataRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmGetSpaceMetaDataRequest(struct soap *soap, struct ns1__srmGetSpaceMetaDataRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetSpaceMetaDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmGetSpaceMetaDataResponse(struct soap *soap, struct ns1__srmGetSpaceMetaDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse))
		soap_serialize_ns1__srmGetSpaceMetaDataResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmGetSpaceMetaDataResponse(struct soap *soap, const char *tag, int id, struct ns1__srmGetSpaceMetaDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmGetSpaceMetaDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaDataResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmGetSpaceMetaDataResponse(struct soap *soap, const char *tag, struct ns1__srmGetSpaceMetaDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmGetSpaceMetaDataResponse **)soap_malloc(soap, sizeof(struct ns1__srmGetSpaceMetaDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmGetSpaceMetaDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmGetSpaceMetaDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmGetSpaceMetaDataResponse, sizeof(struct ns1__srmGetSpaceMetaDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmGetSpaceMetaDataResponse(struct soap *soap, struct ns1__srmGetSpaceMetaDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmGetSpaceMetaDataResponse);
	if (soap_out_PointerTons1__srmGetSpaceMetaDataResponse(soap, tag?tag:"ns1:srmGetSpaceMetaDataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmGetSpaceMetaDataResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmGetSpaceMetaDataResponse(struct soap *soap, struct ns1__srmGetSpaceMetaDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmGetSpaceMetaDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse_))
		soap_serialize_ns1__srmStatusOfUpdateSpaceRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfUpdateSpaceRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfUpdateSpaceRequestResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfUpdateSpaceRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse_, sizeof(struct ns1__srmStatusOfUpdateSpaceRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_);
	if (soap_out_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_(soap, tag?tag:"ns1:srmStatusOfUpdateSpaceRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestRequest))
		soap_serialize_ns1__srmStatusOfUpdateSpaceRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfUpdateSpaceRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfUpdateSpaceRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequestRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfUpdateSpaceRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfUpdateSpaceRequestRequest **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfUpdateSpaceRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfUpdateSpaceRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfUpdateSpaceRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestRequest, sizeof(struct ns1__srmStatusOfUpdateSpaceRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfUpdateSpaceRequestRequest);
	if (soap_out_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(soap, tag?tag:"ns1:srmStatusOfUpdateSpaceRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequestRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfUpdateSpaceRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse))
		soap_serialize_ns1__srmStatusOfUpdateSpaceRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfUpdateSpaceRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfUpdateSpaceRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequestResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfUpdateSpaceRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfUpdateSpaceRequestResponse **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfUpdateSpaceRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfUpdateSpaceRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfUpdateSpaceRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfUpdateSpaceRequestResponse, sizeof(struct ns1__srmStatusOfUpdateSpaceRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfUpdateSpaceRequestResponse);
	if (soap_out_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(soap, tag?tag:"ns1:srmStatusOfUpdateSpaceRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfUpdateSpaceRequestResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, struct ns1__srmStatusOfUpdateSpaceRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfUpdateSpaceRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmUpdateSpaceResponse_(struct soap *soap, struct ns1__srmUpdateSpaceResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmUpdateSpaceResponse_))
		soap_serialize_ns1__srmUpdateSpaceResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmUpdateSpaceResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmUpdateSpaceResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmUpdateSpaceResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmUpdateSpaceResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmUpdateSpaceResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmUpdateSpaceResponse_(struct soap *soap, const char *tag, struct ns1__srmUpdateSpaceResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmUpdateSpaceResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmUpdateSpaceResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmUpdateSpaceResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmUpdateSpaceResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmUpdateSpaceResponse_, sizeof(struct ns1__srmUpdateSpaceResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmUpdateSpaceResponse_(struct soap *soap, struct ns1__srmUpdateSpaceResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmUpdateSpaceResponse_);
	if (soap_out_PointerTons1__srmUpdateSpaceResponse_(soap, tag?tag:"ns1:srmUpdateSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmUpdateSpaceResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmUpdateSpaceResponse_(struct soap *soap, struct ns1__srmUpdateSpaceResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmUpdateSpaceResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmUpdateSpaceRequest(struct soap *soap, struct ns1__srmUpdateSpaceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmUpdateSpaceRequest))
		soap_serialize_ns1__srmUpdateSpaceRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmUpdateSpaceRequest(struct soap *soap, const char *tag, int id, struct ns1__srmUpdateSpaceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmUpdateSpaceRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmUpdateSpaceRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmUpdateSpaceRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmUpdateSpaceRequest(struct soap *soap, const char *tag, struct ns1__srmUpdateSpaceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmUpdateSpaceRequest **)soap_malloc(soap, sizeof(struct ns1__srmUpdateSpaceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmUpdateSpaceRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmUpdateSpaceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmUpdateSpaceRequest, sizeof(struct ns1__srmUpdateSpaceRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmUpdateSpaceRequest(struct soap *soap, struct ns1__srmUpdateSpaceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmUpdateSpaceRequest);
	if (soap_out_PointerTons1__srmUpdateSpaceRequest(soap, tag?tag:"ns1:srmUpdateSpaceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmUpdateSpaceRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmUpdateSpaceRequest(struct soap *soap, struct ns1__srmUpdateSpaceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmUpdateSpaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmUpdateSpaceResponse(struct soap *soap, struct ns1__srmUpdateSpaceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmUpdateSpaceResponse))
		soap_serialize_ns1__srmUpdateSpaceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmUpdateSpaceResponse(struct soap *soap, const char *tag, int id, struct ns1__srmUpdateSpaceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmUpdateSpaceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmUpdateSpaceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmUpdateSpaceResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmUpdateSpaceResponse(struct soap *soap, const char *tag, struct ns1__srmUpdateSpaceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmUpdateSpaceResponse **)soap_malloc(soap, sizeof(struct ns1__srmUpdateSpaceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmUpdateSpaceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmUpdateSpaceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmUpdateSpaceResponse, sizeof(struct ns1__srmUpdateSpaceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmUpdateSpaceResponse(struct soap *soap, struct ns1__srmUpdateSpaceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmUpdateSpaceResponse);
	if (soap_out_PointerTons1__srmUpdateSpaceResponse(soap, tag?tag:"ns1:srmUpdateSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmUpdateSpaceResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmUpdateSpaceResponse(struct soap *soap, struct ns1__srmUpdateSpaceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmUpdateSpaceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmReleaseSpaceResponse_(struct soap *soap, struct ns1__srmReleaseSpaceResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmReleaseSpaceResponse_))
		soap_serialize_ns1__srmReleaseSpaceResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmReleaseSpaceResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmReleaseSpaceResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmReleaseSpaceResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmReleaseSpaceResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmReleaseSpaceResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmReleaseSpaceResponse_(struct soap *soap, const char *tag, struct ns1__srmReleaseSpaceResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmReleaseSpaceResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmReleaseSpaceResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmReleaseSpaceResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseSpaceResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmReleaseSpaceResponse_, sizeof(struct ns1__srmReleaseSpaceResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmReleaseSpaceResponse_(struct soap *soap, struct ns1__srmReleaseSpaceResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmReleaseSpaceResponse_);
	if (soap_out_PointerTons1__srmReleaseSpaceResponse_(soap, tag?tag:"ns1:srmReleaseSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseSpaceResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmReleaseSpaceResponse_(struct soap *soap, struct ns1__srmReleaseSpaceResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmReleaseSpaceResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmReleaseSpaceRequest(struct soap *soap, struct ns1__srmReleaseSpaceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmReleaseSpaceRequest))
		soap_serialize_ns1__srmReleaseSpaceRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmReleaseSpaceRequest(struct soap *soap, const char *tag, int id, struct ns1__srmReleaseSpaceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmReleaseSpaceRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmReleaseSpaceRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmReleaseSpaceRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmReleaseSpaceRequest(struct soap *soap, const char *tag, struct ns1__srmReleaseSpaceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmReleaseSpaceRequest **)soap_malloc(soap, sizeof(struct ns1__srmReleaseSpaceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmReleaseSpaceRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseSpaceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmReleaseSpaceRequest, sizeof(struct ns1__srmReleaseSpaceRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmReleaseSpaceRequest(struct soap *soap, struct ns1__srmReleaseSpaceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmReleaseSpaceRequest);
	if (soap_out_PointerTons1__srmReleaseSpaceRequest(soap, tag?tag:"ns1:srmReleaseSpaceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseSpaceRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmReleaseSpaceRequest(struct soap *soap, struct ns1__srmReleaseSpaceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmReleaseSpaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmReleaseSpaceResponse(struct soap *soap, struct ns1__srmReleaseSpaceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmReleaseSpaceResponse))
		soap_serialize_ns1__srmReleaseSpaceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmReleaseSpaceResponse(struct soap *soap, const char *tag, int id, struct ns1__srmReleaseSpaceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmReleaseSpaceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmReleaseSpaceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmReleaseSpaceResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmReleaseSpaceResponse(struct soap *soap, const char *tag, struct ns1__srmReleaseSpaceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmReleaseSpaceResponse **)soap_malloc(soap, sizeof(struct ns1__srmReleaseSpaceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmReleaseSpaceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReleaseSpaceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmReleaseSpaceResponse, sizeof(struct ns1__srmReleaseSpaceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmReleaseSpaceResponse(struct soap *soap, struct ns1__srmReleaseSpaceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmReleaseSpaceResponse);
	if (soap_out_PointerTons1__srmReleaseSpaceResponse(soap, tag?tag:"ns1:srmReleaseSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReleaseSpaceResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmReleaseSpaceResponse(struct soap *soap, struct ns1__srmReleaseSpaceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmReleaseSpaceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse_))
		soap_serialize_ns1__srmStatusOfReserveSpaceRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfReserveSpaceRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfReserveSpaceRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, const char *tag, struct ns1__srmStatusOfReserveSpaceRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfReserveSpaceRequestResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfReserveSpaceRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfReserveSpaceRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfReserveSpaceRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse_, sizeof(struct ns1__srmStatusOfReserveSpaceRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfReserveSpaceRequestResponse_);
	if (soap_out_PointerTons1__srmStatusOfReserveSpaceRequestResponse_(soap, tag?tag:"ns1:srmStatusOfReserveSpaceRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfReserveSpaceRequestResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestRequest))
		soap_serialize_ns1__srmStatusOfReserveSpaceRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfReserveSpaceRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfReserveSpaceRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequestRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, const char *tag, struct ns1__srmStatusOfReserveSpaceRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfReserveSpaceRequestRequest **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfReserveSpaceRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfReserveSpaceRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfReserveSpaceRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestRequest, sizeof(struct ns1__srmStatusOfReserveSpaceRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfReserveSpaceRequestRequest);
	if (soap_out_PointerTons1__srmStatusOfReserveSpaceRequestRequest(soap, tag?tag:"ns1:srmStatusOfReserveSpaceRequestRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequestRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfReserveSpaceRequestRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse))
		soap_serialize_ns1__srmStatusOfReserveSpaceRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, const char *tag, int id, struct ns1__srmStatusOfReserveSpaceRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmStatusOfReserveSpaceRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequestResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, const char *tag, struct ns1__srmStatusOfReserveSpaceRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmStatusOfReserveSpaceRequestResponse **)soap_malloc(soap, sizeof(struct ns1__srmStatusOfReserveSpaceRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmStatusOfReserveSpaceRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmStatusOfReserveSpaceRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmStatusOfReserveSpaceRequestResponse, sizeof(struct ns1__srmStatusOfReserveSpaceRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmStatusOfReserveSpaceRequestResponse);
	if (soap_out_PointerTons1__srmStatusOfReserveSpaceRequestResponse(soap, tag?tag:"ns1:srmStatusOfReserveSpaceRequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmStatusOfReserveSpaceRequestResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, struct ns1__srmStatusOfReserveSpaceRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmStatusOfReserveSpaceRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmReserveSpaceResponse_(struct soap *soap, struct ns1__srmReserveSpaceResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmReserveSpaceResponse_))
		soap_serialize_ns1__srmReserveSpaceResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmReserveSpaceResponse_(struct soap *soap, const char *tag, int id, struct ns1__srmReserveSpaceResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmReserveSpaceResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmReserveSpaceResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmReserveSpaceResponse_ ** SOAP_FMAC4 soap_in_PointerTons1__srmReserveSpaceResponse_(struct soap *soap, const char *tag, struct ns1__srmReserveSpaceResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmReserveSpaceResponse_ **)soap_malloc(soap, sizeof(struct ns1__srmReserveSpaceResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmReserveSpaceResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReserveSpaceResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmReserveSpaceResponse_, sizeof(struct ns1__srmReserveSpaceResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmReserveSpaceResponse_(struct soap *soap, struct ns1__srmReserveSpaceResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmReserveSpaceResponse_);
	if (soap_out_PointerTons1__srmReserveSpaceResponse_(soap, tag?tag:"ns1:srmReserveSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReserveSpaceResponse_ ** SOAP_FMAC4 soap_get_PointerTons1__srmReserveSpaceResponse_(struct soap *soap, struct ns1__srmReserveSpaceResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmReserveSpaceResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmReserveSpaceRequest(struct soap *soap, struct ns1__srmReserveSpaceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmReserveSpaceRequest))
		soap_serialize_ns1__srmReserveSpaceRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmReserveSpaceRequest(struct soap *soap, const char *tag, int id, struct ns1__srmReserveSpaceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmReserveSpaceRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmReserveSpaceRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmReserveSpaceRequest ** SOAP_FMAC4 soap_in_PointerTons1__srmReserveSpaceRequest(struct soap *soap, const char *tag, struct ns1__srmReserveSpaceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmReserveSpaceRequest **)soap_malloc(soap, sizeof(struct ns1__srmReserveSpaceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmReserveSpaceRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReserveSpaceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmReserveSpaceRequest, sizeof(struct ns1__srmReserveSpaceRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmReserveSpaceRequest(struct soap *soap, struct ns1__srmReserveSpaceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmReserveSpaceRequest);
	if (soap_out_PointerTons1__srmReserveSpaceRequest(soap, tag?tag:"ns1:srmReserveSpaceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReserveSpaceRequest ** SOAP_FMAC4 soap_get_PointerTons1__srmReserveSpaceRequest(struct soap *soap, struct ns1__srmReserveSpaceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmReserveSpaceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__srmReserveSpaceResponse(struct soap *soap, struct ns1__srmReserveSpaceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__srmReserveSpaceResponse))
		soap_serialize_ns1__srmReserveSpaceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__srmReserveSpaceResponse(struct soap *soap, const char *tag, int id, struct ns1__srmReserveSpaceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__srmReserveSpaceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__srmReserveSpaceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__srmReserveSpaceResponse ** SOAP_FMAC4 soap_in_PointerTons1__srmReserveSpaceResponse(struct soap *soap, const char *tag, struct ns1__srmReserveSpaceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__srmReserveSpaceResponse **)soap_malloc(soap, sizeof(struct ns1__srmReserveSpaceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__srmReserveSpaceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__srmReserveSpaceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__srmReserveSpaceResponse, sizeof(struct ns1__srmReserveSpaceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__srmReserveSpaceResponse(struct soap *soap, struct ns1__srmReserveSpaceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__srmReserveSpaceResponse);
	if (soap_out_PointerTons1__srmReserveSpaceResponse(soap, tag?tag:"ns1:srmReserveSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__srmReserveSpaceResponse ** SOAP_FMAC4 soap_get_PointerTons1__srmReserveSpaceResponse(struct soap *soap, struct ns1__srmReserveSpaceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__srmReserveSpaceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTSupportedTransferProtocol(struct soap *soap, struct ns1__ArrayOfTSupportedTransferProtocol *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTSupportedTransferProtocol))
		soap_serialize_ns1__ArrayOfTSupportedTransferProtocol(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTSupportedTransferProtocol(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTSupportedTransferProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTSupportedTransferProtocol);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTSupportedTransferProtocol(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTSupportedTransferProtocol ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTSupportedTransferProtocol(struct soap *soap, const char *tag, struct ns1__ArrayOfTSupportedTransferProtocol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTSupportedTransferProtocol **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTSupportedTransferProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTSupportedTransferProtocol(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTSupportedTransferProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTSupportedTransferProtocol, sizeof(struct ns1__ArrayOfTSupportedTransferProtocol), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTSupportedTransferProtocol(struct soap *soap, struct ns1__ArrayOfTSupportedTransferProtocol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTSupportedTransferProtocol);
	if (soap_out_PointerTons1__ArrayOfTSupportedTransferProtocol(soap, tag?tag:"ns1:ArrayOfTSupportedTransferProtocol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTSupportedTransferProtocol ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTSupportedTransferProtocol(struct soap *soap, struct ns1__ArrayOfTSupportedTransferProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTSupportedTransferProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTRequestTokenReturn(struct soap *soap, struct ns1__ArrayOfTRequestTokenReturn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTRequestTokenReturn))
		soap_serialize_ns1__ArrayOfTRequestTokenReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTRequestTokenReturn(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTRequestTokenReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTRequestTokenReturn);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTRequestTokenReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTRequestTokenReturn ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTRequestTokenReturn(struct soap *soap, const char *tag, struct ns1__ArrayOfTRequestTokenReturn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTRequestTokenReturn **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTRequestTokenReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTRequestTokenReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTRequestTokenReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTRequestTokenReturn, sizeof(struct ns1__ArrayOfTRequestTokenReturn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTRequestTokenReturn(struct soap *soap, struct ns1__ArrayOfTRequestTokenReturn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTRequestTokenReturn);
	if (soap_out_PointerTons1__ArrayOfTRequestTokenReturn(soap, tag?tag:"ns1:ArrayOfTRequestTokenReturn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTRequestTokenReturn ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTRequestTokenReturn(struct soap *soap, struct ns1__ArrayOfTRequestTokenReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTRequestTokenReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTRequestSummary(struct soap *soap, struct ns1__ArrayOfTRequestSummary *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTRequestSummary))
		soap_serialize_ns1__ArrayOfTRequestSummary(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTRequestSummary(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTRequestSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTRequestSummary);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTRequestSummary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTRequestSummary ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTRequestSummary(struct soap *soap, const char *tag, struct ns1__ArrayOfTRequestSummary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTRequestSummary **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTRequestSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTRequestSummary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTRequestSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTRequestSummary, sizeof(struct ns1__ArrayOfTRequestSummary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTRequestSummary(struct soap *soap, struct ns1__ArrayOfTRequestSummary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTRequestSummary);
	if (soap_out_PointerTons1__ArrayOfTRequestSummary(soap, tag?tag:"ns1:ArrayOfTRequestSummary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTRequestSummary ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTRequestSummary(struct soap *soap, struct ns1__ArrayOfTRequestSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTRequestSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTCopyRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTCopyRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTCopyRequestFileStatus))
		soap_serialize_ns1__ArrayOfTCopyRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTCopyRequestFileStatus(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTCopyRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTCopyRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTCopyRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTCopyRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTCopyRequestFileStatus(struct soap *soap, const char *tag, struct ns1__ArrayOfTCopyRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTCopyRequestFileStatus **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTCopyRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTCopyRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTCopyRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTCopyRequestFileStatus, sizeof(struct ns1__ArrayOfTCopyRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTCopyRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTCopyRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTCopyRequestFileStatus);
	if (soap_out_PointerTons1__ArrayOfTCopyRequestFileStatus(soap, tag?tag:"ns1:ArrayOfTCopyRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTCopyRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTCopyRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTCopyRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTCopyRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTCopyFileRequest(struct soap *soap, struct ns1__ArrayOfTCopyFileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTCopyFileRequest))
		soap_serialize_ns1__ArrayOfTCopyFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTCopyFileRequest(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTCopyFileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTCopyFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTCopyFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTCopyFileRequest ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTCopyFileRequest(struct soap *soap, const char *tag, struct ns1__ArrayOfTCopyFileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTCopyFileRequest **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTCopyFileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTCopyFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTCopyFileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTCopyFileRequest, sizeof(struct ns1__ArrayOfTCopyFileRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTCopyFileRequest(struct soap *soap, struct ns1__ArrayOfTCopyFileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTCopyFileRequest);
	if (soap_out_PointerTons1__ArrayOfTCopyFileRequest(soap, tag?tag:"ns1:ArrayOfTCopyFileRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTCopyFileRequest ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTCopyFileRequest(struct soap *soap, struct ns1__ArrayOfTCopyFileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTCopyFileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTPutRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTPutRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTPutRequestFileStatus))
		soap_serialize_ns1__ArrayOfTPutRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTPutRequestFileStatus(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTPutRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTPutRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTPutRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTPutRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTPutRequestFileStatus(struct soap *soap, const char *tag, struct ns1__ArrayOfTPutRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTPutRequestFileStatus **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTPutRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTPutRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTPutRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTPutRequestFileStatus, sizeof(struct ns1__ArrayOfTPutRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTPutRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTPutRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTPutRequestFileStatus);
	if (soap_out_PointerTons1__ArrayOfTPutRequestFileStatus(soap, tag?tag:"ns1:ArrayOfTPutRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTPutRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTPutRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTPutRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTPutRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TOverwriteMode(struct soap *soap, enum ns1__TOverwriteMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__TOverwriteMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TOverwriteMode(struct soap *soap, const char *tag, int id, enum ns1__TOverwriteMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TOverwriteMode);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TOverwriteMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__TOverwriteMode ** SOAP_FMAC4 soap_in_PointerTons1__TOverwriteMode(struct soap *soap, const char *tag, enum ns1__TOverwriteMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__TOverwriteMode **)soap_malloc(soap, sizeof(enum ns1__TOverwriteMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TOverwriteMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__TOverwriteMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TOverwriteMode, sizeof(enum ns1__TOverwriteMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TOverwriteMode(struct soap *soap, enum ns1__TOverwriteMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TOverwriteMode);
	if (soap_out_PointerTons1__TOverwriteMode(soap, tag?tag:"ns1:TOverwriteMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TOverwriteMode ** SOAP_FMAC4 soap_get_PointerTons1__TOverwriteMode(struct soap *soap, enum ns1__TOverwriteMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TOverwriteMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTPutFileRequest(struct soap *soap, struct ns1__ArrayOfTPutFileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTPutFileRequest))
		soap_serialize_ns1__ArrayOfTPutFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTPutFileRequest(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTPutFileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTPutFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTPutFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTPutFileRequest ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTPutFileRequest(struct soap *soap, const char *tag, struct ns1__ArrayOfTPutFileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTPutFileRequest **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTPutFileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTPutFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTPutFileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTPutFileRequest, sizeof(struct ns1__ArrayOfTPutFileRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTPutFileRequest(struct soap *soap, struct ns1__ArrayOfTPutFileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTPutFileRequest);
	if (soap_out_PointerTons1__ArrayOfTPutFileRequest(soap, tag?tag:"ns1:ArrayOfTPutFileRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTPutFileRequest ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTPutFileRequest(struct soap *soap, struct ns1__ArrayOfTPutFileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTPutFileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTBringOnlineRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTBringOnlineRequestFileStatus))
		soap_serialize_ns1__ArrayOfTBringOnlineRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTBringOnlineRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTBringOnlineRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTBringOnlineRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTBringOnlineRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, const char *tag, struct ns1__ArrayOfTBringOnlineRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTBringOnlineRequestFileStatus **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTBringOnlineRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTBringOnlineRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTBringOnlineRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTBringOnlineRequestFileStatus, sizeof(struct ns1__ArrayOfTBringOnlineRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTBringOnlineRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTBringOnlineRequestFileStatus);
	if (soap_out_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(soap, tag?tag:"ns1:ArrayOfTBringOnlineRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTBringOnlineRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTBringOnlineRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTBringOnlineRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTGetRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTGetRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTGetRequestFileStatus))
		soap_serialize_ns1__ArrayOfTGetRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTGetRequestFileStatus(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTGetRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTGetRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTGetRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTGetRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTGetRequestFileStatus(struct soap *soap, const char *tag, struct ns1__ArrayOfTGetRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTGetRequestFileStatus **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTGetRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTGetRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTGetRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTGetRequestFileStatus, sizeof(struct ns1__ArrayOfTGetRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTGetRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTGetRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTGetRequestFileStatus);
	if (soap_out_PointerTons1__ArrayOfTGetRequestFileStatus(soap, tag?tag:"ns1:ArrayOfTGetRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTGetRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTGetRequestFileStatus(struct soap *soap, struct ns1__ArrayOfTGetRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTGetRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTGetFileRequest(struct soap *soap, struct ns1__ArrayOfTGetFileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTGetFileRequest))
		soap_serialize_ns1__ArrayOfTGetFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTGetFileRequest(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTGetFileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTGetFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTGetFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTGetFileRequest ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTGetFileRequest(struct soap *soap, const char *tag, struct ns1__ArrayOfTGetFileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTGetFileRequest **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTGetFileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTGetFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTGetFileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTGetFileRequest, sizeof(struct ns1__ArrayOfTGetFileRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTGetFileRequest(struct soap *soap, struct ns1__ArrayOfTGetFileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTGetFileRequest);
	if (soap_out_PointerTons1__ArrayOfTGetFileRequest(soap, tag?tag:"ns1:ArrayOfTGetFileRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTGetFileRequest ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTGetFileRequest(struct soap *soap, struct ns1__ArrayOfTGetFileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTGetFileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTPermissionReturn(struct soap *soap, struct ns1__ArrayOfTPermissionReturn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTPermissionReturn))
		soap_serialize_ns1__ArrayOfTPermissionReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTPermissionReturn(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTPermissionReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTPermissionReturn);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTPermissionReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTPermissionReturn ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTPermissionReturn(struct soap *soap, const char *tag, struct ns1__ArrayOfTPermissionReturn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTPermissionReturn **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTPermissionReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTPermissionReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTPermissionReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTPermissionReturn, sizeof(struct ns1__ArrayOfTPermissionReturn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTPermissionReturn(struct soap *soap, struct ns1__ArrayOfTPermissionReturn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTPermissionReturn);
	if (soap_out_PointerTons1__ArrayOfTPermissionReturn(soap, tag?tag:"ns1:ArrayOfTPermissionReturn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTPermissionReturn ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTPermissionReturn(struct soap *soap, struct ns1__ArrayOfTPermissionReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTPermissionReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTSURLPermissionReturn(struct soap *soap, struct ns1__ArrayOfTSURLPermissionReturn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTSURLPermissionReturn))
		soap_serialize_ns1__ArrayOfTSURLPermissionReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTSURLPermissionReturn(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTSURLPermissionReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTSURLPermissionReturn);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTSURLPermissionReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTSURLPermissionReturn ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTSURLPermissionReturn(struct soap *soap, const char *tag, struct ns1__ArrayOfTSURLPermissionReturn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTSURLPermissionReturn **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTSURLPermissionReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTSURLPermissionReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTSURLPermissionReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTSURLPermissionReturn, sizeof(struct ns1__ArrayOfTSURLPermissionReturn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTSURLPermissionReturn(struct soap *soap, struct ns1__ArrayOfTSURLPermissionReturn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTSURLPermissionReturn);
	if (soap_out_PointerTons1__ArrayOfTSURLPermissionReturn(soap, tag?tag:"ns1:ArrayOfTSURLPermissionReturn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTSURLPermissionReturn ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTSURLPermissionReturn(struct soap *soap, struct ns1__ArrayOfTSURLPermissionReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTSURLPermissionReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, struct ns1__ArrayOfTSURLLifetimeReturnStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTSURLLifetimeReturnStatus))
		soap_serialize_ns1__ArrayOfTSURLLifetimeReturnStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTSURLLifetimeReturnStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTSURLLifetimeReturnStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTSURLLifetimeReturnStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTSURLLifetimeReturnStatus ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, const char *tag, struct ns1__ArrayOfTSURLLifetimeReturnStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTSURLLifetimeReturnStatus **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTSURLLifetimeReturnStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTSURLLifetimeReturnStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTSURLLifetimeReturnStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTSURLLifetimeReturnStatus, sizeof(struct ns1__ArrayOfTSURLLifetimeReturnStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, struct ns1__ArrayOfTSURLLifetimeReturnStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTSURLLifetimeReturnStatus);
	if (soap_out_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(soap, tag?tag:"ns1:ArrayOfTSURLLifetimeReturnStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTSURLLifetimeReturnStatus ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, struct ns1__ArrayOfTSURLLifetimeReturnStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTSURLLifetimeReturnStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTSURLReturnStatus(struct soap *soap, struct ns1__ArrayOfTSURLReturnStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTSURLReturnStatus))
		soap_serialize_ns1__ArrayOfTSURLReturnStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTSURLReturnStatus(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTSURLReturnStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTSURLReturnStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTSURLReturnStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTSURLReturnStatus ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTSURLReturnStatus(struct soap *soap, const char *tag, struct ns1__ArrayOfTSURLReturnStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTSURLReturnStatus **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTSURLReturnStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTSURLReturnStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTSURLReturnStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTSURLReturnStatus, sizeof(struct ns1__ArrayOfTSURLReturnStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTSURLReturnStatus(struct soap *soap, struct ns1__ArrayOfTSURLReturnStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTSURLReturnStatus);
	if (soap_out_PointerTons1__ArrayOfTSURLReturnStatus(soap, tag?tag:"ns1:ArrayOfTSURLReturnStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTSURLReturnStatus ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTSURLReturnStatus(struct soap *soap, struct ns1__ArrayOfTSURLReturnStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTSURLReturnStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfAnyURI(struct soap *soap, struct ns1__ArrayOfAnyURI *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfAnyURI))
		soap_serialize_ns1__ArrayOfAnyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfAnyURI(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfAnyURI *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfAnyURI);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfAnyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfAnyURI ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfAnyURI(struct soap *soap, const char *tag, struct ns1__ArrayOfAnyURI **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfAnyURI **)soap_malloc(soap, sizeof(struct ns1__ArrayOfAnyURI *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfAnyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfAnyURI **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfAnyURI, sizeof(struct ns1__ArrayOfAnyURI), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfAnyURI(struct soap *soap, struct ns1__ArrayOfAnyURI *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfAnyURI);
	if (soap_out_PointerTons1__ArrayOfAnyURI(soap, tag?tag:"ns1:ArrayOfAnyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfAnyURI ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfAnyURI(struct soap *soap, struct ns1__ArrayOfAnyURI **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfAnyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTMetaDataSpace(struct soap *soap, struct ns1__ArrayOfTMetaDataSpace *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTMetaDataSpace))
		soap_serialize_ns1__ArrayOfTMetaDataSpace(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTMetaDataSpace(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTMetaDataSpace *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTMetaDataSpace);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTMetaDataSpace(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTMetaDataSpace ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTMetaDataSpace(struct soap *soap, const char *tag, struct ns1__ArrayOfTMetaDataSpace **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTMetaDataSpace **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTMetaDataSpace *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTMetaDataSpace(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTMetaDataSpace **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTMetaDataSpace, sizeof(struct ns1__ArrayOfTMetaDataSpace), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTMetaDataSpace(struct soap *soap, struct ns1__ArrayOfTMetaDataSpace *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTMetaDataSpace);
	if (soap_out_PointerTons1__ArrayOfTMetaDataSpace(soap, tag?tag:"ns1:ArrayOfTMetaDataSpace", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTMetaDataSpace ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTMetaDataSpace(struct soap *soap, struct ns1__ArrayOfTMetaDataSpace **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTMetaDataSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TTransferParameters(struct soap *soap, struct ns1__TTransferParameters *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TTransferParameters))
		soap_serialize_ns1__TTransferParameters(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TTransferParameters(struct soap *soap, const char *tag, int id, struct ns1__TTransferParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TTransferParameters);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TTransferParameters(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TTransferParameters ** SOAP_FMAC4 soap_in_PointerTons1__TTransferParameters(struct soap *soap, const char *tag, struct ns1__TTransferParameters **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TTransferParameters **)soap_malloc(soap, sizeof(struct ns1__TTransferParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TTransferParameters(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TTransferParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TTransferParameters, sizeof(struct ns1__TTransferParameters), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TTransferParameters(struct soap *soap, struct ns1__TTransferParameters *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TTransferParameters);
	if (soap_out_PointerTons1__TTransferParameters(soap, tag?tag:"ns1:TTransferParameters", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TTransferParameters ** SOAP_FMAC4 soap_get_PointerTons1__TTransferParameters(struct soap *soap, struct ns1__TTransferParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TTransferParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfUnsignedLong(struct soap *soap, struct ns1__ArrayOfUnsignedLong *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfUnsignedLong))
		soap_serialize_ns1__ArrayOfUnsignedLong(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfUnsignedLong(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfUnsignedLong *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfUnsignedLong);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfUnsignedLong(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfUnsignedLong ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfUnsignedLong(struct soap *soap, const char *tag, struct ns1__ArrayOfUnsignedLong **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfUnsignedLong **)soap_malloc(soap, sizeof(struct ns1__ArrayOfUnsignedLong *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfUnsignedLong(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfUnsignedLong **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfUnsignedLong, sizeof(struct ns1__ArrayOfUnsignedLong), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfUnsignedLong(struct soap *soap, struct ns1__ArrayOfUnsignedLong *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfUnsignedLong);
	if (soap_out_PointerTons1__ArrayOfUnsignedLong(soap, tag?tag:"ns1:ArrayOfUnsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfUnsignedLong ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfUnsignedLong(struct soap *soap, struct ns1__ArrayOfUnsignedLong **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfUnsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TSupportedTransferProtocol(struct soap *soap, struct ns1__TSupportedTransferProtocol *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TSupportedTransferProtocol))
		soap_serialize_ns1__TSupportedTransferProtocol(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TSupportedTransferProtocol(struct soap *soap, const char *tag, int id, struct ns1__TSupportedTransferProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TSupportedTransferProtocol);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TSupportedTransferProtocol(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TSupportedTransferProtocol ** SOAP_FMAC4 soap_in_PointerTons1__TSupportedTransferProtocol(struct soap *soap, const char *tag, struct ns1__TSupportedTransferProtocol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TSupportedTransferProtocol **)soap_malloc(soap, sizeof(struct ns1__TSupportedTransferProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TSupportedTransferProtocol(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TSupportedTransferProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TSupportedTransferProtocol, sizeof(struct ns1__TSupportedTransferProtocol), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TSupportedTransferProtocol(struct soap *soap, struct ns1__TSupportedTransferProtocol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TSupportedTransferProtocol);
	if (soap_out_PointerTons1__TSupportedTransferProtocol(soap, tag?tag:"ns1:TSupportedTransferProtocol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TSupportedTransferProtocol ** SOAP_FMAC4 soap_get_PointerTons1__TSupportedTransferProtocol(struct soap *soap, struct ns1__TSupportedTransferProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TSupportedTransferProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TRequestTokenReturn(struct soap *soap, struct ns1__TRequestTokenReturn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TRequestTokenReturn))
		soap_serialize_ns1__TRequestTokenReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TRequestTokenReturn(struct soap *soap, const char *tag, int id, struct ns1__TRequestTokenReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TRequestTokenReturn);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TRequestTokenReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TRequestTokenReturn ** SOAP_FMAC4 soap_in_PointerTons1__TRequestTokenReturn(struct soap *soap, const char *tag, struct ns1__TRequestTokenReturn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TRequestTokenReturn **)soap_malloc(soap, sizeof(struct ns1__TRequestTokenReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TRequestTokenReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TRequestTokenReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TRequestTokenReturn, sizeof(struct ns1__TRequestTokenReturn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TRequestTokenReturn(struct soap *soap, struct ns1__TRequestTokenReturn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TRequestTokenReturn);
	if (soap_out_PointerTons1__TRequestTokenReturn(soap, tag?tag:"ns1:TRequestTokenReturn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TRequestTokenReturn ** SOAP_FMAC4 soap_get_PointerTons1__TRequestTokenReturn(struct soap *soap, struct ns1__TRequestTokenReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TRequestTokenReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TPermissionReturn(struct soap *soap, struct ns1__TPermissionReturn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TPermissionReturn))
		soap_serialize_ns1__TPermissionReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TPermissionReturn(struct soap *soap, const char *tag, int id, struct ns1__TPermissionReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TPermissionReturn);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TPermissionReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TPermissionReturn ** SOAP_FMAC4 soap_in_PointerTons1__TPermissionReturn(struct soap *soap, const char *tag, struct ns1__TPermissionReturn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TPermissionReturn **)soap_malloc(soap, sizeof(struct ns1__TPermissionReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TPermissionReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TPermissionReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TPermissionReturn, sizeof(struct ns1__TPermissionReturn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TPermissionReturn(struct soap *soap, struct ns1__TPermissionReturn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TPermissionReturn);
	if (soap_out_PointerTons1__TPermissionReturn(soap, tag?tag:"ns1:TPermissionReturn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TPermissionReturn ** SOAP_FMAC4 soap_get_PointerTons1__TPermissionReturn(struct soap *soap, struct ns1__TPermissionReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TPermissionReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTGroupPermission(struct soap *soap, struct ns1__ArrayOfTGroupPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTGroupPermission))
		soap_serialize_ns1__ArrayOfTGroupPermission(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTGroupPermission(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTGroupPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTGroupPermission);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTGroupPermission(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTGroupPermission ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTGroupPermission(struct soap *soap, const char *tag, struct ns1__ArrayOfTGroupPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTGroupPermission **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTGroupPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTGroupPermission(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTGroupPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTGroupPermission, sizeof(struct ns1__ArrayOfTGroupPermission), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTGroupPermission(struct soap *soap, struct ns1__ArrayOfTGroupPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTGroupPermission);
	if (soap_out_PointerTons1__ArrayOfTGroupPermission(soap, tag?tag:"ns1:ArrayOfTGroupPermission", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTGroupPermission ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTGroupPermission(struct soap *soap, struct ns1__ArrayOfTGroupPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTGroupPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTUserPermission(struct soap *soap, struct ns1__ArrayOfTUserPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTUserPermission))
		soap_serialize_ns1__ArrayOfTUserPermission(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTUserPermission(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTUserPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTUserPermission);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTUserPermission(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTUserPermission ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTUserPermission(struct soap *soap, const char *tag, struct ns1__ArrayOfTUserPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTUserPermission **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTUserPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTUserPermission(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTUserPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTUserPermission, sizeof(struct ns1__ArrayOfTUserPermission), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTUserPermission(struct soap *soap, struct ns1__ArrayOfTUserPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTUserPermission);
	if (soap_out_PointerTons1__ArrayOfTUserPermission(soap, tag?tag:"ns1:ArrayOfTUserPermission", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTUserPermission ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTUserPermission(struct soap *soap, struct ns1__ArrayOfTUserPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTUserPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TSURLPermissionReturn(struct soap *soap, struct ns1__TSURLPermissionReturn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TSURLPermissionReturn))
		soap_serialize_ns1__TSURLPermissionReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TSURLPermissionReturn(struct soap *soap, const char *tag, int id, struct ns1__TSURLPermissionReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TSURLPermissionReturn);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TSURLPermissionReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TSURLPermissionReturn ** SOAP_FMAC4 soap_in_PointerTons1__TSURLPermissionReturn(struct soap *soap, const char *tag, struct ns1__TSURLPermissionReturn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TSURLPermissionReturn **)soap_malloc(soap, sizeof(struct ns1__TSURLPermissionReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TSURLPermissionReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TSURLPermissionReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TSURLPermissionReturn, sizeof(struct ns1__TSURLPermissionReturn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TSURLPermissionReturn(struct soap *soap, struct ns1__TSURLPermissionReturn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TSURLPermissionReturn);
	if (soap_out_PointerTons1__TSURLPermissionReturn(soap, tag?tag:"ns1:TSURLPermissionReturn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TSURLPermissionReturn ** SOAP_FMAC4 soap_get_PointerTons1__TSURLPermissionReturn(struct soap *soap, struct ns1__TSURLPermissionReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TSURLPermissionReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TRequestSummary(struct soap *soap, struct ns1__TRequestSummary *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TRequestSummary))
		soap_serialize_ns1__TRequestSummary(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TRequestSummary(struct soap *soap, const char *tag, int id, struct ns1__TRequestSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TRequestSummary);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TRequestSummary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TRequestSummary ** SOAP_FMAC4 soap_in_PointerTons1__TRequestSummary(struct soap *soap, const char *tag, struct ns1__TRequestSummary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TRequestSummary **)soap_malloc(soap, sizeof(struct ns1__TRequestSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TRequestSummary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TRequestSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TRequestSummary, sizeof(struct ns1__TRequestSummary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TRequestSummary(struct soap *soap, struct ns1__TRequestSummary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TRequestSummary);
	if (soap_out_PointerTons1__TRequestSummary(soap, tag?tag:"ns1:TRequestSummary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TRequestSummary ** SOAP_FMAC4 soap_get_PointerTons1__TRequestSummary(struct soap *soap, struct ns1__TRequestSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TRequestSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TRequestType(struct soap *soap, enum ns1__TRequestType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__TRequestType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TRequestType(struct soap *soap, const char *tag, int id, enum ns1__TRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TRequestType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TRequestType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__TRequestType ** SOAP_FMAC4 soap_in_PointerTons1__TRequestType(struct soap *soap, const char *tag, enum ns1__TRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__TRequestType **)soap_malloc(soap, sizeof(enum ns1__TRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TRequestType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__TRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TRequestType, sizeof(enum ns1__TRequestType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TRequestType(struct soap *soap, enum ns1__TRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TRequestType);
	if (soap_out_PointerTons1__TRequestType(soap, tag?tag:"ns1:TRequestType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TRequestType ** SOAP_FMAC4 soap_get_PointerTons1__TRequestType(struct soap *soap, enum ns1__TRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TCopyRequestFileStatus(struct soap *soap, struct ns1__TCopyRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TCopyRequestFileStatus))
		soap_serialize_ns1__TCopyRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TCopyRequestFileStatus(struct soap *soap, const char *tag, int id, struct ns1__TCopyRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TCopyRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TCopyRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TCopyRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTons1__TCopyRequestFileStatus(struct soap *soap, const char *tag, struct ns1__TCopyRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TCopyRequestFileStatus **)soap_malloc(soap, sizeof(struct ns1__TCopyRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TCopyRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TCopyRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TCopyRequestFileStatus, sizeof(struct ns1__TCopyRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TCopyRequestFileStatus(struct soap *soap, struct ns1__TCopyRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TCopyRequestFileStatus);
	if (soap_out_PointerTons1__TCopyRequestFileStatus(soap, tag?tag:"ns1:TCopyRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TCopyRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTons1__TCopyRequestFileStatus(struct soap *soap, struct ns1__TCopyRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TCopyRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TPutRequestFileStatus(struct soap *soap, struct ns1__TPutRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TPutRequestFileStatus))
		soap_serialize_ns1__TPutRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TPutRequestFileStatus(struct soap *soap, const char *tag, int id, struct ns1__TPutRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TPutRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TPutRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TPutRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTons1__TPutRequestFileStatus(struct soap *soap, const char *tag, struct ns1__TPutRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TPutRequestFileStatus **)soap_malloc(soap, sizeof(struct ns1__TPutRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TPutRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TPutRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TPutRequestFileStatus, sizeof(struct ns1__TPutRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TPutRequestFileStatus(struct soap *soap, struct ns1__TPutRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TPutRequestFileStatus);
	if (soap_out_PointerTons1__TPutRequestFileStatus(soap, tag?tag:"ns1:TPutRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TPutRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTons1__TPutRequestFileStatus(struct soap *soap, struct ns1__TPutRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TPutRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TBringOnlineRequestFileStatus(struct soap *soap, struct ns1__TBringOnlineRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TBringOnlineRequestFileStatus))
		soap_serialize_ns1__TBringOnlineRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TBringOnlineRequestFileStatus(struct soap *soap, const char *tag, int id, struct ns1__TBringOnlineRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TBringOnlineRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TBringOnlineRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TBringOnlineRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTons1__TBringOnlineRequestFileStatus(struct soap *soap, const char *tag, struct ns1__TBringOnlineRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TBringOnlineRequestFileStatus **)soap_malloc(soap, sizeof(struct ns1__TBringOnlineRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TBringOnlineRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TBringOnlineRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TBringOnlineRequestFileStatus, sizeof(struct ns1__TBringOnlineRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TBringOnlineRequestFileStatus(struct soap *soap, struct ns1__TBringOnlineRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TBringOnlineRequestFileStatus);
	if (soap_out_PointerTons1__TBringOnlineRequestFileStatus(soap, tag?tag:"ns1:TBringOnlineRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TBringOnlineRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTons1__TBringOnlineRequestFileStatus(struct soap *soap, struct ns1__TBringOnlineRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TBringOnlineRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TGetRequestFileStatus(struct soap *soap, struct ns1__TGetRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TGetRequestFileStatus))
		soap_serialize_ns1__TGetRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TGetRequestFileStatus(struct soap *soap, const char *tag, int id, struct ns1__TGetRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TGetRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TGetRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TGetRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTons1__TGetRequestFileStatus(struct soap *soap, const char *tag, struct ns1__TGetRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TGetRequestFileStatus **)soap_malloc(soap, sizeof(struct ns1__TGetRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TGetRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TGetRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TGetRequestFileStatus, sizeof(struct ns1__TGetRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TGetRequestFileStatus(struct soap *soap, struct ns1__TGetRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TGetRequestFileStatus);
	if (soap_out_PointerTons1__TGetRequestFileStatus(soap, tag?tag:"ns1:TGetRequestFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TGetRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTons1__TGetRequestFileStatus(struct soap *soap, struct ns1__TGetRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TGetRequestFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTExtraInfo(struct soap *soap, struct ns1__ArrayOfTExtraInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTExtraInfo))
		soap_serialize_ns1__ArrayOfTExtraInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTExtraInfo(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTExtraInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTExtraInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTExtraInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTExtraInfo ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTExtraInfo(struct soap *soap, const char *tag, struct ns1__ArrayOfTExtraInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTExtraInfo **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTExtraInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTExtraInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTExtraInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTExtraInfo, sizeof(struct ns1__ArrayOfTExtraInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTExtraInfo(struct soap *soap, struct ns1__ArrayOfTExtraInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTExtraInfo);
	if (soap_out_PointerTons1__ArrayOfTExtraInfo(soap, tag?tag:"ns1:ArrayOfTExtraInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTExtraInfo ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTExtraInfo(struct soap *soap, struct ns1__ArrayOfTExtraInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTExtraInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TCopyFileRequest(struct soap *soap, struct ns1__TCopyFileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TCopyFileRequest))
		soap_serialize_ns1__TCopyFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TCopyFileRequest(struct soap *soap, const char *tag, int id, struct ns1__TCopyFileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TCopyFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TCopyFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TCopyFileRequest ** SOAP_FMAC4 soap_in_PointerTons1__TCopyFileRequest(struct soap *soap, const char *tag, struct ns1__TCopyFileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TCopyFileRequest **)soap_malloc(soap, sizeof(struct ns1__TCopyFileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TCopyFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TCopyFileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TCopyFileRequest, sizeof(struct ns1__TCopyFileRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TCopyFileRequest(struct soap *soap, struct ns1__TCopyFileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TCopyFileRequest);
	if (soap_out_PointerTons1__TCopyFileRequest(soap, tag?tag:"ns1:TCopyFileRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TCopyFileRequest ** SOAP_FMAC4 soap_get_PointerTons1__TCopyFileRequest(struct soap *soap, struct ns1__TCopyFileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TCopyFileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TPutFileRequest(struct soap *soap, struct ns1__TPutFileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TPutFileRequest))
		soap_serialize_ns1__TPutFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TPutFileRequest(struct soap *soap, const char *tag, int id, struct ns1__TPutFileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TPutFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TPutFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TPutFileRequest ** SOAP_FMAC4 soap_in_PointerTons1__TPutFileRequest(struct soap *soap, const char *tag, struct ns1__TPutFileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TPutFileRequest **)soap_malloc(soap, sizeof(struct ns1__TPutFileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TPutFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TPutFileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TPutFileRequest, sizeof(struct ns1__TPutFileRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TPutFileRequest(struct soap *soap, struct ns1__TPutFileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TPutFileRequest);
	if (soap_out_PointerTons1__TPutFileRequest(soap, tag?tag:"ns1:TPutFileRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TPutFileRequest ** SOAP_FMAC4 soap_get_PointerTons1__TPutFileRequest(struct soap *soap, struct ns1__TPutFileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TPutFileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TGetFileRequest(struct soap *soap, struct ns1__TGetFileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TGetFileRequest))
		soap_serialize_ns1__TGetFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TGetFileRequest(struct soap *soap, const char *tag, int id, struct ns1__TGetFileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TGetFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TGetFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TGetFileRequest ** SOAP_FMAC4 soap_in_PointerTons1__TGetFileRequest(struct soap *soap, const char *tag, struct ns1__TGetFileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TGetFileRequest **)soap_malloc(soap, sizeof(struct ns1__TGetFileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TGetFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TGetFileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TGetFileRequest, sizeof(struct ns1__TGetFileRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TGetFileRequest(struct soap *soap, struct ns1__TGetFileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TGetFileRequest);
	if (soap_out_PointerTons1__TGetFileRequest(soap, tag?tag:"ns1:TGetFileRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TGetFileRequest ** SOAP_FMAC4 soap_get_PointerTons1__TGetFileRequest(struct soap *soap, struct ns1__TGetFileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TGetFileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TDirOption(struct soap *soap, struct ns1__TDirOption *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TDirOption))
		soap_serialize_ns1__TDirOption(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TDirOption(struct soap *soap, const char *tag, int id, struct ns1__TDirOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TDirOption);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TDirOption(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TDirOption ** SOAP_FMAC4 soap_in_PointerTons1__TDirOption(struct soap *soap, const char *tag, struct ns1__TDirOption **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TDirOption **)soap_malloc(soap, sizeof(struct ns1__TDirOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TDirOption(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TDirOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TDirOption, sizeof(struct ns1__TDirOption), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TDirOption(struct soap *soap, struct ns1__TDirOption *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TDirOption);
	if (soap_out_PointerTons1__TDirOption(soap, tag?tag:"ns1:TDirOption", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TDirOption ** SOAP_FMAC4 soap_get_PointerTons1__TDirOption(struct soap *soap, struct ns1__TDirOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TDirOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TConnectionType(struct soap *soap, enum ns1__TConnectionType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__TConnectionType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TConnectionType(struct soap *soap, const char *tag, int id, enum ns1__TConnectionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TConnectionType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TConnectionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__TConnectionType ** SOAP_FMAC4 soap_in_PointerTons1__TConnectionType(struct soap *soap, const char *tag, enum ns1__TConnectionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__TConnectionType **)soap_malloc(soap, sizeof(enum ns1__TConnectionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TConnectionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__TConnectionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TConnectionType, sizeof(enum ns1__TConnectionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TConnectionType(struct soap *soap, enum ns1__TConnectionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TConnectionType);
	if (soap_out_PointerTons1__TConnectionType(soap, tag?tag:"ns1:TConnectionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TConnectionType ** SOAP_FMAC4 soap_get_PointerTons1__TConnectionType(struct soap *soap, enum ns1__TConnectionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TConnectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TAccessPattern(struct soap *soap, enum ns1__TAccessPattern *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__TAccessPattern);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TAccessPattern(struct soap *soap, const char *tag, int id, enum ns1__TAccessPattern *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TAccessPattern);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TAccessPattern(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__TAccessPattern ** SOAP_FMAC4 soap_in_PointerTons1__TAccessPattern(struct soap *soap, const char *tag, enum ns1__TAccessPattern **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__TAccessPattern **)soap_malloc(soap, sizeof(enum ns1__TAccessPattern *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TAccessPattern(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__TAccessPattern **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TAccessPattern, sizeof(enum ns1__TAccessPattern), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TAccessPattern(struct soap *soap, enum ns1__TAccessPattern *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TAccessPattern);
	if (soap_out_PointerTons1__TAccessPattern(soap, tag?tag:"ns1:TAccessPattern", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TAccessPattern ** SOAP_FMAC4 soap_get_PointerTons1__TAccessPattern(struct soap *soap, enum ns1__TAccessPattern **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TAccessPattern(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TExtraInfo(struct soap *soap, struct ns1__TExtraInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TExtraInfo))
		soap_serialize_ns1__TExtraInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TExtraInfo(struct soap *soap, const char *tag, int id, struct ns1__TExtraInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TExtraInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TExtraInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TExtraInfo ** SOAP_FMAC4 soap_in_PointerTons1__TExtraInfo(struct soap *soap, const char *tag, struct ns1__TExtraInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TExtraInfo **)soap_malloc(soap, sizeof(struct ns1__TExtraInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TExtraInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TExtraInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TExtraInfo, sizeof(struct ns1__TExtraInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TExtraInfo(struct soap *soap, struct ns1__TExtraInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TExtraInfo);
	if (soap_out_PointerTons1__TExtraInfo(soap, tag?tag:"ns1:TExtraInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TExtraInfo ** SOAP_FMAC4 soap_get_PointerTons1__TExtraInfo(struct soap *soap, struct ns1__TExtraInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TExtraInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TMetaDataSpace(struct soap *soap, struct ns1__TMetaDataSpace *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TMetaDataSpace))
		soap_serialize_ns1__TMetaDataSpace(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TMetaDataSpace(struct soap *soap, const char *tag, int id, struct ns1__TMetaDataSpace *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TMetaDataSpace);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TMetaDataSpace(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TMetaDataSpace ** SOAP_FMAC4 soap_in_PointerTons1__TMetaDataSpace(struct soap *soap, const char *tag, struct ns1__TMetaDataSpace **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TMetaDataSpace **)soap_malloc(soap, sizeof(struct ns1__TMetaDataSpace *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TMetaDataSpace(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TMetaDataSpace **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TMetaDataSpace, sizeof(struct ns1__TMetaDataSpace), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TMetaDataSpace(struct soap *soap, struct ns1__TMetaDataSpace *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TMetaDataSpace);
	if (soap_out_PointerTons1__TMetaDataSpace(soap, tag?tag:"ns1:TMetaDataSpace", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TMetaDataSpace ** SOAP_FMAC4 soap_get_PointerTons1__TMetaDataSpace(struct soap *soap, struct ns1__TMetaDataSpace **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TMetaDataSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TMetaDataPathDetail(struct soap *soap, struct ns1__TMetaDataPathDetail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TMetaDataPathDetail))
		soap_serialize_ns1__TMetaDataPathDetail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TMetaDataPathDetail(struct soap *soap, const char *tag, int id, struct ns1__TMetaDataPathDetail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TMetaDataPathDetail);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TMetaDataPathDetail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TMetaDataPathDetail ** SOAP_FMAC4 soap_in_PointerTons1__TMetaDataPathDetail(struct soap *soap, const char *tag, struct ns1__TMetaDataPathDetail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TMetaDataPathDetail **)soap_malloc(soap, sizeof(struct ns1__TMetaDataPathDetail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TMetaDataPathDetail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TMetaDataPathDetail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TMetaDataPathDetail, sizeof(struct ns1__TMetaDataPathDetail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TMetaDataPathDetail(struct soap *soap, struct ns1__TMetaDataPathDetail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TMetaDataPathDetail);
	if (soap_out_PointerTons1__TMetaDataPathDetail(soap, tag?tag:"ns1:TMetaDataPathDetail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TMetaDataPathDetail ** SOAP_FMAC4 soap_get_PointerTons1__TMetaDataPathDetail(struct soap *soap, struct ns1__TMetaDataPathDetail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TMetaDataPathDetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTMetaDataPathDetail(struct soap *soap, struct ns1__ArrayOfTMetaDataPathDetail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTMetaDataPathDetail))
		soap_serialize_ns1__ArrayOfTMetaDataPathDetail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTMetaDataPathDetail(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTMetaDataPathDetail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTMetaDataPathDetail);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTMetaDataPathDetail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTMetaDataPathDetail ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTMetaDataPathDetail(struct soap *soap, const char *tag, struct ns1__ArrayOfTMetaDataPathDetail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTMetaDataPathDetail **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTMetaDataPathDetail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfTMetaDataPathDetail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTMetaDataPathDetail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTMetaDataPathDetail, sizeof(struct ns1__ArrayOfTMetaDataPathDetail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTMetaDataPathDetail(struct soap *soap, struct ns1__ArrayOfTMetaDataPathDetail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTMetaDataPathDetail);
	if (soap_out_PointerTons1__ArrayOfTMetaDataPathDetail(soap, tag?tag:"ns1:ArrayOfTMetaDataPathDetail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTMetaDataPathDetail ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTMetaDataPathDetail(struct soap *soap, struct ns1__ArrayOfTMetaDataPathDetail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTMetaDataPathDetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TPermissionMode(struct soap *soap, enum ns1__TPermissionMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__TPermissionMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TPermissionMode(struct soap *soap, const char *tag, int id, enum ns1__TPermissionMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TPermissionMode);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TPermissionMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__TPermissionMode ** SOAP_FMAC4 soap_in_PointerTons1__TPermissionMode(struct soap *soap, const char *tag, enum ns1__TPermissionMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__TPermissionMode **)soap_malloc(soap, sizeof(enum ns1__TPermissionMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TPermissionMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__TPermissionMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TPermissionMode, sizeof(enum ns1__TPermissionMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TPermissionMode(struct soap *soap, enum ns1__TPermissionMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TPermissionMode);
	if (soap_out_PointerTons1__TPermissionMode(soap, tag?tag:"ns1:TPermissionMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TPermissionMode ** SOAP_FMAC4 soap_get_PointerTons1__TPermissionMode(struct soap *soap, enum ns1__TPermissionMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TPermissionMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TFileType(struct soap *soap, enum ns1__TFileType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__TFileType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TFileType(struct soap *soap, const char *tag, int id, enum ns1__TFileType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TFileType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TFileType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__TFileType ** SOAP_FMAC4 soap_in_PointerTons1__TFileType(struct soap *soap, const char *tag, enum ns1__TFileType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__TFileType **)soap_malloc(soap, sizeof(enum ns1__TFileType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TFileType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__TFileType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TFileType, sizeof(enum ns1__TFileType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TFileType(struct soap *soap, enum ns1__TFileType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TFileType);
	if (soap_out_PointerTons1__TFileType(soap, tag?tag:"ns1:TFileType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TFileType ** SOAP_FMAC4 soap_get_PointerTons1__TFileType(struct soap *soap, enum ns1__TFileType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TFileType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfString(struct soap *soap, struct ns1__ArrayOfString *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfString))
		soap_serialize_ns1__ArrayOfString(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfString);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfString(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfString ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, struct ns1__ArrayOfString **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfString **)soap_malloc(soap, sizeof(struct ns1__ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfString(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfString, sizeof(struct ns1__ArrayOfString), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfString(struct soap *soap, struct ns1__ArrayOfString *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfString);
	if (soap_out_PointerTons1__ArrayOfString(soap, tag?tag:"ns1:ArrayOfString", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfString ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfString(struct soap *soap, struct ns1__ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TFileLocality(struct soap *soap, enum ns1__TFileLocality *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__TFileLocality);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TFileLocality(struct soap *soap, const char *tag, int id, enum ns1__TFileLocality *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TFileLocality);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TFileLocality(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__TFileLocality ** SOAP_FMAC4 soap_in_PointerTons1__TFileLocality(struct soap *soap, const char *tag, enum ns1__TFileLocality **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__TFileLocality **)soap_malloc(soap, sizeof(enum ns1__TFileLocality *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TFileLocality(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__TFileLocality **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TFileLocality, sizeof(enum ns1__TFileLocality), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TFileLocality(struct soap *soap, enum ns1__TFileLocality *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TFileLocality);
	if (soap_out_PointerTons1__TFileLocality(soap, tag?tag:"ns1:TFileLocality", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TFileLocality ** SOAP_FMAC4 soap_get_PointerTons1__TFileLocality(struct soap *soap, enum ns1__TFileLocality **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TFileLocality(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TRetentionPolicyInfo(struct soap *soap, struct ns1__TRetentionPolicyInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TRetentionPolicyInfo))
		soap_serialize_ns1__TRetentionPolicyInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TRetentionPolicyInfo(struct soap *soap, const char *tag, int id, struct ns1__TRetentionPolicyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TRetentionPolicyInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TRetentionPolicyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TRetentionPolicyInfo ** SOAP_FMAC4 soap_in_PointerTons1__TRetentionPolicyInfo(struct soap *soap, const char *tag, struct ns1__TRetentionPolicyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TRetentionPolicyInfo **)soap_malloc(soap, sizeof(struct ns1__TRetentionPolicyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TRetentionPolicyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TRetentionPolicyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TRetentionPolicyInfo, sizeof(struct ns1__TRetentionPolicyInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TRetentionPolicyInfo(struct soap *soap, struct ns1__TRetentionPolicyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TRetentionPolicyInfo);
	if (soap_out_PointerTons1__TRetentionPolicyInfo(soap, tag?tag:"ns1:TRetentionPolicyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TRetentionPolicyInfo ** SOAP_FMAC4 soap_get_PointerTons1__TRetentionPolicyInfo(struct soap *soap, struct ns1__TRetentionPolicyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TRetentionPolicyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TFileStorageType(struct soap *soap, enum ns1__TFileStorageType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__TFileStorageType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TFileStorageType(struct soap *soap, const char *tag, int id, enum ns1__TFileStorageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TFileStorageType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TFileStorageType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__TFileStorageType ** SOAP_FMAC4 soap_in_PointerTons1__TFileStorageType(struct soap *soap, const char *tag, enum ns1__TFileStorageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__TFileStorageType **)soap_malloc(soap, sizeof(enum ns1__TFileStorageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TFileStorageType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__TFileStorageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TFileStorageType, sizeof(enum ns1__TFileStorageType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TFileStorageType(struct soap *soap, enum ns1__TFileStorageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TFileStorageType);
	if (soap_out_PointerTons1__TFileStorageType(soap, tag?tag:"ns1:TFileStorageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TFileStorageType ** SOAP_FMAC4 soap_get_PointerTons1__TFileStorageType(struct soap *soap, enum ns1__TFileStorageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TFileStorageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TSURLLifetimeReturnStatus(struct soap *soap, struct ns1__TSURLLifetimeReturnStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TSURLLifetimeReturnStatus))
		soap_serialize_ns1__TSURLLifetimeReturnStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TSURLLifetimeReturnStatus(struct soap *soap, const char *tag, int id, struct ns1__TSURLLifetimeReturnStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TSURLLifetimeReturnStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TSURLLifetimeReturnStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TSURLLifetimeReturnStatus ** SOAP_FMAC4 soap_in_PointerTons1__TSURLLifetimeReturnStatus(struct soap *soap, const char *tag, struct ns1__TSURLLifetimeReturnStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TSURLLifetimeReturnStatus **)soap_malloc(soap, sizeof(struct ns1__TSURLLifetimeReturnStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TSURLLifetimeReturnStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TSURLLifetimeReturnStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TSURLLifetimeReturnStatus, sizeof(struct ns1__TSURLLifetimeReturnStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TSURLLifetimeReturnStatus(struct soap *soap, struct ns1__TSURLLifetimeReturnStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TSURLLifetimeReturnStatus);
	if (soap_out_PointerTons1__TSURLLifetimeReturnStatus(soap, tag?tag:"ns1:TSURLLifetimeReturnStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TSURLLifetimeReturnStatus ** SOAP_FMAC4 soap_get_PointerTons1__TSURLLifetimeReturnStatus(struct soap *soap, struct ns1__TSURLLifetimeReturnStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TSURLLifetimeReturnStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TSURLReturnStatus(struct soap *soap, struct ns1__TSURLReturnStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TSURLReturnStatus))
		soap_serialize_ns1__TSURLReturnStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TSURLReturnStatus(struct soap *soap, const char *tag, int id, struct ns1__TSURLReturnStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TSURLReturnStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TSURLReturnStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TSURLReturnStatus ** SOAP_FMAC4 soap_in_PointerTons1__TSURLReturnStatus(struct soap *soap, const char *tag, struct ns1__TSURLReturnStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TSURLReturnStatus **)soap_malloc(soap, sizeof(struct ns1__TSURLReturnStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TSURLReturnStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TSURLReturnStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TSURLReturnStatus, sizeof(struct ns1__TSURLReturnStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TSURLReturnStatus(struct soap *soap, struct ns1__TSURLReturnStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TSURLReturnStatus);
	if (soap_out_PointerTons1__TSURLReturnStatus(soap, tag?tag:"ns1:TSURLReturnStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TSURLReturnStatus ** SOAP_FMAC4 soap_get_PointerTons1__TSURLReturnStatus(struct soap *soap, struct ns1__TSURLReturnStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TSURLReturnStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TReturnStatus(struct soap *soap, struct ns1__TReturnStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TReturnStatus))
		soap_serialize_ns1__TReturnStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TReturnStatus(struct soap *soap, const char *tag, int id, struct ns1__TReturnStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TReturnStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TReturnStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TReturnStatus ** SOAP_FMAC4 soap_in_PointerTons1__TReturnStatus(struct soap *soap, const char *tag, struct ns1__TReturnStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TReturnStatus **)soap_malloc(soap, sizeof(struct ns1__TReturnStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TReturnStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TReturnStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TReturnStatus, sizeof(struct ns1__TReturnStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TReturnStatus(struct soap *soap, struct ns1__TReturnStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TReturnStatus);
	if (soap_out_PointerTons1__TReturnStatus(soap, tag?tag:"ns1:TReturnStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TReturnStatus ** SOAP_FMAC4 soap_get_PointerTons1__TReturnStatus(struct soap *soap, struct ns1__TReturnStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TReturnStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedLONG64(struct soap *soap, const char *tag, int id, ULONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedLONG64);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedLONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_in_PointerTounsignedLONG64(struct soap *soap, const char *tag, ULONG64 **a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ULONG64 **)soap_malloc(soap, sizeof(ULONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);

		if (!(*a = soap_in_unsignedLONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedLONG64, sizeof(ULONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedLONG64);
	if (soap_out_PointerTounsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_get_PointerTounsignedLONG64(struct soap *soap, ULONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TGroupPermission(struct soap *soap, struct ns1__TGroupPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TGroupPermission))
		soap_serialize_ns1__TGroupPermission(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TGroupPermission(struct soap *soap, const char *tag, int id, struct ns1__TGroupPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TGroupPermission);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TGroupPermission(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TGroupPermission ** SOAP_FMAC4 soap_in_PointerTons1__TGroupPermission(struct soap *soap, const char *tag, struct ns1__TGroupPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TGroupPermission **)soap_malloc(soap, sizeof(struct ns1__TGroupPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TGroupPermission(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TGroupPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TGroupPermission, sizeof(struct ns1__TGroupPermission), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TGroupPermission(struct soap *soap, struct ns1__TGroupPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TGroupPermission);
	if (soap_out_PointerTons1__TGroupPermission(soap, tag?tag:"ns1:TGroupPermission", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TGroupPermission ** SOAP_FMAC4 soap_get_PointerTons1__TGroupPermission(struct soap *soap, struct ns1__TGroupPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TGroupPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TUserPermission(struct soap *soap, struct ns1__TUserPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TUserPermission))
		soap_serialize_ns1__TUserPermission(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TUserPermission(struct soap *soap, const char *tag, int id, struct ns1__TUserPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TUserPermission);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TUserPermission(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TUserPermission ** SOAP_FMAC4 soap_in_PointerTons1__TUserPermission(struct soap *soap, const char *tag, struct ns1__TUserPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TUserPermission **)soap_malloc(soap, sizeof(struct ns1__TUserPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TUserPermission(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TUserPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TUserPermission, sizeof(struct ns1__TUserPermission), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TUserPermission(struct soap *soap, struct ns1__TUserPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TUserPermission);
	if (soap_out_PointerTons1__TUserPermission(soap, tag?tag:"ns1:TUserPermission", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TUserPermission ** SOAP_FMAC4 soap_get_PointerTons1__TUserPermission(struct soap *soap, struct ns1__TUserPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TUserPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TAccessLatency(struct soap *soap, enum ns1__TAccessLatency *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__TAccessLatency);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TAccessLatency(struct soap *soap, const char *tag, int id, enum ns1__TAccessLatency *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TAccessLatency);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TAccessLatency(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__TAccessLatency ** SOAP_FMAC4 soap_in_PointerTons1__TAccessLatency(struct soap *soap, const char *tag, enum ns1__TAccessLatency **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__TAccessLatency **)soap_malloc(soap, sizeof(enum ns1__TAccessLatency *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TAccessLatency(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__TAccessLatency **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TAccessLatency, sizeof(enum ns1__TAccessLatency), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TAccessLatency(struct soap *soap, enum ns1__TAccessLatency *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TAccessLatency);
	if (soap_out_PointerTons1__TAccessLatency(soap, tag?tag:"ns1:TAccessLatency", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TAccessLatency ** SOAP_FMAC4 soap_get_PointerTons1__TAccessLatency(struct soap *soap, enum ns1__TAccessLatency **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TAccessLatency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
