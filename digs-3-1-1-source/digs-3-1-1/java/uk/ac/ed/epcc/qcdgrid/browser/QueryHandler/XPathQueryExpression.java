/*
 * Copyright (c) 2002 The University of Edinburgh. All rights reserved.
 *
 * Released under the OGSA-DAI Project Software Licence.
 * Please refer to licence.txt for full project software licence.
 */

package uk.ac.ed.epcc.qcdgrid.browser.QueryHandler;

import java.util.*;
import javax.swing.tree.*;

/**
 * Title: XPathQueryExpression Description: An XPathQueryExpression represents
 * an XPath expression. It holds a vector of AtomicXPathQueryExpressions and a
 * (user defined) name which is used when displaying the query in the list of
 * the main window. Copyright: Copyright (c) 2002 Company: The University of
 * Edinburgh
 * 
 * @author Amy Krause
 * @version 1.0
 */

public class XPathQueryExpression {

    /** a collection of AtomicXPathQueryExpressions */
    private Vector queries;

    /** the name of this query */
    private String name = null;

    /** type of this query */
    private String type = null;

    /** whether query name is autogenerated */
    private boolean autoNamed = false;

    /** Constructs an empty XPathQueryExpression */
    public XPathQueryExpression() {
	queries = new Vector();
    }

    /**
     * Constructs an XPathQueryExpression from a template tree node, a predicate
     * string and a name
     * 
     * @param node
     *          a template tree node representing the path
     * @param pred
     *          a predicate string
     * @param n
     *          the name of the query
     */
    public XPathQueryExpression(DefaultMutableTreeNode node, String pred,
				String n, String t) {
	queries = new Vector();
	AtomicXPathQueryExpression query = new AtomicXPathQueryExpression(node,
									  pred);
	// if no name was specified, the XPath expression is used as default
	if (n == null || n.equals("")) {
	    name = query.toXPathString();
	    autoNamed = true;
	}
	else {
	    name = n;
	}
	type = t;
	queries.add(query);
    }
    
    /**
     * Constructs an XPathQueryExpression from a name and a vector of
     * AtomicXPathQueryExpressions. Used in loading queries off disk
     * 
     * @param n
     *          the name for the query
     * @param atoms
     *          a Vector of Atomic expressions making up the query
     */
    public XPathQueryExpression(String n, Vector atoms, String t, boolean an) {
	name = n;
	queries = atoms;
	type = t;
	autoNamed = an;
    }
    
    public XPathQueryExpression(String n, Vector atoms, String t) {
	name = n;
	queries = atoms;
	type = t;
	autoNamed = false;
    }

    /**
     * Constructs an XPathQueryExpression from an arbitrary query string and a
     * name
     * 
     * @param q
     *          an arbitrary query string
     * @param n
     *          the name of the query
     */
    public XPathQueryExpression(String q, String n, String t) {
	queries = new Vector();
	AtomicXPathQueryExpression query = new AtomicXPathQueryExpression(q);
	// if no name was specified, the XPath expression is used as default
	if (n == null || n.equals("")) {
	    name = query.toXPathString();
	    autoNamed = true;
	}
	else
	    name = n;
	type = t;
	queries.add(query);
    }
    
    /** @return the collection of AtomicXPathQueries */
    public Vector getQuery() {
	return queries;
    }
    
    /** @return true if the query is empty */
    public boolean isEmpty() {
	return queries.isEmpty();
    }
    
    /**
     * Sets the name of this query
     * 
     * @param n
     *          the name to assign to this query
     */
    public void setName(String n) {
	name = n;
	autoNamed = false;
    }

    public void setName(String n, boolean an) {
	name = n;
	autoNamed = an;
    }

    public String getName() {
	return name;
    }
    
    public boolean isAutoNamed() {
	return autoNamed;
    }

    public void setType(String t){
	type = t;
    }
    
    public String getType() {
	return type;
    }
    
    /**
     * combine this query with another by extending the queries vector
     * 
     * @param q
     *          a query which will be combined with this query
     */
    public void add(XPathQueryExpression q) {
	queries.addAll(q.queries);
	if (name != null)
	    name = name + " AND " + q.name;
	else
	    name = q.name;
	autoNamed = false;
    }
    
    private int queryDepth(String q) {
	int i = 0;
	int depth = 0;
	int nesting = 0;
	
	while (i < q.length()) {
	    if ((q.charAt(i) == '/') && (nesting == 0)) {
		if ((q.charAt(i + 1) == '.') && (q.charAt(i + 2) == '.')) {
		    depth--;
		} else {
		    depth++;
		}
	    }
	    if (q.charAt(i) == '[') {
		nesting++;
	    }
	    if (q.charAt(i) == ']') {
		nesting--;
	    }
	    
	    i++;
	}
	return depth;
    }
    
    private String topLevelQuery(String q) {
	int depth = queryDepth(q);
	
	//for (int i=0; i<depth; i++) { q+="/.."; }
	
	return q;
    }
    
    private String combineQueries(String q1, String q2) {
	int depth1 = queryDepth(q1);
	
	String result = q1;

	for (int i = 0; i < (depth1 - 1); i++) {
	    result += "/..";
	}

	if (q2.charAt(0) != '/') {
	    return null;
	}

	int secondSlash = q2.indexOf('/', 1);

	if (secondSlash < 0) {
	    return result;
	}

	result += q2.substring(secondSlash);
	
	return result;
    }

    /**
     * Builds a valid XPath query from the queries vector
     * 
     * @param prefix
     *          to be inserted before every AtomicXPathQueryExpression
     * @param postfix
     *          to be inserted after every AtomicXPathQueryExpression
     * @param namespace
     *          the namespace (prefix) to use
     * @return an XPath query string
     */
    public String toXPathString(String prefix, String postfix, String namespace) {

	AtomicXPathQueryExpression query;
	String result = "";

	if (queries.size() == 1) {
	    query = (AtomicXPathQueryExpression) queries.elementAt(0);
	    result = query.toXPathString(namespace);
	}
	else {

	    query = (AtomicXPathQueryExpression) queries.elementAt(0);
	    result = query.toXPathString(namespace);

	    for (int i = 1; i < queries.size(); i++) {
		query = (AtomicXPathQueryExpression) queries.elementAt(i);
		result = combineQueries(result, query.toXPathString(namespace));
	    }
	}

	/*ListIterator queriesIterator = queries.listIterator();
	AtomicXPathQueryExpression query;
	String result = "";
	while (queriesIterator.hasNext()) {
	    query = (AtomicXPathQueryExpression) queriesIterator.next();
	    result += prefix + topLevelQuery(query.toXPathString(namespace))
		+ postfix;
	}
	*/
	System.out.println("Returning XPath: " + result);

	return result;
    }
    
    public String toXPathString(String prefix, String postfix, String namespace,
				String extraQuery) {
	String result = toXPathString(prefix, postfix, namespace);

	result = combineQueries(result, extraQuery);

	return result;
    }

    /**
     * Builds a valid XPath query from the queries vector
     * 
     * @return an XPath query string
     */
    public String toXPathString() {
	return toXPathString("", "", "");
    }
    
    /** @return the name of the query */
    public String toString() {
	return name;
    }
    
    private String quoteSymbols(String str) {
	int i;
	
	i = str.indexOf('&');
	while (i >= 0) {
	    str = str.substring(0, i) + "&amp;" + str.substring(i + 1);
	    i = str.indexOf('&', i + 1);
	}
	
	i = str.indexOf('>');
	while (i >= 0) {
	    str = str.substring(0, i) + "&gt;" + str.substring(i + 1);
	    i = str.indexOf('>');
	}
	
	i = str.indexOf('<');
	while (i >= 0) {
	    str = str.substring(0, i) + "&lt;" + str.substring(i + 1);
	    i = str.indexOf('<');
	}
	
	i = str.indexOf('"');
	while (i >= 0) {
	    str = str.substring(0, i) + "&quot;" + str.substring(i + 1);
	    i = str.indexOf('"');
	}
	
	i = str.indexOf('\'');
	while (i >= 0) {
	    str = str.substring(0, i) + "&apos;" + str.substring(i + 1);
	    i = str.indexOf('\'');
	}
	
	return str;
    }
    
    /** @return an XML representation of the query suitable for saving */
    public String toXML() {
	String xml;
	
	xml = "<query><name>" + quoteSymbols(name) + "</name>";
	
	xml = xml + "<type>" + type + "</type>";

	if (autoNamed) {
	    xml = xml + "<auto_named>true</auto_named>";
	}
	else {
	    xml = xml + "<auto_named>false</auto_named>";
	}
	
	for (int i = 0; i < queries.size(); i++) {
	    AtomicXPathQueryExpression query = (AtomicXPathQueryExpression) queries
		.elementAt(i);
	    xml = xml + query.toXML();
	}
	
	xml = xml + "</query>";
	
	return xml;
    }

    public boolean isPlainText() {
	if (queries.size() == 1) {
	    AtomicXPathQueryExpression query = (AtomicXPathQueryExpression) queries.elementAt(0);
	    return query.isPlainText();
	}
	return false;
    }
}
